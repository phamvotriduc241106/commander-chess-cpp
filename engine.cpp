/*
 * Commander Chess (Cờ Tư Lệnh) — C++ Port with SDL2
 * ====================================================
 * Player side is selectable in the mode menu (Red or Blue).
 *
 * ── 2026 Strength Upgrade Summary (~+180 Elo target) ──────────────────────
 *  1) Advanced Threat Evaluation (~+80 Elo):
 *     hanging/undefended pressure, cross-domain attack bonuses, carrier
 *     unload threat potential, commander attack amplification, and
 *     win-condition piece targeting.
 *  2) Terrain-Aware Correction History (~+70 Elo):
 *     adds terrain/control/stacking/commander-water context to correction
 *     history for stronger fortress recognition and eval stability.
 *  3) Low-Depth Fortress & Special Draw Recognizer (~+30 Elo):
 *     detects low-depth fortress deadlocks, variant-specific decisive states,
 *     and carrier-loop draw patterns in AB + QSearch.
 *
 * ── Search Engine ───────────────────────────────────────────────────────────
 * Built from scratch for Commander Chess rules; incorporates all major
 * Stockfish 18 search techniques adapted to this game's 12×11 board,
 * 11-piece-type ruleset, and multi-domain terrain (land/sea/sky):
 *
 *  • Lazy SMP — full multi-threaded iterative deepening with shared TT
 *  • PVS (Principal Variation Search) with asymmetric aspiration windows
 *  • LMR (Late Move Reduction) — SF18-tuned formula: ln(d)·ln(m)/2.0
 *  • NMP (Null Move Pruning) with adaptive reduction
 *  • SEE (Static Exchange Evaluation) pruning in both AB and QSearch
 *  • Reverse Futility Pruning extended to depth 4 (SF18)
 *  • Razoring (depths 1–3) + Probcut (depths 5+)
 *  • Singular/Double-Singular/Negative Extensions
 *  • Correction History — SF18 position + material hash correction of
 *    static eval; improves RFP/Razoring/Futility/LMR accuracy
 *  • Node-count time extension — extends search when best move changes
 *    (mirrors SF18's bestMoveChanges time manager)
 *  • In-check quiescence — commander evasions searched in QSearch (SF18)
 *  • IIR (Internal Iterative Reduction)
 *  • Improving heuristic (2-ply eval comparison)
 *  • Transposition Table (two-bucket, age-aware replacement)
 *  • Killer/Countermove/History/Continuation-History heuristics
 *  • MCTS + Alpha-Beta hybrid (AlphaZero-style root)
 *  • Threefold repetition detection in search path
 *  • Opening book with risk assessment
 *
 * Note: Stockfish's NNUE and 64-bit bitboard representation cannot be
 * ported — they are hardcoded for 8×8 standard chess.  All search
 * algorithms above are faithfully re-implemented for Commander Chess.
 *
 * Compile (Linux):
 *   g++ -O2 -o commanderchess commander_chess.cpp \
 *       $(sdl2-config --cflags --libs) -lSDL2_image -lSDL2_ttf -lm -lpthread
 *
 * Compile (macOS with Homebrew):
 *   g++ -O2 -o commanderchess commander_chess.cpp \
 *       $(sdl2-config --cflags --libs) -lSDL2_image -lSDL2_ttf -lm
 *
 * Compile (Windows with MinGW):
 *   g++ -O2 -o commanderchess commander_chess.cpp \
 *       -ISDL2/include -LSDL2/lib -lSDL2 -lSDL2_image -lSDL2_ttf -lm
 *
 * Dependencies: SDL2, SDL2_image, SDL2_ttf
 */

#define SDL_MAIN_HANDLED
#if __has_include(<SDL2/SDL.h>)
#include <SDL2/SDL.h>
#include <SDL2/SDL_image.h>
#include <SDL2/SDL_ttf.h>
#elif __has_include(<SDL.h>)
#include <SDL.h>
#include <SDL_image.h>
#include <SDL_ttf.h>
#else
#error "SDL2 headers not found. Install SDL2/SDL2_image/SDL2_ttf and ensure include paths are configured."
#endif

#include <algorithm>
#include <array>
#include <atomic>
#include <cassert>
#include <cctype>
#include <chrono>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <functional>
#include <future>
#include <iomanip>
#include <iostream>
#include <map>
#include <memory>
#include <mutex>
#include <limits>
#include <new>
#include <random>
#include <set>
#include <sstream>
#include <stdexcept>
#include <string>
#include <thread>
#include <unordered_map>
#include <vector>

#if defined(__EMSCRIPTEN__)
#define COMMANDER_ENABLE_THREADS 0
#else
#define COMMANDER_ENABLE_THREADS 1
#endif

// WASM-SAFE: Browser builds run single-threaded by default.
struct EngineNoopMutex {
    void lock() noexcept {}
    void unlock() noexcept {}
};

#if COMMANDER_ENABLE_THREADS
using EngineMutex = std::mutex;
#else
using EngineMutex = EngineNoopMutex;
#endif

#if defined(__AVX2__)
#include <immintrin.h>
#endif

#if defined(COMMANDER_ENABLE_WEBGPU) && COMMANDER_ENABLE_WEBGPU
#if __has_include(<webgpu/webgpu.h>)
#include <webgpu/webgpu.h>
#define COMMANDER_HAS_WEBGPU_HEADER 1
#else
#define COMMANDER_HAS_WEBGPU_HEADER 0
#endif
#else
#define COMMANDER_HAS_WEBGPU_HEADER 0
#endif

// ═══════════════════════════════════════════════════════════════════════════
// BASE64 DECODER
// ═══════════════════════════════════════════════════════════════════════════

static std::vector<uint8_t> base64_decode(const std::string& encoded) {
    static const std::string b64chars =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    std::vector<uint8_t> out;
    std::vector<int> T(256, -1);
    for (int i = 0; i < 64; i++) T[(uint8_t)b64chars[i]] = i;

    int val = 0, valb = -8;
    for (unsigned char c : encoded) {
        if (T[c] == -1) continue;
        val = (val << 6) + T[c];
        valb += 6;
        if (valb >= 0) {
            out.push_back((val >> valb) & 0xFF);
            valb -= 8;
        }
    }
    return out;
}

// ═══════════════════════════════════════════════════════════════════════════
// EMBEDDED PIECE IMAGE DATA (base64 PNG)
// ═══════════════════════════════════════════════════════════════════════════
// ── Embedded piece images (inlined from b64data.hpp) ──

#include <map>
#include <string>

static std::map<std::string,std::string> PIECE_B64 = {
    {"C_red", "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"},
    {"C_blue", "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"},
    {"In_red", "iVBORw0KGgoAAAANSUhEUgAAADQAAAA0CAYAAADFeBvrAAAaYUlEQVR4nKWaeZAlV3Xmf/fezLfVq3q179VbdVdXt9Tdam1IaEMbO0aAxtgeg+0BG8QyYxgTg/HY44U1WMKAA4GBYR0YFiGwhCwJSRYSspZW75K6W1VdvdW+vn3JzHvP/JGvWosnYsIxGVFR8epVZt5z7rnnfN93jpJIBA2iwAECaEDxwmdHhEMw+BgB7QAbgYoQYxDtoyIh1BFKKXzlEV/SfNL6VQM8BB+7/p4QJLJoTxH5ipAID4UCDArlBLRHBBgB5ZqP0hEoCyRe8g4lTgQVv/r8H9fXQmyocg4RAaNREt8ciouX60K0VhidiG9YylNeWqA+9TyF6TMszs8RWQtEaALSmSw9fVtoHd1KemCQZG8ftOcAsC4C0RhU/GIDFsEpUCh00wnx2iRe20scBkpE5CW+lBeMOf+/65+1IM4hShM0v04qoFogv+9xph54jPkTRymvnSOpLL39/ZBO4Kc8nLVoMoi12NIKy4urSKKFRO8AXXsuZvyG15Ldvgt8H2cFJSBGgQaRpiEqjhlBI01TNC+9VCQi6yF2fuEvM8g1w9GIIOIQJRjlQbHA7AP3sf9nP6ZxapL2rRvZtWcT+fwpejYM0nnJZVCv0agWCWoNdJDGuYjWoRTPP/IEue4NuMhw6qljLC7XyW0YZ/fbbqXrlZdDIoFzoMV7UURZUA6rDIJuhuXLDArFioE4lOI9fIkx520UUNahPAVELP76IfZ99XYq05PsvHIv2264Cn+gh0JlgZmTR3BGsXPnhUw+e5REyiNfzKOdYWTTZlxSc3pigrEtWyiullCrId2qlVPHpjlx7BTt27dz5Z+8h+T23UjkgYpdrhBQFtHNE+b+7RapSELRKJTo8wY5BKcUYFEojFWIFVRCI6Uljnz5Hzhx98/YesUOdt98OcVkxHypgC9CbmSEuelpFufOsn10lJWFFQYHhjh24iidg+0MDg6z+PwMy5UCbV1ZWtJJfKeZP3mOgWwPCcky9dhBZqcL7PqjdzP+e+/ESQoErNFoHMY6EB073bzUIuUkio+5awaehhCwWDwkPqAhKM8QTJ3goU/+FcxMsPe6S+i74RVMz59hpbjA5PRJrrvqCor5Gn6uh3pQx7cWT6UxKs2RgwfoH8kxMNJPkK+BryFlSGiF1GrMLi8zuvNC6jPLtJFi6onjnHjmDP0XXs6Vf/bnuFwXFlBKAw4jUXyKlPeiww7KiRVF85AohSgIERQOXwQJQ1QiTfTcCX78oT9mtMcwuHuYZROy99obKVRriKsyuzJNTQIGB7dgqoJ2Hg0npLwsGZ0h7fvgqqBqFMKABiE+Ecpa9j+9j4tvfBWBRJw9cZJUJGzftRd/TXj49h8jPRu44bOfh45urFOgNSIhIHjqZWk7EisaHcejAqckTgA4VCMAL0Ht8GHu/sh/ZtOOPi679RoWy/M8/dwJ+ns309U/RPdwLzOTJ5ivOPbuuYzw9CyJs4ucPX2O6YVlakFAwjmoNojqBbr6c2zespmO0Y1E3VmWi8uUowrZXAvaCXOnTjG2ZzdZL4U3W+LAPz/Bmmrlxk9/AekeRmMIVYTTkIir1YuTgsRJ4bxBcSpQYYjShmBmlh+9/4/Y2m+48n2/w9GpI2wbG2Pi+ClQSTZsHmdtaZnOwSHS5yosPnGEyfvu5dzpafouuoTu66+jb8corZk2CjNFVg4fZuGeHyELy7Rns7Tv2Ej2hkvov3SM+doy+bU5ejYMs7RWIAjrbO3tI50XHv3JI/jdO7j6U3+PzaRRGrRzoPVLE7NIJBaDliY6UBKHXygQ5HnwQx9AlWa46UO/z7GJg2QH+si0dWAbilzrEGGQgXyZ1YfuYu2Ou0nPlFhJtdB92x+y7X1/CkMbAUd5YoLs0AgkMgRPPM2pL3yS+r/8kpyEFCPB37WZkd99HW58gLm5GbL9baR7WqjnQ5aePsm2wTGevPNX9L3i" "Nez8048hRqNU0yARGgoUGu2aFVidhwoKnEN7iuPf+g4rxw9w07vfwtnCHCpSzD1zgqhQIfSTBMkMzCwx8RcfJ//3P2BoNgTVxsZ3v4dt//0vYWgEJ+AWyvz6018mPDGJ8yBx1aVs/8oXaX3r2ynXk2w3OXr3n+L0X3+FlR8/zOauzZRXShRmlzk3McmGyy+mlogYu2SUY7/6OQsP3ofSCisvQKt1FKFts0DxwpahPU3p6EEO3PEjXnXr61ikjEklGNo+Trqnl8nnp2jr3kB0/DSHPvJf6XzmCBeoVmyQwHvTLQx+9L8RpdshH6KnFijf8wtSjzxI4b770FMncavzhH1DbPnUl0i+/neYLYd0aZ/xukf5Ow8y+bWfMTa8l9njC+RyOVraFFEyIHvZOFe/+koe+caXYW4OpQwxbtN4aDxpRqBD4i1aR6NBwONf+womG5A3JbIWqDZYoU7v1q1ceM3NhPtP8syH/obtc3k2YqgEJZY3drHhw+9COnJ4oqkvzHD3n93GxCc+yqbiKZZu/wL3v/MPWHj2GJ5TSHs7W/7qY5Qv3E4+dOgIdiZaSNy/j9Of+19cufc6xPcplZYJTZ1awpIYaSUbrvHcT36E1hon8eFXTTijjcQG2SZOUlqx9MijFJ/Zz5W/fS1Vr87hfQeoVxuksymMTpM6U2Tio3/HtrkFeqIYeC8lofWdb8HbuxuJHNZBcks/e373TWQEevINUuUKO9/0anovuzBGytZhLtrG0Affw0xLO3UvRRAGjChN/d5HOP2Dexjp2sjCzDw67XPs0NO0jA1x8ztu4fgDd1M/ewaFRpSczwoaC1bAiuBUnFqf+d4P2XLxKMMXjdK/cZCWoT66t46i6oYul2XiLz7L6OwyPUohkVBRSYKRQfrfcgt4aTQGwSF+mpFrb6KS6CHvtXHGT9J77XWYdBcOQflAFNL5H96Kd9P1FGshxlOoMGIoYSj+7AHcY1O0tvQggWXj+DirxTxRh2F4U46Td/wArSCU6DwEOv9LCWhtKB49TPHYYcZfdzlnjz+Hco7hXWOgDLnMIBPf+BHZY8/TLaBCh5gEgRW6r3glia1jzfB1KBuiHZw9dJrFkVF6b/88pRuu5pnnpkA0IjFAtKIh18Xw62+MoZaNMApS1jFaExb+59300km5HJJKplkpVljTlsGxPub2PYwrLKC1IhKHoPBQglKKdcY1+cj9DG7rQaehMLHEcrrEUGcvSa3QM8vU7nqUIWOwWKxV+DbCR5E/dhKZXUWPdoIXxpAJxeCuPQx87Uv4mzt5/RtvJliL8aJnfDBgEAiLFA7vx1MWExEvTBwJaymcnqf64GFaXrudtXyeC264mWh6ESnUOW6Oce7R37DxjbcQ4DBK44FDi0Y8A/kCpx97lL1XjlAqrdG/aQtrQci+Jw9x07VvZPand9KzsEYmqSk7S9ozuMiSMZr8oWdY/dLXab/+OgK/QeQDksRECYwJqT9TQKkkShLUjx1AdFzhtY6QiedZ+8U9DPk+WEFchFhQ4sgBi/+yj6HXXspCfZGT+57Azq3h1R1t/Z2sPL6PjW94PUZ74MBDO4xTOKNpTE6QWlsl1bsDi+B1ddIRaa4a2om/2iDx6FO0+0miEBJKISoEJWjrGFSO1X/8B5a+/20qOqTmOZz1SNsERtUJdIgvaQg01o9AJwiwtEhArtZgU6TwxEckZsCBBXyNJ47azCyF52dRHRGnDjzNBZdeRX6pQN/QBqYfncCtLmO6BhEBL1Jx7THAzNQkPnWsFlKpFkqlNTIqg5/uY+XQUdyZBRLGgGfwrSCRQhnACJ619AZ1bGRpxxERs86EgCLCKlCmDtYgAuIUTsXqgr9OJEWhxKG0oJIaZy0JpUmXa6hDz9H/25eT8IVcLkvSeVRmpokSdSpz87R2jcTZwBKTWoDKmdMkWxOslYoc2n+QtZVFlNJkG5b5+x+kXSk87YhcHYfF4IHziZzCAmJA40iIIuM0aQRf25iqi8KP" "IgwhSSKSKiCjQoyyOO0QbUGHWGWJlKAiQYvCWEevVTQOHCeTzEDSJ3/uNNVygb4r9+CysHZqqgkLBM+gMNpAJCyfO8vwji10bdtMYmEBkzSEeLizS3QeO01WuTg7aXCRNKu0QTsQQhzuJcqMiCCeRrQlEtASs06nHOs6SLxbgjFx+Vjn1MbGHDVEyJoES3N5UoGgPJ+GE6bOTRAlkkRRg6XZGTYQA2tt0CitoFxjLb9EsiNNfnWRlpYM/cMbSCUylI9O0rpQwBd1Pox8pRDlEO3wNCjVVJbcusoiMau0oJxG0ARKE/LC18rFP8bFddaz4GPwrEYpjfggvorPcySwWqEt0UJUq9Le1U6ut4dsTwfLC3NArBB567RbGg3K1RJeeyd+axKLz8LcPIY2kosFXOThUimcraNFUEhTlbExmFVqnfXHkpcAxFRZGx+9zrHOw0kBpVEiIIKTGH6Js7F3mhVfaYXVFomCWGjxW/CyGdIJn0zKp727k3KdJoATPJG4DgmCMopqVMfVNBI2WCkWyLb5kGthti1FMenHHq3WUZEjUgEekIriVSqtME7IYDBKEXmamoklL2ctOgzxAK0MKIUPeA5SWpPQGuWaYFI1tQ0boZWgnIUwQEURIkJbdw+dnR1UFlYQGyAuRt2Cw1PrGQaLQ4iCkEatxoYt4+TqndSDNMPvfj0j174O1agRRXVWz81TL1axNiQolAhXikgYoBoV9NoalWodEZiulhm+/lpaRkcJSiUa+QJRoUhQqaFqNaJCCVWtYgtFpFRC1xpIFGCAXGTpTiZRNiCB4Ckw2rC2kqe4WKc/AlMHiyaK9QM8UXixxAsYA07hR5qWrm7mps/R0tkG1hAuLBBWLaqzG93TTvfl1+ApH9o743PidCx6RGWoV6BSBhG6rZDo7CEzNMK626hUoNGAeogrl4kaDcJyiaBSJKo1cCurmEoZ/a9PM33nHQz5PlHQIPQU4hye1kRWmD03g9/wCLUhWkemTvBUE6maRIL2tnZMJcJon3JxgXRHlqBW4exd32fuu/eQbeuknPQwmQwt2TYynR34LS2Y7j7CjnYaHW2ku9pJt2RIdXSR3bAZr3MYV42wvsYqhZdqRSdbUTnQg7EynQBaeOkVXvAoRx5/Ers0T5enqKY1XkcbOlVhy84LCOoB9XzA/PQExiSaiNTgKWJ5V6WTdHV2s3T8SbxuoRw2GDYanTS4FsMAIUPlIsGaRWlDI6xhDUSARDGV0sZDfJ+K1sxkUlR37eHq27+K3r6tqcxajCLeVSSO/WYdkBcxZoXgX/EKLv3WV5j8zKep/vpf0W2tlLtacS4gXCuCUgwMDXG0dIiOsX6aaQ5PoXAWVMKndaAPmU4yftmlPHH4ECsLBUb6+rB9aVa6s5j5GjmAyIL2YkFFg1auKVJ6EITgw1qpzvyBp5j8L7eRuvFVDPzWG/BHt4NJNc+rwtOmme8s2qrzhqI1kkyQve5qLtr5Tc5+/buUZyaxqQRtfpbp2SXqxSpjsw0yMyWGbtgcP8c4vBc3PFL9faw0IlYW5zG+RybXTTplqPe00ejKEc1V8RRYTzXri0GJQ1y8y2iFaE1kI9JGsTmKKDz8OMcefZInnzrAW7/zPWwyZixagV3LUz51hty2DdCWRZxgIwFjEMCLBNUzwIaPfRiZOca5Z+4lO9BCtQtGtvdRf/wYlbMr9I/taBoEOkLFTweGxi+gGilM2TLU2UG2LcHhw0dYXsnTPjRACXBKxTsjDs9F6KjZatExZlPi0BicU+hIYQOfzI7LuPYPP4jyk4iWuGugheW7fsb9b34bC//4Ldz8NCos43lxGMY6to+IplpfZUUtonxBN4Su1k7aMmmilEdyeJBET0+cB5RGs44UREhtHaeYbKe6WKdeKjA3e5KWbCvpXI6Wi3ey0uYhvodEDqPXOxEO16RTohXYCO0c1vOYSnjY37uVvd+7nZ43XI/VgrEW7RQsnyH/nW9yydICs5/6LPvf9k5O" "fPSvaZyawqDwIlBWgROwJRbOPcfpM5NUlkuYurBybJITTx4gPTaGas3hnIBTaE9AlBCJg7YONl96NYv7nidpDB25Fto7OohybTQ2d8EV21m0IV4iQeAEp+NODUphjSYQFadvA/mODF0f/3NGvvo5vB1jNKyNz5kF5SmWf3EXwb4nGFYB2yslNu07wtoXv8rM939IDHbi4qpcjVRUor40S0dfLwtraxw9chBdCIjmqgxf9UpQprmroJUoRBxWKQTFphteQyEf0RYkiFZLzCzMUyEi7G6h982vYqXVRyKLJwpM3HjSTaTpjI8YTWgtlbYWut74aqKWDJEDL7QYBK0c5V/+M4tf/jqDocKzlmSjRo+rsish5O+8k2jmLHgQGQtehVL+HL193YxfcBHbL96DS0BtegljWxm68ipEbCzix5EvaK3QShGI0Lr3IrytO1g8NE1n+xAdPT0USwWCqIEaaCd7zR5mbIRJJHBW4kQgCiMKI3HqNJ6BmSXOfO37eDbESIRJeLC8yJnPfJpn338bncdP0m5jiKw8TcMXkjqi5fkpFv7pHpSCwC5TXDzG0vxJcj29zJ6aZnl1kZ0bN/PcoUmGr7kJ2rqaOkYz46LiTOk10RCeYfzWt3H2uQWkALVChfzqEklfU6mWaL/xFZR3jTArFmU8rIu5glEK31mIBGUNw3VD6ds/pnjfvWhtKT/5OIfe9wHyn/kc47MLdIQB4gAMYjSRgIkcvaFj5o67CE8exY+WmDt1kN6WDBNPHqK0vExv3wDJczUaBc2mW9+GrGum57tB6+I8glExLuq7+joyWy/kyTsfYnz7bnbv2cnizBmGNozQaEuw8R2/xczWTk6nLdWkiTlAFAEuFlycJSuW/sVFql//NsVPfY6J//guOu++jwuikJwLMUoRJjROWVRoSYoj0h6B0qwunqY2d5z81GGyCQgLFToz7fguQj87xaFfPMqFr72FxMhGbBNcK2Iusq4nxToZxN06lWT3e99FpWipPH+GUmGZDbvHWK1XmFpbZDoDO//yNurX7mTas3F33DOAou5FuKTFuTqtRkg+9Bsqn/gko7NTDGuLBHVCrYg8RRiEaG1RSrA6yRkHc1t7ufp/vBdyIWcP/IYOL+ZQXQN9DG8ZYu6JoxS9NJt+/+3N6FBoiS2wOJRYEbTEeUU02saVW3lw9Iuf4syv7uSVf3ADx0vTJEkyOraDcrFKYW6OsY1jLP3kV6z85EFyFaFXpVEmRNsQLxCsMUTOoUyMll0UY+BQ4hTvi0KUZlU5zqUNLTdewegH30kxbSlUl2kU1igsL7Fpx4WUT83SJT4PfOteXv13n6ftlTcTOoevY04lqjlmIKGIeOBw6KZGbBVgQ1RU5t73f5BOU6DvihHIGrqHellbWYVAWF4uMLblAvTpZU7+8G78g5O0FBvkPEO6Od+gPRWTtDDmPuIZHELVCQVxlBMejfGNDL7jjbTduJflyjI2bNDSmqGtu4v9Dz9MYq3OxYO7uePrP2HHm9/Ozvd+gNAa8Dz8l4FaJZGIM4JgMaLBapyKa5N2AWpulrtv+2O2bGpj62v2sFhfpFKrEpk0ue4hGsUSvjhGBgYoPvEsK79+ivyxkyQXquQiSDmIwhd6u6HyKCfaKOQSZPdup/O6S+h71SXkTYNGo0AmmyIoFohUHUknWTkxyw5/Iw9895ckd13EdX/7t4iKxRnRGm1ePnjhRGKh3mLEQKhxCKGGhHIoBe7EcX7+kQ8wur2L8Vfvwg60sv/pg3iSYmzjVsrlFarlFXy/jYHuIVQ5JDh+itLMMqXFNahbMIpIQUtfHz07tpAYHURtHmR5+jTnzpyid/MwI+NbqS4tc/rgEQYu2sja5AyjtX6e+OmjhENbuP4zn8S1tqLCuPo5DfrlXXBxIlHTIE80RAYEokQMZ0wYYXyPYOIE93zoNrZvy7Hl5l0sJyOMn2bx+bOMjo9x4uSztHZ0xsTPCtnWDnw/TVolMALWWUinKBHQ" "sGWoVklpjyMHD1EOG9zwljeTX1nBw1CvhehykQ3Swf1f+ycyY3u5+hOfhGwbLnQ4HTe3lRI89XKDrIjVNHU2QVsNomOu06xRxlk8ZZDTUzz88Y+xMLWPWz78n/C6WpiemkSnfRarRbZtGKQRhJDwMdqjWqoSNEIW5ubwO9rpGeghiCzdLTmwgrMWiRo8OzXJJVdfTW25BIksvT0jHP/mHRz49UF23vJWLnr/+4kyOYw1KNGIB40mS02+bNpHSRTLphGCwjZlsbhKueZN2mlcFKJ9DdUKx775DZ77+f9m/IIRhi/eQjFtUWmPoFYhiBrkKxWUNgwMj5DLdXFk31NccMUrqFRKsfdDTalWYmTrZkQJC2en6Wjvpb9rA/VTi+z/xQPk5wMu+ZP3MvjmmxClsWIwOnm+deqaA1f/ZjQmTtsx43TNAqtwMeg8P6blcMphrcFpn6SC0uOP8/Q3b6dy7jk2Xb6D0b07CLuz0JqmUi0zd2aK8b17iSp1jjz2GBs3bCEsVkh2tVL3I3zRtKdbKdctndkeSjMFJh7cx9mJM2y95jouese78bZuRYJ6bIBWiOfHky3rw0fnx7NeZJATkfODS2p9Pk7QTQ0Np0FCnIoIVAofjY4E5StoFJh/7CH2//QOgpk5OjpbGL98D55xJNqStPS2USwss1Qu05rO4omhZ3gQCSpMP32EVKaTwkKZU5NzrCyWGbz4cva8/VZye3cj+ISRQ2mNpxXKNZeoeJGj/y8GNSQUD412+vz03/p26mbrVWyT92iFp2PpVsQhJh7SI7BUnj3G8V/dw8pzR8nPnCGpI/oGOtBtSVQmBdpDQoWr1snPL5BfqZJq76ZtZBM9u/ey49ob8bZsa2ZDh22Kl1qZ5jkmJqKKWPhvojhQ/w6DaLb7X5hqiFsorE9vxVRZtH7BUaU8tfkF6nMz1KZPk19bxiKIKJQYMD69IxtJ9w+R6uwiMdIPiTQQOy4mQSr2pjhU85RIU39cjzaFxM0yXp7l5AW95d93vViNiN/onEMZ8zKf/T+e0pzB00qvx9P/1/V/APKaUK3FMOQtAAAAAElFTkSuQmCC"},
    {"In_blue", "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"},
    {"T_red", "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"},
    {"T_blue", "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"},
    {"M_red", "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"},
    {"M_blue", "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"},
    {"E_red", "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"},
    {"E_blue", "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"},
    {"A_red", "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"},
    {"A_blue", "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"},
    {"Aa_red", "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"},
    {"Aa_blue", "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"},
    {"Ms_red", "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"},
    {"Ms_blue", "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"},
    {"Af_red", "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"},
    {"Af_blue", "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"},
    {"N_red", "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"},
    {"N_blue", "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"},
    {"H_red", "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"},
    {"H_blue", "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"},
};
// ═══════════════════════════════════════════════════════════════════════════
// SOUND ENGINE — synthesized WAV playback via SDL2 audio
// ═══════════════════════════════════════════════════════════════════════════

static const int SAMPLE_RATE = 22050;

struct SoundBuffer {
    std::vector<int16_t> samples;
};

struct SoundNote { float freq, dur, decay; };

static SoundBuffer synth_sound(const std::vector<SoundNote>& notes, float volume = 0.38f) {
    SoundBuffer buf;
    for (auto& n : notes) {
        int cnt = (int)(SAMPLE_RATE * n.dur);
        for (int i = 0; i < cnt; i++) {
            float t = (float)i / SAMPLE_RATE;
            float env = expf(-t * n.decay);
            float v = 0.0f;
            if (n.freq > 0) {
                v = sinf(2*M_PI*n.freq*t)      * 0.7f
                  + sinf(2*M_PI*n.freq*2*t)    * 0.2f
                  + sinf(2*M_PI*n.freq*0.5f*t) * 0.1f;
            }
            int16_t s = (int16_t)std::max(-32768, std::min(32767,
                (int)(volume * env * 32767.0f * v)));
            buf.samples.push_back(s);
        }
    }
    return buf;
}

// Global sound buffers
static std::map<std::string, SoundBuffer> g_sounds;
static SDL_AudioDeviceID g_audio_dev = 0;
static SDL_AudioSpec     g_audio_spec;
static bool              g_audio_ok = false;

// Simple audio callback: mixes a single one-shot sound
struct AudioPlayback {
    const SoundBuffer* buf;
    size_t pos;
};
static std::vector<AudioPlayback> g_playbacks;
static EngineMutex g_audio_mutex;

static void audio_callback(void* /*userdata*/, uint8_t* stream, int len) {
    int16_t* out = (int16_t*)stream;
    int n = len / 2;
    memset(stream, 0, len);

    std::lock_guard<EngineMutex> lk(g_audio_mutex);
    for (auto& pb : g_playbacks) {
        for (int i = 0; i < n && pb.pos < pb.buf->samples.size(); i++) {
            int32_t v = (int32_t)out[i] + pb.buf->samples[pb.pos++];
            out[i] = (int16_t)std::max(-32768, std::min(32767, v));
        }
    }
    // Remove finished
    g_playbacks.erase(std::remove_if(g_playbacks.begin(), g_playbacks.end(),
        [](const AudioPlayback& pb){ return pb.pos >= pb.buf->samples.size(); }),
        g_playbacks.end());
}

static void init_audio() {
    SDL_AudioSpec want{};
    want.freq     = SAMPLE_RATE;
    want.format   = AUDIO_S16SYS;
    want.channels = 1;
    want.samples  = 512;
    want.callback = audio_callback;
    g_audio_dev = SDL_OpenAudioDevice(nullptr, 0, &want, &g_audio_spec, 0);
    if (g_audio_dev) {
        SDL_PauseAudioDevice(g_audio_dev, 0);
        g_audio_ok = true;
    }

    // Build all sounds
    g_sounds["move"]    = synth_sound({{600,0.05f,25},{400,0.07f,30}},        0.30f);
    g_sounds["capture"] = synth_sound({{220,0.06f,20},{160,0.10f,15},{100,0.08f,18}}, 0.50f);
    g_sounds["hero"]    = synth_sound({{523,0.10f,8},{784,0.18f,6}},          0.45f);
    g_sounds["win"]     = synth_sound({{523,0.12f,4},{659,0.12f,4},{784,0.12f,4},{1047,0.28f,3}}, 0.50f);
    g_sounds["invalid"] = synth_sound({{180,0.05f,30},{120,0.08f,25}},        0.30f);
    g_sounds["cpu"]     = synth_sound({{800,0.04f,40}},                       0.18f);
    g_sounds["boom"]    = synth_sound({{120,0.04f,8},{80,0.08f,5},{50,0.12f,4}},0.55f);
}

static void play_sound(const std::string& name) {
    if (!g_audio_ok) return;
    auto it = g_sounds.find(name);
    if (it == g_sounds.end()) return;
    std::lock_guard<EngineMutex> lk(g_audio_mutex);
    g_playbacks.push_back({&it->second, 0});
}

// ═══════════════════════════════════════════════════════════════════════════
// BOARD CONSTANTS & COLORS
// ═══════════════════════════════════════════════════════════════════════════

static const int COLS     = 11;
static const int ROWS     = 12;
static const int CELL     = 60;
static const int PAD      = 44;
static const int PIECE_R  = 25;
static const int BW       = COLS * CELL + PAD * 2;  // 748
static const int BH       = ROWS * CELL + PAD * 2;  // 808
static const int TITLE_H  = 42;   // gold title banner  "★ COMMANDER CHESS ★"
static const int STATUS_H = 44;   // turn status bar below title
static const int PANEL_W  = 300;  // side panel
static const int WIN_W    = BW + PANEL_W;
static const int WIN_H    = TITLE_H + STATUS_H + BH;

struct Color { uint8_t r,g,b,a; };
static Color C_LAND      = {0xf0,0xe8,0xc0,0xff};
static Color C_SEA       = {0xf0,0xe8,0xc0,0xff};
static Color C_RIVER     = {0x88,0xd0,0xf0,0xff};
static Color C_SEA2      = {0xf0,0xe8,0xc0,0xff};
static Color C_GRID      = {0x8a,0x7a,0x50,0xff};
static Color C_SEL       = {0xff,0xd7,0x00,0xff};
static Color C_MOVE      = {0x44,0xcc,0x66,0xaa};
static Color C_CAPTURE   = {0xff,0x44,0x44,0xff};
static Color C_HERO_RING = {0xff,0xee,0x00,0xff};
static Color C_BG        = {0x0d,0x11,0x17,0xff};  // dark navy background
static Color C_PANEL     = {0x11,0x18,0x22,0xff};  // dark panel background
// UI chrome colors (not used on board/pieces)
static Color C_GREEN     = {0x58,0xc8,0x8c,0xff};  // Duolingo green accent
static Color C_GREEN2    = {0x43,0xb0,0x7a,0xff};  // darker green
static Color C_RED_DOT   = {0xdc,0x35,0x45,0xff};  // red player dot
static Color C_BLUE_DOT  = {0x3b,0x82,0xf6,0xff};  // blue player dot
static Color C_TEXT_DIM  = {0x90,0xa4,0xae,0xff};  // muted text
static Color C_TEXT_BRT  = {0xe8,0xed,0xf2,0xff};  // bright text
static Color C_AMBER     = {0xfb,0xbf,0x24,0xff};  // amber/gold accent

// ═══════════════════════════════════════════════════════════════════════════
// GAME DATA STRUCTURES
// ═══════════════════════════════════════════════════════════════════════════

struct PieceDef {
    std::string name;
    int range;
    bool diag;
    bool flies;
    std::string domain; // land/sea/air/commander
};

static std::map<std::string, PieceDef> PIECE_DEF = {
    {"C",  {"Commander",         10, false, false, "commander"}},
    {"H",  {"Headquarters",       0, false, false, "commander"}},
    {"In", {"Infantry",           1, false, false, "land"}},
    {"M",  {"Militia",            1, true,  false, "land"}},
    {"T",  {"Tank",               2, false, false, "land"}},
    {"E",  {"Engineer",           1, false, false, "land"}},
    {"A",  {"Artillery",          3, false, false, "land"}},
    {"Aa", {"Anti-Aircraft",      1, false, false, "land"}},
    {"Ms", {"Missile",            2, false, false, "land"}},
    {"Af", {"Air Force",          4, true,  true,  "air"}},
    {"N",  {"Navy",               4, true,  true,  "sea"}},
};

static std::map<std::string, int> PIECE_VALUE = {
    // Official rulebook point scale ×10 for integer evaluation.
    {"C",1000},{"H",0},{"In",100},{"M",100},
    {"T",200},{"E",100},{"A",300},{"Aa",100},
    {"Ms",200},{"Af",400},{"N",800},
};

// Forward-declared fast helpers (kind_index defined fully later; this early
// version is identical and needed because compute_game_phase / quick_eval
// call piece_value_fast before the main kind_index definition).
static inline int kind_index_early(const std::string& k) {
    if (k.empty()) return 0;
    switch (k[0]) {
        case 'C': return 0;
        case 'H': return 1;
        case 'I': return 2;
        case 'M': return (k.size()>1 && k[1]=='s') ? 8 : 3;
        case 'T': return 4;
        case 'E': return 5;
        case 'A': if (k.size()>1) { if (k[1]=='a') return 7; if (k[1]=='f') return 9; }
                  return 6;
        case 'N': return 10;
        default: return 0;
    }
}
static const int PIECE_VALUE_FAST[11] = {1000, 0, 100, 100, 200, 100, 300, 100, 200, 400, 800};
static inline int piece_value_fast(const std::string& kind) {
    int ki = kind_index_early(kind);
    return (ki >= 0 && ki < 11) ? PIECE_VALUE_FAST[ki] : 0;
}

struct Piece {
    int  id;
    std::string player; // "red" or "blue"
    std::string kind;
    int  col, row;
    bool hero;
    int  carrier_id; // -1 when not carried; otherwise piece id of carrier
};

struct PieceList {
    static constexpr std::size_t kMaxPieces = 132;
    using value_type = Piece;
    using size_type = std::size_t;
    using iterator = Piece*;
    using const_iterator = const Piece*;

    std::array<Piece, kMaxPieces> items{};
    size_type len = 0;

    iterator begin() noexcept { return items.data(); }
    iterator end() noexcept { return items.data() + len; }
    const_iterator begin() const noexcept { return items.data(); }
    const_iterator end() const noexcept { return items.data() + len; }
    const_iterator cbegin() const noexcept { return items.data(); }
    const_iterator cend() const noexcept { return items.data() + len; }

    size_type size() const noexcept { return len; }
    bool empty() const noexcept { return len == 0; }
    void clear() noexcept { len = 0; }

    void reserve(size_type n) {
        if (n > kMaxPieces) throw std::length_error("PieceList reserve overflow");
    }

    value_type& operator[](size_type i) { return items[i]; }
    const value_type& operator[](size_type i) const { return items[i]; }
    value_type& front() { return items[0]; }
    const value_type& front() const { return items[0]; }
    value_type& back() { return items[len - 1]; }
    const value_type& back() const { return items[len - 1]; }

    value_type* data() noexcept { return items.data(); }
    const value_type* data() const noexcept { return items.data(); }

    void push_back(const value_type& v) {
        if (len >= kMaxPieces) throw std::length_error("PieceList push_back overflow");
        items[len++] = v;
    }

    void push_back(value_type&& v) {
        if (len >= kMaxPieces) throw std::length_error("PieceList push_back overflow");
        items[len++] = std::move(v);
    }

    template <typename... Args>
    value_type& emplace_back(Args&&... args) {
        if (len >= kMaxPieces) throw std::length_error("PieceList emplace_back overflow");
        items[len] = value_type{std::forward<Args>(args)...};
        return items[len++];
    }

    void pop_back() noexcept {
        if (len > 0) --len;
    }

    iterator erase(iterator pos) {
        size_type idx = static_cast<size_type>(pos - begin());
        if (idx >= len) return end();
        for (size_type i = idx; i + 1 < len; i++) items[i] = std::move(items[i + 1]);
        --len;
        return begin() + idx;
    }

    iterator erase(iterator first, iterator last) {
        if (first == last) return first;
        size_type idx_first = static_cast<size_type>(first - begin());
        size_type idx_last = static_cast<size_type>(last - begin());
        if (idx_first >= len) return end();
        idx_last = std::min(idx_last, len);
        size_type remove_count = idx_last - idx_first;
        for (size_type i = idx_first; i + remove_count < len; i++) {
            items[i] = std::move(items[i + remove_count]);
        }
        len -= remove_count;
        return begin() + idx_first;
    }

    iterator insert(iterator pos, const value_type& v) {
        size_type idx = static_cast<size_type>(pos - begin());
        if (idx > len) idx = len;
        if (len >= kMaxPieces) throw std::length_error("PieceList insert overflow");
        for (size_type i = len; i > idx; i--) items[i] = std::move(items[i - 1]);
        items[idx] = v;
        ++len;
        return begin() + idx;
    }

    iterator insert(iterator pos, value_type&& v) {
        size_type idx = static_cast<size_type>(pos - begin());
        if (idx > len) idx = len;
        if (len >= kMaxPieces) throw std::length_error("PieceList insert overflow");
        for (size_type i = len; i > idx; i--) items[i] = std::move(items[i - 1]);
        items[idx] = std::move(v);
        ++len;
        return begin() + idx;
    }
};

// ═══════════════════════════════════════════════════════════════════════════
// BOARD HELPERS
// ═══════════════════════════════════════════════════════════════════════════

static std::string opp(const std::string& p) { return p=="red" ? "blue" : "red"; }
static bool on_board(int c, int r) { return c>=0 && c<=10 && r>=0 && r<=11; }
static bool is_sea(int c, int /*r*/) { return c <= 2; }
static bool is_reef(int c) { return c==5 || c==7; }
static bool is_navigable(int c, int r) {
    if (!on_board(c, r)) return false;
    if (is_sea(c, r)) return true;
    // Deep-water river segment excluding reef-base columns.
    return (r == 5 || r == 6) && c >= 2 && c <= 10 && !is_reef(c);
}
static bool is_hq_square(int c, int r) {
    return (r == 0 || r == 11) && (c == 4 || c == 6);
}
static bool crosses_river(int r1, int r2) {
    return (r1<=5 && r2>=6) || (r1>=6 && r2<=5);
}

static Piece* piece_at(PieceList& pieces, int col, int row) {
    for (auto& p : pieces)
        if (p.carrier_id < 0 && p.col==col && p.row==row) return &p;
    return nullptr;
}
static const Piece* piece_at_c(const PieceList& pieces, int col, int row) {
    for (auto& p : pieces)
        if (p.carrier_id < 0 && p.col==col && p.row==row) return &p;
    return nullptr;
}

static Piece* piece_by_id(PieceList& pieces, int id) {
    for (auto& p : pieces) if (p.id == id) return &p;
    return nullptr;
}

static const Piece* piece_by_id_c(const PieceList& pieces, int id) {
    for (auto& p : pieces) if (p.id == id) return &p;
    return nullptr;
}

static bool is_person_payload_kind(const std::string& kind) {
    return kind == "In" || kind == "M" || kind == "E" || kind == "C";
}

static bool is_ground_piece_kind(const std::string& kind) {
    return kind == "C" || kind == "H" ||
           kind == "In" || kind == "M" || kind == "T" || kind == "E" ||
           kind == "A" || kind == "Aa" || kind == "Ms";
}

static bool can_carry_kind(const std::string& carrier_kind, const std::string& carried_kind) {
    if (carried_kind == "H") return false;
    if (carried_kind == "C") {
        return carrier_kind == "T" || carrier_kind == "Af" || carrier_kind == "N";
    }
    if (carrier_kind == "N") {
        return carried_kind == "Af" || carried_kind == "T" || is_person_payload_kind(carried_kind);
    }
    if (carrier_kind == "T") {
        // Tank carries one person payload.
        return is_person_payload_kind(carried_kind);
    }
    if (carrier_kind == "Af") {
        // Air force transports one tank OR one person payload.
        return carried_kind == "In" || carried_kind == "M" || carried_kind == "E" ||
               carried_kind == "T";
    }
    if (carrier_kind == "E") {
        // Engineer can ferry heavy vehicles across river segments.
        return carried_kind == "Aa" || carried_kind == "A" || carried_kind == "Ms";
    }
    return false;
}

static bool carrier_capacity_allows_add(const PieceList& pieces, int carrier_id,
                                        const std::string& carrier_kind,
                                        const std::string& add_kind) {
    int af = 0, tank = 0, person = 0, other = 0;
    auto bump = [&](const std::string& kind) {
        if (kind == "Af") af++;
        else if (kind == "T") tank++;
        else if (is_person_payload_kind(kind)) person++;
        else other++;
    };
    for (const auto& p : pieces) {
        if (p.carrier_id == carrier_id) bump(p.kind);
    }
    bump(add_kind);

    if (carrier_kind == "N") {
        if (other > 0) return false;
        // Allowed Navy cargo combos:
        // 2 Af, or 2 T, or 1 Af+1 T, or 1 Af+1 person.
        if (af == 0 && tank <= 2 && person == 0) return true;
        if (tank == 0 && af <= 2 && person == 0) return true;
        if (af == 1 && tank == 1 && person == 0) return true;
        if (af == 1 && tank == 0 && person == 1) return true;
        if (af == 0 && tank == 0 && person <= 1) return true;
        return false;
    }
    if (carrier_kind == "Af") {
        if (af > 0 || other > 0) return false;
        // One tank OR one person.
        return (tank + person) <= 1;
    }
    if (carrier_kind == "T") {
        if (af > 0 || tank > 0 || other > 0) return false;
        // One person.
        return person <= 1;
    }
    return true;
}

static bool carrier_capacity_valid(const PieceList& pieces, int carrier_id, const std::string& carrier_kind) {
    int af = 0, tank = 0, person = 0, other = 0;
    auto bump = [&](const std::string& kind) {
        if (kind == "Af") af++;
        else if (kind == "T") tank++;
        else if (is_person_payload_kind(kind)) person++;
        else other++;
    };
    for (const auto& p : pieces) {
        if (p.carrier_id == carrier_id) bump(p.kind);
    }

    if (carrier_kind == "N") {
        if (other > 0) return false;
        if (af == 0 && tank <= 2 && person == 0) return true;
        if (tank == 0 && af <= 2 && person == 0) return true;
        if (af == 1 && tank == 1 && person == 0) return true;
        if (af == 1 && tank == 0 && person == 1) return true;
        if (af == 0 && tank == 0 && person <= 1) return true;
        return false;
    }
    if (carrier_kind == "Af") {
        if (af > 0 || other > 0) return false;
        return (tank + person) <= 1;
    }
    if (carrier_kind == "T") {
        if (af > 0 || tank > 0 || other > 0) return false;
        return person <= 1;
    }
    return true;
}

static bool can_stack_together(const PieceList& pieces, const Piece& a, const Piece& b) {
    if (a.player != b.player || a.id == b.id) return false;
    if (!can_carry_kind(a.kind, b.kind)) return false;
    return carrier_capacity_allows_add(pieces, a.id, a.kind, b.kind);
}

static bool piece_has_carried_children(const PieceList& pieces, int carrier_id) {
    for (const auto& p : pieces) if (p.carrier_id == carrier_id) return true;
    return false;
}

static void collect_carried_ids(const PieceList& pieces, int carrier_id, std::set<int>& out_ids) {
    for (const auto& p : pieces) {
        if (p.carrier_id != carrier_id) continue;
        if (!out_ids.insert(p.id).second) continue;
        collect_carried_ids(pieces, p.id, out_ids);
    }
}

static void remove_piece_with_carried(PieceList& pieces, int root_id) {
    std::set<int> ids;
    ids.insert(root_id);
    collect_carried_ids(pieces, root_id, ids);
    pieces.erase(std::remove_if(pieces.begin(), pieces.end(),
                                [&](const Piece& p){ return ids.count(p.id) != 0; }),
                 pieces.end());
}

static void sync_carried_positions(PieceList& pieces, int carrier_id) {
    Piece* carrier = piece_by_id(pieces, carrier_id);
    if (!carrier) return;
    for (auto& p : pieces) {
        if (p.carrier_id != carrier_id) continue;
        p.col = carrier->col;
        p.row = carrier->row;
        sync_carried_positions(pieces, p.id);
    }
}

static bool is_carried_by_engineer(const Piece& p, const PieceList& pieces) {
    int cid = p.carrier_id;
    while (cid >= 0) {
        const Piece* c = piece_by_id_c(pieces, cid);
        if (!c) return false;
        if (c->kind == "E") return true;
        cid = c->carrier_id;
    }
    return false;
}

static bool in_aa_range(const PieceList& pieces, int col, int row, const std::string& player) {
    for (auto& p : pieces) {
        if (p.player == player) continue; // only enemy
        int d = std::max(std::abs(p.col-col), std::abs(p.row-row));
        if (p.kind=="Aa" && d<=1) return true;
        if (p.kind=="Ms" && d<=2) return true;
        if (p.kind=="N"  && d<=1) return true;
    }
    return false;
}

// ═══════════════════════════════════════════════════════════════════════════
// MOVE GENERATION
// ═══════════════════════════════════════════════════════════════════════════

using Move2 = std::pair<int,int>;

static inline int sq_index(int c, int r) { return r * COLS + c; }
static inline int sq_col(int sq) { return sq % COLS; }
static inline int sq_row(int sq) { return sq / COLS; }

struct BB132 {
    uint64_t w[3]{0,0,0};

    inline void clear() { w[0]=w[1]=w[2]=0; }
    inline void set(int sq) {
        w[sq >> 6] |= (1ULL << (sq & 63));
    }
    inline bool test(int sq) const {
        return (w[sq >> 6] & (1ULL << (sq & 63))) != 0;
    }
    inline void or_bits(const BB132& o) {
        w[0] |= o.w[0]; w[1] |= o.w[1]; w[2] |= o.w[2];
    }
};

static int bb_popcount(const BB132& b) {
#if defined(__AVX2__)
    alignas(32) uint64_t lanes[4] = {b.w[0], b.w[1], b.w[2], 0};
    __m256i v = _mm256_load_si256((const __m256i*)lanes);
    const __m256i lut = _mm256_setr_epi8(
        0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,
        0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4);
    const __m256i low_mask = _mm256_set1_epi8(0x0f);
    __m256i lo = _mm256_and_si256(v, low_mask);
    __m256i hi = _mm256_and_si256(_mm256_srli_epi16(v, 4), low_mask);
    __m256i pc = _mm256_add_epi8(_mm256_shuffle_epi8(lut, lo),
                                 _mm256_shuffle_epi8(lut, hi));
    __m256i sum64 = _mm256_sad_epu8(pc, _mm256_setzero_si256());
    alignas(32) uint64_t sums[4];
    _mm256_store_si256((__m256i*)sums, sum64);
    return (int)(sums[0] + sums[1] + sums[2] + sums[3]);
#else
    return (int)(__builtin_popcountll(b.w[0]) +
                 __builtin_popcountll(b.w[1]) +
                 __builtin_popcountll(b.w[2]));
#endif
}

static int bb_pop_lsb(BB132& b) {
    for (int wi = 0; wi < 3; wi++) {
        uint64_t v = b.w[wi];
        if (!v) continue;
        int bit = __builtin_ctzll(v);
        b.w[wi] = v & (v - 1);
        return wi * 64 + bit;
    }
    return -1;
}

static std::vector<Move2> bb_to_moves_sorted(const BB132& bb) {
    std::vector<Move2> out;
    out.reserve(bb_popcount(bb));
    // Preserve old set<pair<int,int>> ordering: (col,row).
    for (int c = 0; c < COLS; c++) {
        for (int r = 0; r < ROWS; r++) {
            int sq = sq_index(c, r);
            if (bb.test(sq)) out.push_back({c, r});
        }
    }
    return out;
}

struct MoveGenContext {
    const PieceList* pieces = nullptr;
    std::array<int, COLS * ROWS> sq_to_piece{};
    BB132 occ_all;
    BB132 occ_by_player[2];
    BB132 aa_cover_by_player[2];
    int commander_sq[2]{-1, -1};
};

static inline int player_idx(const std::string& p) { return p=="red" ? 0 : 1; }

static MoveGenContext build_movegen_context(const PieceList& pieces) {
    MoveGenContext ctx;
    ctx.pieces = &pieces;
    ctx.sq_to_piece.fill(-1);

    for (int i = 0; i < (int)pieces.size(); i++) {
        const Piece& p = pieces[i];
        if (!on_board(p.col, p.row)) continue;
        if (p.carrier_id >= 0) continue; // carried pieces do not occupy extra board squares
        int sq = sq_index(p.col, p.row);
        ctx.sq_to_piece[sq] = i;
        ctx.occ_all.set(sq);
        int pl = player_idx(p.player);
        ctx.occ_by_player[pl].set(sq);
        if (p.kind == "C") ctx.commander_sq[pl] = sq;
    }

    // Precompute anti-air coverage for each side (Aa/N range 1, Ms range 2).
    for (const Piece& p : pieces) {
        if (!on_board(p.col, p.row)) continue;
        int radius = 0;
        if (p.kind == "Aa" || p.kind == "N") radius = 1;
        else if (p.kind == "Ms") radius = 2;
        if (radius == 0) continue;
        int pl = player_idx(p.player);
        for (int dc = -radius; dc <= radius; dc++) {
            for (int dr = -radius; dr <= radius; dr++) {
                if (std::max(std::abs(dc), std::abs(dr)) > radius) continue;
                int c = p.col + dc, r = p.row + dr;
                if (!on_board(c, r)) continue;
                ctx.aa_cover_by_player[pl].set(sq_index(c, r));
            }
        }
    }
    return ctx;
}

static BB132 get_move_mask_bitboard(const Piece& piece, const MoveGenContext& ctx) {
    BB132 res;
    const std::string& k = piece.kind;
    int col = piece.col, row = piece.row;
    bool hero = piece.hero;

    if (!on_board(col, row)) return res;
    if (k == "H" && !hero) return res;

    int rng = 0;
    bool use_diag = false;
    if (k == "H") {
        // Heroic headquarters moves like heroic infantry.
        rng = 2;
        use_diag = true;
    } else {
        auto it = PIECE_DEF.find(k);
        if (it == PIECE_DEF.end()) return res;
        rng = it->second.range + (hero ? 1 : 0);
        use_diag = it->second.diag || hero;
    }

    int me = player_idx(piece.player);
    int enemy = 1 - me;

    static const int ORTHO[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};
    static const int DIAG[4][2]  = {{1,1},{1,-1},{-1,1},{-1,-1}};

    auto add_sq = [&](int c, int r) {
        if (piece.kind != "C" && is_hq_square(c, r)) return;
        if (on_board(c, r)) res.set(sq_index(c, r));
    };
    auto piece_index_at = [&](int c, int r) -> int {
        if (!on_board(c, r)) return -1;
        return ctx.sq_to_piece[sq_index(c, r)];
    };
    auto enemy_piece_at = [&](int c, int r) -> const Piece* {
        int pi = piece_index_at(c, r);
        if (pi < 0) return nullptr;
        const Piece& p = (*ctx.pieces)[pi];
        return player_idx(p.player) == me ? nullptr : &p;
    };
    auto can_stack_at = [&](int c, int r) -> bool {
        int pi = piece_index_at(c, r);
        if (pi < 0) return false;
        const Piece& t = (*ctx.pieces)[pi];
        return can_stack_together(*ctx.pieces, piece, t);
    };

    if (k == "C") {
        for (auto& d : ORTHO) {
            for (int s = 1; s <= rng; s++) {
                int nc = col + d[0] * s, nr = row + d[1] * s;
                if (!on_board(nc, nr)) break;
                int pi = piece_index_at(nc, nr);
                if (pi >= 0) {
                    const Piece& t = (*ctx.pieces)[pi];
                    if (player_idx(t.player) != me && s == 1) add_sq(nc, nr);
                    break;
                }
                add_sq(nc, nr);
            }
        }

        int enemy_cmd_sq = ctx.commander_sq[enemy];
        if (enemy_cmd_sq < 0) return res;

        int oc = sq_col(enemy_cmd_sq);
        int orow = sq_row(enemy_cmd_sq);
        BB132 filtered;
        BB132 tmp = res;
        while (true) {
            int sq = bb_pop_lsb(tmp);
            if (sq < 0) break;
            int nc = sq_col(sq), nr = sq_row(sq);
            bool exposed = false;
            if (nc == oc) {
                int mn = std::min(nr, orow), mx = std::max(nr, orow);
                bool blocked = false;
                for (int rr = mn + 1; rr < mx; rr++) {
                    int pi = piece_index_at(nc, rr);
                    if (pi >= 0 && (*ctx.pieces)[pi].id != piece.id) { blocked = true; break; }
                }
                if (!blocked) exposed = true;
            } else if (nr == orow) {
                int mn = std::min(nc, oc), mx = std::max(nc, oc);
                bool blocked = false;
                for (int cc = mn + 1; cc < mx; cc++) {
                    int pi = piece_index_at(cc, nr);
                    if (pi >= 0 && (*ctx.pieces)[pi].id != piece.id) { blocked = true; break; }
                }
                if (!blocked) exposed = true;
            }
            if (!exposed) filtered.set(sq);
        }
        return filtered;
    }

    if (k == "N") {
        for (auto& d : ORTHO) {
            for (int s = 1; s <= rng; s++) {
                int nc = col + d[0] * s, nr = row + d[1] * s;
                if (!on_board(nc, nr) || !is_navigable(nc, nr)) break;
                int pi = piece_index_at(nc, nr);
                if (pi >= 0) {
                    const Piece& t = (*ctx.pieces)[pi];
                    if (player_idx(t.player) != me) {
                        add_sq(nc, nr);
                        break;
                    }
                    if (can_stack_together(*ctx.pieces, piece, t)) add_sq(nc, nr);
                    // Rule: Navy movement is not blocked by friendly pieces.
                    continue;
                }
                add_sq(nc, nr);
            }
        }
        for (auto& d : DIAG) {
            for (int s = 1; s <= rng; s++) {
                int nc = col + d[0] * s, nr = row + d[1] * s;
                if (!on_board(nc, nr) || !is_navigable(nc, nr)) break;
                int pi = piece_index_at(nc, nr);
                if (pi >= 0) {
                    const Piece& t = (*ctx.pieces)[pi];
                    if (player_idx(t.player) != me) {
                        add_sq(nc, nr);
                        break;
                    }
                    if (can_stack_together(*ctx.pieces, piece, t)) add_sq(nc, nr);
                    continue;
                }
                add_sq(nc, nr);
            }
        }
        // Gunboat fire (ground targets: max 3) and anti-ship missile (enemy Navy: max rng).
        for (auto& d : ORTHO) {
            for (int s = 1; s <= rng; s++) {
                int nc = col + d[0] * s, nr = row + d[1] * s;
                if (!on_board(nc, nr)) break;
                int pi = piece_index_at(nc, nr);
                if (pi >= 0) {
                    const Piece& t = (*ctx.pieces)[pi];
                    if (player_idx(t.player) != me) {
                        // Gunboat: ground targets capped at range 3
                        // Anti-ship missile: enemy Navy up to full range
                        if (t.kind == "N" || (is_ground_piece_kind(t.kind) && s <= 3)) {
                            add_sq(nc, nr);
                        }
                    }
                    break;
                }
            }
        }
        return res;
    }

    if (k == "Af") {
        int dirs[8][2] = {{0,1},{0,-1},{1,0},{-1,0},{1,1},{1,-1},{-1,1},{-1,-1}};
        int ndirs = use_diag ? 8 : 4;
        auto path_hits_enemy_aa = [&](int dx, int dy, int steps) -> bool {
            if (hero) return false;
            // Intermediate AA coverage blocks flight before landing.
            for (int t = 1; t < steps; t++) {
                int pc = col + dx * t, pr = row + dy * t;
                if (!on_board(pc, pr)) return true;
                if (ctx.aa_cover_by_player[enemy].test(sq_index(pc, pr))) return true;
            }
            return false;
        };
        for (int di = 0; di < ndirs; di++) {
            int dx = dirs[di][0], dy = dirs[di][1];
            for (int s = 1; s <= rng; s++) {
                int nc = col + dx * s, nr = row + dy * s;
                if (!on_board(nc, nr)) break;
                if (path_hits_enemy_aa(dx, dy, s)) continue;
                int pi = piece_index_at(nc, nr);
                bool dest_in_enemy_aa = !hero && ctx.aa_cover_by_player[enemy].test(sq_index(nc, nr));
                if (is_sea(nc, nr)) {
                    if (pi >= 0) {
                        const Piece& t = (*ctx.pieces)[pi];
                        // Capture landing is legal even inside AA (kamikaze resolved in apply_move).
                        if (player_idx(t.player) != me && t.kind == "N") add_sq(nc, nr);
                        else if (player_idx(t.player) == me &&
                                 can_stack_together(*ctx.pieces, piece, t) &&
                                 !dest_in_enemy_aa) add_sq(nc, nr);
                        // Air force ray stops after first occupied square.
                        break;
                    }
                    continue;
                }
                if (pi >= 0) {
                    const Piece& t = (*ctx.pieces)[pi];
                    // Capture landing is legal even inside AA (kamikaze resolved in apply_move).
                    if (player_idx(t.player) != me) add_sq(nc, nr);
                    else if (can_stack_together(*ctx.pieces, piece, t) && !dest_in_enemy_aa) add_sq(nc, nr);
                    // Air force ray stops after first occupied square.
                    break;
                }
                if (!dest_in_enemy_aa) add_sq(nc, nr);
            }
        }
        return res;
    }

    if (k == "A") {
        int dirs[8][2] = {{0,1},{0,-1},{1,0},{-1,0},{1,1},{1,-1},{-1,1},{-1,-1}};
        int ndirs = use_diag ? 8 : 4;
        bool eng_carried = is_carried_by_engineer(piece, *ctx.pieces);
        for (int di = 0; di < ndirs; di++) {
            int dx = dirs[di][0], dy = dirs[di][1];
            for (int s = 1; s <= rng; s++) {
                int nc = col + dx * s, nr = row + dy * s;
                if (!on_board(nc, nr)) break;
                if (is_sea(nc, nr)) break;
                int pi = piece_index_at(nc, nr);
                if (crosses_river(row, nr) && !is_reef(col) && !eng_carried) {
                    if (pi >= 0 && player_idx((*ctx.pieces)[pi].player) != me) add_sq(nc, nr);
                    break;
                }
                if (pi >= 0) {
                    if (player_idx((*ctx.pieces)[pi].player) != me) add_sq(nc, nr);
                    else if (can_stack_at(nc, nr)) add_sq(nc, nr);
                    break;
                }
                add_sq(nc, nr);
            }
        }
        for (auto& d : ORTHO) {
            for (int s = 1; s <= 3; s++) {
                int nc = col + d[0] * s, nr = row + d[1] * s;
                if (!on_board(nc, nr)) break;
                int pi = piece_index_at(nc, nr);
                if (pi >= 0) {
                    if (player_idx((*ctx.pieces)[pi].player) != me && is_sea(nc, nr)) add_sq(nc, nr);
                    break;
                }
            }
        }
        return res;
    }

    if (k == "Aa") {
        bool eng_carried = is_carried_by_engineer(piece, *ctx.pieces);
        for (auto& d : ORTHO) {
            for (int s = 1; s <= rng; s++) {
                int nc = col + d[0] * s, nr = row + d[1] * s;
                if (!on_board(nc, nr)) break;
                if (is_sea(nc, nr)) break;
                if (crosses_river(row, nr) && !is_reef(col) && !eng_carried) break;
                int pi = piece_index_at(nc, nr);
                if (pi >= 0) {
                    if (player_idx((*ctx.pieces)[pi].player) != me) add_sq(nc, nr);
                    else if (can_stack_at(nc, nr)) add_sq(nc, nr);
                    break;
                }
                add_sq(nc, nr);
            }
        }
        return res;
    }

    if (k == "Ms") {
        bool eng_carried = is_carried_by_engineer(piece, *ctx.pieces);
        for (auto& d : ORTHO) {
            for (int s = 1; s <= rng; s++) {
                int nc = col + d[0] * s, nr = row + d[1] * s;
                if (!on_board(nc, nr)) break;
                if (is_sea(nc, nr)) break;
                if (crosses_river(row, nr) && !is_reef(col) && !eng_carried) break;
                int pi = piece_index_at(nc, nr);
                if (pi >= 0) {
                    if (player_idx((*ctx.pieces)[pi].player) != me) add_sq(nc, nr);
                    else if (can_stack_at(nc, nr)) add_sq(nc, nr);
                    break;
                }
                add_sq(nc, nr);
            }
        }
        // Missile fire ring: orthogonal range 2, diagonal range 1 only.
        for (int dc = -2; dc <= 2; dc++) {
            for (int dr = -2; dr <= 2; dr++) {
                if (dc == 0 && dr == 0) continue;
                // Only pure orthogonal (range 1–2) or pure adjacent diagonal (range 1):
                bool is_orthogonal = (dc == 0 || dr == 0);
                bool is_adj_diag   = (std::abs(dc) == 1 && std::abs(dr) == 1);
                if (!is_orthogonal && !is_adj_diag) continue;
                int nc = col + dc, nr = row + dr;
                if (!on_board(nc, nr)) continue;
                // Bug #4 fix: Missile only hits ground and air targets, not Navy/sea.
                int pi = piece_index_at(nc, nr);
                if (pi >= 0) {
                    const Piece& tp = (*ctx.pieces)[pi];
                    if (player_idx(tp.player) != me && tp.kind != "N" && !is_sea(nc, nr))
                        add_sq(nc, nr);
                }
            }
        }
        return res;
    }

    if (k == "E") {
        for (auto& d : ORTHO) {
            int nc = col + d[0], nr = row + d[1];
            if (!on_board(nc, nr) || is_sea(nc, nr)) continue;
            int pi = piece_index_at(nc, nr);
            if (pi >= 0) {
                if (player_idx((*ctx.pieces)[pi].player) != me) add_sq(nc, nr);
                else if (can_stack_at(nc, nr)) add_sq(nc, nr);
            } else {
                add_sq(nc, nr);
            }
        }
        return res;
    }

    // Infantry, Militia, Tank.
    int dirs[8][2] = {{0,1},{0,-1},{1,0},{-1,0},{1,1},{1,-1},{-1,1},{-1,-1}};
    int ndirs = use_diag ? 8 : 4;
    for (int di = 0; di < ndirs; di++) {
        int dx = dirs[di][0], dy = dirs[di][1];
        for (int s = 1; s <= rng; s++) {
            int nc = col + dx * s, nr = row + dy * s;
            if (!on_board(nc, nr) || is_sea(nc, nr)) break;
            int pi = piece_index_at(nc, nr);
            if (pi >= 0) {
                if (player_idx((*ctx.pieces)[pi].player) != me) add_sq(nc, nr);
                else if (can_stack_at(nc, nr)) add_sq(nc, nr);
                break;
            }
            add_sq(nc, nr);
        }
    }

    // Tank sea-capture: Tank can stand still to capture enemy pieces at sea (range up to 2).
    // This is a fire-only action — the Tank does not move onto the sea square.
    if (k == "T") {
        for (auto& d : ORTHO) {
            for (int s = 1; s <= rng; s++) {
                int nc = col + d[0] * s, nr = row + d[1] * s;
                if (!on_board(nc, nr)) break;
                int pi = piece_index_at(nc, nr);
                if (pi >= 0) {
                    if (is_sea(nc, nr) && player_idx((*ctx.pieces)[pi].player) != me)
                        add_sq(nc, nr);
                    break;
                }
                // If empty land square, continue scanning; if empty sea square, also continue.
            }
        }
    }

    return res;
}

static std::vector<Move2> get_moves_with_ctx(const Piece& piece, const MoveGenContext& ctx) {
    return bb_to_moves_sorted(get_move_mask_bitboard(piece, ctx));
}

static std::vector<Move2> get_moves(const Piece& piece, const PieceList& pieces_in) {
    MoveGenContext ctx = build_movegen_context(pieces_in);
    return get_moves_with_ctx(piece, ctx);
}

static bool has_legal_destination(const Piece& piece, const PieceList& pieces,
                                  int dc, int dr) {
    auto mvs = get_moves(piece, pieces);
    for (const auto& mv : mvs) {
        if (mv.first == dc && mv.second == dr) return true;
    }
    return false;
}

static bool square_capturable_by_player(const PieceList& pieces, int col, int row,
                                        const std::string& by_player) {
    for (const auto& p : pieces) {
        if (p.player != by_player) continue;
        if (!on_board(p.col, p.row)) continue;
        auto mvs = get_moves(p, pieces);
        for (const auto& mv : mvs) {
            if (mv.first == col && mv.second == row) return true;
        }
    }
    return false;
}

static void promote_heroes_from_checks(PieceList& pieces) {
    bool changed = true;
    while (changed) {
        changed = false;
        for (auto& p : pieces) {
            if (p.hero) continue;
            if (!on_board(p.col, p.row)) continue;
            const Piece* enemy_cmd = nullptr;
            for (const auto& q : pieces) {
                if (q.player == opp(p.player) && q.kind == "C") {
                    enemy_cmd = &q;
                    break;
                }
            }
            if (!enemy_cmd) continue;
            auto mvs = get_moves(p, pieces);
            for (const auto& mv : mvs) {
                if (mv.first == enemy_cmd->col && mv.second == enemy_cmd->row) {
                    p.hero = true;
                    changed = true;
                    break;
                }
            }
        }

        // Last-protector rule: if only one non-Commander, non-HQ piece remains, it becomes heroic.
        for (const std::string side : {"red", "blue"}) {
            int remaining_eligible = 0;
            int last_idx = -1;
            for (int i = 0; i < (int)pieces.size(); i++) {
                const Piece& p = pieces[i];
                if (p.player != side || !on_board(p.col, p.row)) continue;
                if (p.kind == "C" || p.kind == "H") continue;
                remaining_eligible++;
                last_idx = i;
                if (remaining_eligible > 1) break;
            }
            if (remaining_eligible == 1 && last_idx >= 0 && !pieces[last_idx].hero) {
                pieces[last_idx].hero = true;
                changed = true;
            }
        }
    }
}

static void push_position_history(std::vector<uint64_t>& history, uint64_t hash) {
    history.push_back(hash);
    const size_t MAX_HIST = 200;
    if (history.size() > MAX_HIST) {
        history.erase(history.begin(), history.begin() + (history.size() - MAX_HIST));
    }
}

static bool is_threefold_repetition(const std::vector<uint64_t>& history, uint64_t hash) {
    int cnt = 0;
    for (uint64_t h : history) {
        if (h == hash && ++cnt >= 3) return true;
    }
    return false;
}

// ═══════════════════════════════════════════════════════════════════════════
// WIN CHECK
// ═══════════════════════════════════════════════════════════════════════════

enum class GameMode {
    FULL_BATTLE,   // Capture the Commander to win.
    MARINE_BATTLE, // First side to destroy 2 enemy Navies wins.
    AIR_BATTLE,    // First side to destroy 2 enemy Air Forces wins.
    LAND_BATTLE,   // First side to destroy 2 Tanks + 2 Infantry + 2 Artillery wins.
};
static GameMode g_game_mode = GameMode::FULL_BATTLE;

static const char* game_mode_name(GameMode mode) {
    switch (mode) {
    case GameMode::MARINE_BATTLE: return "Marine Battle";
    case GameMode::AIR_BATTLE:    return "Air Battle";
    case GameMode::LAND_BATTLE:   return "Land Battle";
    case GameMode::FULL_BATTLE:
    default: return "Full Battle";
    }
}

static std::string check_win(const PieceList& pieces, const std::string& last) {
    std::string op = opp(last);
    int cnt_C=0, cnt_N=0, cnt_Af=0, cnt_T=0, cnt_In=0, cnt_A=0;
    for (auto& p : pieces) {
        if (p.player != op) continue;
        if (!on_board(p.col, p.row)) continue;
        if (p.kind=="C")  cnt_C++;
        if (p.kind=="N")  cnt_N++;
        if (p.kind=="Af") cnt_Af++;
        if (p.kind=="T")  cnt_T++;
        if (p.kind=="In") cnt_In++;
        if (p.kind=="A")  cnt_A++;
    }
    bool commander_captured = (cnt_C == 0);

    switch (g_game_mode) {
    case GameMode::MARINE_BATTLE:
        if (commander_captured) return last + " wins — Commander captured!";
        if (cnt_N == 0)         return last + " wins — Naval division destroyed!";
        break;
    case GameMode::AIR_BATTLE:
        if (commander_captured) return last + " wins — Commander captured!";
        if (cnt_Af == 0)        return last + " wins — Air Force destroyed!";
        break;
    case GameMode::LAND_BATTLE:
        if (commander_captured) return last + " wins — Commander captured!";
        if (cnt_T == 0 && cnt_In == 0 && cnt_A == 0)
            return last + " wins — Land division destroyed!";
        break;
    case GameMode::FULL_BATTLE:
    default:
        if (commander_captured) return last + " wins — Commander captured!";
        break;
    }
    return "";
}

// ═══════════════════════════════════════════════════════════════════════════
// INITIAL BOARD SETUP
// ═══════════════════════════════════════════════════════════════════════════

static PieceList make_initial_pieces() {
    PieceList all;
    int pid = 0;
    auto add = [&](const std::string& player, const std::string& kind, int col, int row) {
        all.push_back({pid++, player, kind, col, row, false, -1});
    };
    // Official setup (Figure 4 in the rulebook), mirrored by side.
    // RED — bottom half
    add("red","C",  6,0);
    add("red","N",  1,1);
    add("red","Af", 4,1); add("red","H", 5,1); add("red","H", 7,1); add("red","Af", 8,1);
    add("red","A",  3,2); add("red","Ms",6,2); add("red","A", 9,2);
    add("red","N",  2,3); add("red","Aa",4,3); add("red","T", 5,3); add("red","T", 7,3); add("red","Aa",8,3);
    add("red","In",2,4); add("red","E", 3,4); add("red","M", 6,4); add("red","E", 9,4); add("red","In",10,4);

    // BLUE — top half
    add("blue","In",10,7); add("blue","E", 9,7); add("blue","M", 6,7); add("blue","E", 3,7); add("blue","In",2,7);
    add("blue","Aa",8,8); add("blue","T", 7,8); add("blue","T", 5,8); add("blue","Aa",4,8); add("blue","N",2,8);
    add("blue","A", 9,9); add("blue","Ms",6,9); add("blue","A", 3,9);
    add("blue","Af",8,10); add("blue","H",7,10); add("blue","H",5,10); add("blue","Af",4,10); add("blue","N",1,10);
    add("blue","C", 6,11);
    // Note: heroic status is granted only when a piece delivers check during gameplay,
    // not at initial setup. Do NOT call promote_heroes_from_checks here.
    return all;
}

// ═══════════════════════════════════════════════════════════════════════════
// AI ENGINE — Iterative Deepening Alpha-Beta + Quiescence + TT + PST
// ═══════════════════════════════════════════════════════════════════════════

// ── Piece-square tables (Midgame + Endgame pairs) ─────────────────────────
// All tables are from blue's perspective (row 0=bottom, 11=top).
// Red's view is mirrored vertically. Phase-interpolated in board_score.

// Commander: midgame → stay back & safe; endgame → become active
static const int PST_C_MG[12][11] = {
    { 0, 0, 0, 0, 2, 4, 2, 0, 0, 0, 0},
    { 0, 0, 0, 1, 4, 6, 4, 1, 0, 0, 0},
    { 0, 0, 0, 2, 6, 8, 6, 2, 0, 0, 0},
    { 0, 0, 0, 2, 6, 8, 6, 2, 0, 0, 0},
    { 0, 0, 0, 1, 4, 5, 4, 1, 0, 0, 0},
    { 0, 0, 0, 0, 2, 3, 2, 0, 0, 0, 0},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    { 0, 0, 0, 0,-2,-2,-2, 0, 0, 0, 0},
    { 0, 0, 0,-2,-4,-5,-4,-2, 0, 0, 0},
    { 0, 0,-2,-4,-6,-8,-6,-4,-2, 0, 0},
    { 0,-2,-4,-6,-8,-10,-8,-6,-4,-2, 0},
    { 0,-4,-6,-8,-10,-12,-10,-8,-6,-4, 0},
};
static const int PST_C_EG[12][11] = {
    { 0, 0, 0, 2, 6, 8, 6, 2, 0, 0, 0},
    { 0, 0, 2, 4, 8,10, 8, 4, 2, 0, 0},
    { 0, 0, 4, 6,10,12,10, 6, 4, 0, 0},
    { 0, 0, 4, 6,10,12,10, 6, 4, 0, 0},
    { 0, 0, 2, 4, 8,10, 8, 4, 2, 0, 0},
    { 0, 0, 0, 2, 6, 8, 6, 2, 0, 0, 0},
    { 0, 0, 0, 2, 6, 8, 6, 2, 0, 0, 0},
    { 0, 0, 2, 4, 8,10, 8, 4, 2, 0, 0},
    { 0, 0, 4, 6,10,12,10, 6, 4, 0, 0},
    { 0, 0, 4, 6,10,12,10, 6, 4, 0, 0},
    { 0, 0, 4, 6,10,12,10, 6, 4, 0, 0},
    { 0, 0, 2, 4, 8,10, 8, 4, 2, 0, 0},
};

// Infantry/Militia/Engineer: midgame → hold line; endgame → advance aggressively
static const int PST_In_MG[12][11] = {
    {0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0},
    {0, 0, 0, 2, 3, 3, 3, 2, 0, 0, 0},
    {0, 0, 0, 4, 6, 7, 6, 4, 0, 0, 0},
    {0, 0, 2, 5, 8,10, 8, 5, 2, 0, 0},
    {0, 0, 4, 6,10,12,10, 6, 4, 0, 0},
    {0, 0, 4, 6,10,12,10, 6, 4, 0, 0},
    {0, 0, 3, 5, 8,10, 8, 5, 3, 0, 0},
    {0, 0, 2, 4, 6, 8, 6, 4, 2, 0, 0},
};
static const int PST_In_EG[12][11] = {
    {0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0, 0, 0, 0, 0, 0,0,0,0},
    {0,0,0, 2, 3, 3, 3, 2,0,0,0},
    {0, 0, 2, 4, 6, 7, 6, 4, 2, 0, 0},
    {0, 0, 4, 7,10,12,10, 7, 4, 0, 0},
    {0, 0, 6, 9,14,16,14, 9, 6, 0, 0},
    {0, 0, 8,12,18,22,18,12, 8, 0, 0},
    {0, 0,10,14,20,25,20,14,10, 0, 0},
    {0, 0,12,16,22,28,22,16,12, 0, 0},
    {0, 0,10,14,18,22,18,14,10, 0, 0},
};

// Tank: midgame → center control; endgame → enemy territory
static const int PST_T_MG[12][11] = {
    {0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,2,2,2,0,0,0,0},
    {0, 0, 0, 2, 4, 5, 4, 2, 0, 0, 0},
    {0, 0, 2, 4, 7, 8, 7, 4, 2, 0, 0},
    {0, 0, 3, 6,10,12,10, 6, 3, 0, 0},
    {0, 0, 4, 7,12,14,12, 7, 4, 0, 0},
    {0, 0, 4, 7,12,14,12, 7, 4, 0, 0},
    {0, 0, 3, 6,10,12,10, 6, 3, 0, 0},
    {0, 0, 2, 4, 8,10, 8, 4, 2, 0, 0},
    {0, 0, 0, 2, 6, 8, 6, 2, 0, 0, 0},
};
static const int PST_T_EG[12][11] = {
    {0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,2,2,2,0,0,0,0},
    {0, 0, 0, 2, 5, 6, 5, 2, 0, 0, 0},
    {0, 0, 2, 5, 8, 9, 8, 5, 2, 0, 0},
    {0, 0, 4, 7,11,13,11, 7, 4, 0, 0},
    {0, 0, 5, 8,14,16,14, 8, 5, 0, 0},
    {0, 0, 6,10,16,18,16,10, 6, 0, 0},
    {0, 0, 6,10,16,18,16,10, 6, 0, 0},
    {0, 0, 5, 8,14,16,14, 8, 5, 0, 0},
    {0, 0, 4, 6,10,12,10, 6, 4, 0, 0},
};

// Artillery: midgame → safe back positions with range; endgame → more active
static const int PST_A_MG[12][11] = {
    {0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0},
    {0, 0, 0, 3, 6, 7, 6, 3, 0, 0, 0},
    {0, 0, 2, 4, 7, 8, 7, 4, 2, 0, 0},
    {0, 0, 2, 5, 8, 9, 8, 5, 2, 0, 0},
    {0, 0, 3, 6, 9,10, 9, 6, 3, 0, 0},
    {0, 0, 3, 6,10,12,10, 6, 3, 0, 0},
    {0, 0, 3, 6,10,12,10, 6, 3, 0, 0},
    {0, 0, 2, 5, 8,10, 8, 5, 2, 0, 0},
    {0, 0, 2, 4, 6, 8, 6, 4, 2, 0, 0},
    {0, 0, 0, 2, 4, 6, 4, 2, 0, 0, 0},
    {0, 0, 0, 0, 2, 4, 2, 0, 0, 0, 0},
};
static const int PST_A_EG[12][11] = {
    {0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0},
    {0, 0, 0, 2, 5, 6, 5, 2, 0, 0, 0},
    {0, 0, 0, 3, 6, 7, 6, 3, 0, 0, 0},
    {0, 0, 2, 4, 8, 9, 8, 4, 2, 0, 0},
    {0, 0, 3, 6,10,12,10, 6, 3, 0, 0},
    {0, 0, 4, 7,12,14,12, 7, 4, 0, 0},
    {0, 0, 4, 7,12,14,12, 7, 4, 0, 0},
    {0, 0, 3, 6,10,12,10, 6, 3, 0, 0},
    {0, 0, 2, 4, 8,10, 8, 4, 2, 0, 0},
    {0, 0, 0, 2, 6, 8, 6, 2, 0, 0, 0},
    {0, 0, 0, 0, 4, 6, 4, 0, 0, 0, 0},
};

// Air Force: midgame → behind lines or flanks; endgame → aggressive
static const int PST_Af_MG[12][11] = {
    {0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,2,4,4,4,2,0,0,0},
    {0, 0, 2, 4, 7, 8, 7, 4, 2, 0, 0},
    {0, 0, 4, 6, 9,10, 9, 6, 4, 0, 0},
    {0, 0, 5, 8,12,14,12, 8, 5, 0, 0},
    {0, 0, 6, 9,14,16,14, 9, 6, 0, 0},
    {0, 0, 5, 8,12,14,12, 8, 5, 0, 0},
    {0, 0, 4, 6,10,12,10, 6, 4, 0, 0},
    {0, 0, 2, 4, 8,10, 8, 4, 2, 0, 0},
    {0, 0, 0, 2, 6, 8, 6, 2, 0, 0, 0},
};
static const int PST_Af_EG[12][11] = {
    {0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,2,2,2,0,0,0,0},
    {0, 0, 0, 2, 5, 6, 5, 2, 0, 0, 0},
    {0, 0, 2, 4, 8,10, 8, 4, 2, 0, 0},
    {0, 0, 4, 7,12,14,12, 7, 4, 0, 0},
    {0, 0, 6,10,16,18,16,10, 6, 0, 0},
    {0, 0, 8,12,18,22,18,12, 8, 0, 0},
    {0, 0, 8,12,18,22,18,12, 8, 0, 0},
    {0, 0, 6,10,16,18,16,10, 6, 0, 0},
    {0, 0, 4, 8,12,14,12, 8, 4, 0, 0},
};

// Navy: sea-based; both phases similar (sea positions matter most)
static const int PST_N_MG[12][11] = {
    {8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {8,12, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {8,12, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {8,12, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {8,10, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {6, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {6, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {8,10, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {8,12, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {8,12, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {8,12, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};
static const int PST_N_EG[12][11] = {
    {10,10, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {10,14, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {10,14, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {10,14, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {10,12, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    { 8,10, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    { 8,10, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {10,12, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {10,14, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {10,14, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {10,14, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {10,10, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};

// Missile: midgame → centre/forward; endgame → even more forward
static const int PST_Ms_MG[12][11] = {
    {0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,2,2,2,0,0,0,0},
    {0, 0, 0, 2, 5, 6, 5, 2, 0, 0, 0},
    {0, 0, 2, 4, 7, 8, 7, 4, 2, 0, 0},
    {0, 0, 3, 6,10,12,10, 6, 3, 0, 0},
    {0, 0, 4, 7,12,14,12, 7, 4, 0, 0},
    {0, 0, 3, 6,10,12,10, 6, 3, 0, 0},
    {0, 0, 2, 4, 8,10, 8, 4, 2, 0, 0},
    {0, 0, 0, 2, 6, 8, 6, 2, 0, 0, 0},
    {0, 0, 0, 0, 4, 6, 4, 0, 0, 0, 0},
};
static const int PST_Ms_EG[12][11] = {
    {0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,2,2,2,0,0,0,0},
    {0, 0, 0, 2, 5, 6, 5, 2, 0, 0, 0},
    {0, 0, 2, 4, 8,10, 8, 4, 2, 0, 0},
    {0, 0, 4, 7,12,14,12, 7, 4, 0, 0},
    {0, 0, 6,10,16,18,16,10, 6, 0, 0},
    {0, 0, 6,10,16,18,16,10, 6, 0, 0},
    {0, 0, 4, 8,14,16,14, 8, 4, 0, 0},
    {0, 0, 2, 6,10,12,10, 6, 2, 0, 0},
    {0, 0, 0, 4, 8,10, 8, 4, 0, 0, 0},
};

// Anti-air: midgame → central coverage; endgame → similar
static const int PST_Aa_MG[12][11] = {
    {0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,2,2,2,0,0,0,0},
    {0,0,0,2,4,5,4,2,0,0,0},
    {0,0,2,4,6,7,6,4,2,0,0},
    {0, 0, 2, 4, 7, 8, 7, 4, 2, 0, 0},
    {0, 0, 2, 4, 7, 8, 7, 4, 2, 0, 0},
    {0, 0, 2, 4, 7, 8, 7, 4, 2, 0, 0},
    {0, 0, 2, 4, 7, 8, 7, 4, 2, 0, 0},
    {0, 0, 2, 4, 6, 7, 6, 4, 2, 0, 0},
    {0,0,0,2,4,5,4,2,0,0,0},
    {0,0,0,0,2,2,2,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0},
};
static const int PST_Aa_EG[12][11] = {
    {0,0,0,0,0,0,0,0,0,0,0},
    {0,0,0,0,2,2,2,0,0,0,0},
    {0,0,0,2,4,5,4,2,0,0,0},
    {0,0,2,4,6,7,6,4,2,0,0},
    {0, 0, 2, 4, 7, 8, 7, 4, 2, 0, 0},
    {0, 0, 2, 4, 7, 8, 7, 4, 2, 0, 0},
    {0, 0, 2, 4, 7, 8, 7, 4, 2, 0, 0},
    {0, 0, 2, 4, 7, 8, 7, 4, 2, 0, 0},
    {0, 0, 2, 4, 6, 7, 6, 4, 2, 0, 0},
    {0,0,0,2,4,5,4,2,0,0,0},
    {0,0,0,0,2,2,2,0,0,0,0},
    {0,0,0,0,0,0,0,0,0,0,0},
};

// Game phase: 256 = full midgame, 0 = pure endgame.
// Based on non-Commander, non-HQ material remaining.
static const int PHASE_TOTAL = 2 * (100 + 120 + 300*2 + 80*2 + 350*2 + 200*2 + 250 + 500*2 + 450*2);

static int compute_game_phase(const PieceList& pieces) {
    int mat = 0;
    for (auto& p : pieces) {
        if (p.kind == "C" || p.kind == "H") continue;
        int v = piece_value_fast(p.kind);
        mat += v;
    }
    int phase = (mat * 256 + PHASE_TOTAL / 2) / PHASE_TOTAL;
    if (phase > 256) phase = 256;
    if (phase < 0)   phase = 0;
    return phase;
}

// Interpolate between midgame and endgame PST values.
// phase: 256=midgame, 0=endgame.
static int get_pst_phased(const std::string& kind, const std::string& player,
                          int col, int row, int phase) {
    int r = (player == "blue") ? row : (11 - row);
    if (r<0||r>11||col<0||col>10) return 0;
    int mg = 0, eg = 0;
    if      (kind=="C")                    { mg = PST_C_MG[r][col];  eg = PST_C_EG[r][col]; }
    else if (kind=="In"||kind=="M"||kind=="E") { mg = PST_In_MG[r][col]; eg = PST_In_EG[r][col]; }
    else if (kind=="T")                    { mg = PST_T_MG[r][col];  eg = PST_T_EG[r][col]; }
    else if (kind=="A")                    { mg = PST_A_MG[r][col];  eg = PST_A_EG[r][col]; }
    else if (kind=="Af")                   { mg = PST_Af_MG[r][col]; eg = PST_Af_EG[r][col]; }
    else if (kind=="N")                    { mg = PST_N_MG[r][col];  eg = PST_N_EG[r][col]; }
    else if (kind=="Aa")                   { mg = PST_Aa_MG[r][col]; eg = PST_Aa_EG[r][col]; }
    else if (kind=="Ms")                   { mg = PST_Ms_MG[r][col]; eg = PST_Ms_EG[r][col]; }
    else return 0;
    return (mg * phase + eg * (256 - phase)) / 256;
}

// Legacy wrapper for quick_eval (uses midgame PST as approximation)
static int get_pst(const std::string& kind, const std::string& player, int col, int row) {
    return get_pst_phased(kind, player, col, row, 160); // ~60% midgame default
}

// ── Move application (non-destructive) ────────────────────────────────────
struct MoveTriple { int pid; int dc, dr; };

static inline bool same_move(const MoveTriple& a, const MoveTriple& b) {
    return a.pid==b.pid && a.dc==b.dc && a.dr==b.dr;
}

static inline bool valid_move_hint(const MoveTriple& m) {
    return m.pid >= 0 && on_board(m.dc, m.dr);
}

// === CHANGED === Commander Chess special-rule summary for canonical move application:
// 1) Carrying/stacking: legal friendly stacking updates carrier_id links and syncs passengers.
// 2) Heroic promotion: promote_heroes_from_checks runs after every legal move resolution.
// 3) AF anti-air interception: non-hero AF entering enemy AA range is destroyed.
// 4) AF bombardment return: AF can capture then return to source square if destination stays capturable.
// 5) Navy/Tank stay-and-fire: navy/tank may capture without entering forbidden terrain.

// Internal implementation shared by both checked and unchecked apply_move variants.
static PieceList apply_move_impl(const PieceList& pieces, int piece_id, int dc, int dr, const std::string& player) {
    PieceList np = pieces;
    Piece* piece = piece_by_id(np, piece_id);
    if (!piece || piece->player != player) return np;
    if (!on_board(dc, dr)) return np;

    int src_col = piece->col;
    int src_row = piece->row;
    if (piece->carrier_id >= 0) piece->carrier_id = -1; // split from carrier

    Piece* target = piece_at(np, dc, dr);
    bool navy_stays = (piece->kind=="N" && target && target->player != player && !is_navigable(dc,dr))
                    || (piece->kind=="T" && target && target->player != player && is_sea(dc,dr));

    // Friendly-stack move (load / board)
    if (target && target->player == player) {
        Piece mover_before = *piece;
        Piece target_before = *target;
        if (can_stack_together(np, mover_before, target_before)) {
            // Mover becomes the carrier.
            piece->col = dc;
            piece->row = dr;
            target->carrier_id = piece->id;
            target->col = dc;
            target->row = dr;
            sync_carried_positions(np, target->id);
            sync_carried_positions(np, piece->id);
        } else {
            return pieces;
        }
        promote_heroes_from_checks(np);
        return np;
    }

    if (target && target->player != player) {
        Piece captured_before = *target;
        remove_piece_with_carried(np, target->id);
        piece = piece_by_id(np, piece_id);
        if (!piece) return np;

        // Non-hero AF entering enemy AA ring is shot down.
        if (piece->kind=="Af" && !piece->hero && in_aa_range(np, dc, dr, player)) {
            remove_piece_with_carried(np, piece->id);
            promote_heroes_from_checks(np);
            return np;
        }

        if (!navy_stays) {
            piece->col = dc;
            piece->row = dr;
            sync_carried_positions(np, piece->id);
        }

        // Bombardment return-to-base: after a land capture (not Navy, not Aircraft), AF may return if landing is unsafe.
        if (piece->kind == "Af" && captured_before.kind != "N" && captured_before.kind != "Af" && !navy_stays) {
            if (square_capturable_by_player(np, dc, dr, opp(player))) {
                piece->col = src_col;
                piece->row = src_row;
                sync_carried_positions(np, piece->id);
            }
        }
        promote_heroes_from_checks(np);
        return np;
    }

    piece->col = dc;
    piece->row = dr;
    sync_carried_positions(np, piece->id);
    promote_heroes_from_checks(np);
    return np;
}

// Checked version: verifies legality before applying. Used by GUI and opening book.
static PieceList apply_move(const PieceList& pieces, int piece_id, int dc, int dr, const std::string& player) {
    const Piece* piece = piece_by_id_c(pieces, piece_id);
    if (!piece || piece->player != player) return pieces;
    if (!on_board(dc, dr)) return pieces;
    if (!has_legal_destination(*piece, pieces, dc, dr)) return pieces;
    return apply_move_impl(pieces, piece_id, dc, dr, player);
}

// Unchecked version: skips redundant legality check. Used by search when legality
// was already verified by the caller (saves a full move generation per search node).
static PieceList apply_move_unchecked(const PieceList& pieces, int piece_id, int dc, int dr, const std::string& player) {
    return apply_move_impl(pieces, piece_id, dc, dr, player);
}

using AllMoves = std::vector<MoveTriple>;

static AllMoves all_moves_for(const PieceList& pieces, const std::string& player) {
    AllMoves result;
    MoveGenContext ctx = build_movegen_context(pieces);
    for (auto& p : pieces) {
        if (p.player != player) continue;
        auto mvs = get_moves_with_ctx(p, ctx);
        for (auto& m : mvs) result.push_back({p.id, m.first, m.second});
    }
    return result;
}

// True if `player` can win immediately in one move from `pieces`.
static bool has_immediate_winning_move(const PieceList& pieces, const std::string& player) {
    AllMoves moves = all_moves_for(pieces, player);
    for (auto& m : moves) {
        PieceList np = apply_move(pieces, m.pid, m.dc, m.dr, player);
        if (!check_win(np, player).empty()) return true;
    }
    return false;
}

static inline uint64_t zobrist_piece_key(const Piece& p);

static int quick_piece_unit_score(const Piece& p) {
    int val = piece_value_fast(p.kind);
    if (p.hero) val = (int)(val * 1.5f);
    // Fast positional component for incremental eval.
    val += get_pst(p.kind, p.player, p.col, p.row) * 2;
    return val;
}

static int quick_piece_score_cpu(const Piece& p, const std::string& cpu_player) {
    int s = quick_piece_unit_score(p);
    return p.player == cpu_player ? s : -s;
}

static int quick_eval_cpu(const PieceList& pieces, const std::string& cpu_player) {
    int v = 0;
    for (auto& p : pieces) v += quick_piece_score_cpu(p, cpu_player);
    return v;
}

struct AttackCache {
    bool valid = false;
    uint64_t key = 0; // state hash at which cache was built
    int counts[2][12][11]{};
    BB132 attacked_any[2];
    int attacked_square_count[2]{0, 0};
};

struct SearchState {
    PieceList pieces;
    std::string turn;
    uint64_t hash = 0;
    int quick_eval = 0; // from CPU perspective
    AttackCache atk;
    // Cached commander positions (indexed by player: 0=red, 1=blue), -1 if captured.
    int cmd_col[2] = {-1, -1};
    int cmd_row[2] = {-1, -1};
    // Cached navy counts per player.
    int navy_count[2] = {0, 0};

    void rebuild_caches() {
        cmd_col[0] = cmd_col[1] = -1;
        cmd_row[0] = cmd_row[1] = -1;
        navy_count[0] = navy_count[1] = 0;
        for (auto& p : pieces) {
            int pi = (p.player == "red") ? 0 : 1;
            if (p.kind == "C") { cmd_col[pi] = p.col; cmd_row[pi] = p.row; }
            if (p.kind == "N") navy_count[pi]++;
        }
    }
};

struct UndoMove {
    // Always true in current implementation.
    bool used_snapshot = true;
    PieceList snapshot_pieces;
    Piece moved_piece{};
    Piece captured_piece{};
    bool had_capture = false;
    std::string turn_before;
    uint64_t hash_before = 0;
    int quick_eval_before = 0;
};

static SearchState make_search_state(const PieceList& pieces, const std::string& turn,
                                     const std::string& cpu_player);

static int find_piece_idx_by_id(const PieceList& pieces, int pid) {
    for (int i = 0; i < (int)pieces.size(); i++) if (pieces[i].id == pid) return i;
    return -1;
}

static int find_piece_idx_at(const PieceList& pieces, int col, int row) {
    for (int i = 0; i < (int)pieces.size(); i++)
        if (pieces[i].carrier_id < 0 && pieces[i].col==col && pieces[i].row==row) return i;
    return -1;
}

static bool validate_state(const PieceList& pieces) {
    std::set<int> ids;
    std::set<std::pair<int,int>> occ;
    for (auto& p : pieces) {
        if (!on_board(p.col, p.row)) return false;
        if (!ids.insert(p.id).second) return false;
        if (p.carrier_id < 0 && !occ.insert({p.col, p.row}).second) return false;
    }
    for (auto& p : pieces) {
        if (p.carrier_id < 0) continue;
        if (p.carrier_id == p.id) return false;
        const Piece* c = piece_by_id_c(pieces, p.carrier_id);
        if (!c) return false;
        if (c->player != p.player) return false;
        if (!can_carry_kind(c->kind, p.kind)) return false;
        if (p.col != c->col || p.row != c->row) return false;
    }
    for (const auto& p : pieces) {
        if (!carrier_capacity_valid(pieces, p.id, p.kind)) return false;
    }
    return true;
}

// Sim-mode validator: catches corrupted states early and prints useful crash context.
static bool validate_state_for_sim(const PieceList& pieces,
                                   const std::string& last_mover,
                                   std::string* reason = nullptr) {
    std::set<int> ids;
    std::set<std::pair<int,int>> occ;
    int red_cmd = 0;
    int blue_cmd = 0;

    for (auto& p : pieces) {
        if (!on_board(p.col, p.row)) {
            if (reason) *reason = "piece out of bounds";
            return false;
        }
        if (!ids.insert(p.id).second) {
            if (reason) *reason = "duplicate piece id";
            return false;
        }
        if (p.carrier_id < 0 && !occ.insert({p.col, p.row}).second) {
            if (reason) *reason = "square occupied by multiple pieces";
            return false;
        }
        if (p.kind == "C") {
            if (p.player == "red") red_cmd++;
            else if (p.player == "blue") blue_cmd++;
        }
    }

    for (auto& p : pieces) {
        if (p.carrier_id < 0) continue;
        if (p.carrier_id == p.id) {
            if (reason) *reason = "piece carries itself";
            return false;
        }
        const Piece* c = piece_by_id_c(pieces, p.carrier_id);
        if (!c) {
            if (reason) *reason = "missing carrier piece";
            return false;
        }
        if (c->player != p.player) {
            if (reason) *reason = "cross-player carrying link";
            return false;
        }
        if (!can_carry_kind(c->kind, p.kind)) {
            if (reason) *reason = "illegal carrier/passenger pairing";
            return false;
        }
        if (p.col != c->col || p.row != c->row) {
            if (reason) *reason = "carried piece desynced from carrier";
            return false;
        }
    }
    for (const auto& p : pieces) {
        if (!carrier_capacity_valid(pieces, p.id, p.kind)) {
            if (reason) *reason = "carrier capacity exceeded";
            return false;
        }
    }

    if (red_cmd == 1 && blue_cmd == 1) return true;

    // Terminal commander-capture states are allowed if they are a legal win state.
    bool terminal_ok = (red_cmd == 0 && blue_cmd == 1) || (red_cmd == 1 && blue_cmd == 0);
    if (terminal_ok && !check_win(pieces, last_mover).empty()) return true;

    if (reason) {
        *reason = "invalid commander count (red=" + std::to_string(red_cmd) +
                  ", blue=" + std::to_string(blue_cmd) + ")";
    }
    return false;
}

static void build_attack_cache(SearchState& st) {
    if (st.atk.valid && st.atk.key == st.hash) return;
    memset(st.atk.counts, 0, sizeof(st.atk.counts));
    st.atk.attacked_any[0].clear();
    st.atk.attacked_any[1].clear();
    st.atk.attacked_square_count[0] = 0;
    st.atk.attacked_square_count[1] = 0;
    MoveGenContext ctx = build_movegen_context(st.pieces);
    for (auto& p : st.pieces) {
        int pl = (p.player=="red") ? 0 : 1;
        BB132 attacks = get_move_mask_bitboard(p, ctx);
        st.atk.attacked_any[pl].or_bits(attacks);
        while (true) {
            int sq = bb_pop_lsb(attacks);
            if (sq < 0) break;
            int c = sq_col(sq), r = sq_row(sq);
            st.atk.counts[pl][r][c]++;
        }
    }
    st.atk.attacked_square_count[0] = bb_popcount(st.atk.attacked_any[0]);
    st.atk.attacked_square_count[1] = bb_popcount(st.atk.attacked_any[1]);
    st.atk.valid = true;
    st.atk.key = st.hash;
}

// === CHANGED ===
// WASM-SAFE: avoid rebuilding attack cache unless state hash changed.
static inline void ensure_attack_cache(SearchState& st) {
    if (!st.atk.valid || st.atk.key != st.hash) build_attack_cache(st);
}

static bool make_move_inplace(SearchState& st, const MoveTriple& m,
                              const std::string& cpu_player, UndoMove& u);

static void unmake_move_inplace(SearchState& st, const UndoMove& u);

// ── Transposition table ───────────────────────────────────────────────────
static const int TT_EXACT = 0, TT_LOWER = 1, TT_UPPER = 2;

// ── Dynamic Transposition Table (heap-allocated, packed entries) ─────────
// Two-tier replacement:
//   slot 0: depth-preferred (replace only on equal/greater depth, or empty)
//   slot 1: always-replace (latest position)
static const int TT_BUCKET = 2;

// Packed TT entry: 20 bytes (was ~40). More entries per cache line = faster.
#pragma pack(push, 1)
struct TTEntry {
    uint64_t key   = 0;     // 8 bytes: full key
    int16_t  depth = 0;     // 2 bytes
    int16_t  val   = 0;     // 2 bytes (clamped ±32000)
    uint8_t  flag  = 0;     // 1 byte
    uint8_t  age   = 0;     // 1 byte
    int16_t  mv_pid = -1;   // 2 bytes: packed move
    int8_t   mv_dc  = -1;   // 1 byte
    int8_t   mv_dr  = -1;   // 1 byte  — Total: 20 bytes
};
#pragma pack(pop)

static inline MoveTriple tt_unpack_move(const TTEntry& e) {
    return {(int)e.mv_pid, (int)e.mv_dc, (int)e.mv_dr};
}
static inline void tt_pack_move(TTEntry& e, const MoveTriple& m) {
    e.mv_pid = (int16_t)m.pid;
    e.mv_dc  = (int8_t)m.dc;
    e.mv_dr  = (int8_t)m.dr;
}

struct TTCluster { TTEntry e[TT_BUCKET]; };

// === CHANGED ===
struct EngineConfig {
    bool use_mcts = false;
    bool use_opening_book = true;
    std::size_t tt_size_mb = 512;
    int max_depth = 8;
    int time_limit_ms = 3000;
    int mcts_ab_depth = 3;
    bool force_single_thread = false; // WASM-SAFE: true in browser builds.
};

static EngineConfig default_engine_config() {
    EngineConfig cfg;
#if defined(__EMSCRIPTEN__)
    cfg.use_mcts = false;
    cfg.use_opening_book = true;
    cfg.tt_size_mb = 128;
    cfg.max_depth = 8;
    cfg.time_limit_ms = 3000;
    cfg.mcts_ab_depth = 2;
    cfg.force_single_thread = true;
#endif
    return cfg;
}

static EngineConfig g_engine_config = default_engine_config();
static bool& g_use_mcts = g_engine_config.use_mcts;
static bool& g_use_opening_book = g_engine_config.use_opening_book;

static inline int engine_mcts_ab_depth() {
    return std::max(1, g_engine_config.mcts_ab_depth);
}

static void set_engine_config(const EngineConfig& cfg) {
    g_engine_config = cfg;
    if (g_engine_config.tt_size_mb < 8) g_engine_config.tt_size_mb = 8;
#if defined(__EMSCRIPTEN__)
    g_engine_config.force_single_thread = true;
    if (g_engine_config.tt_size_mb > 128) g_engine_config.tt_size_mb = 128;
#endif
}

static const EngineConfig& get_engine_config() {
    return g_engine_config;
}

// Contiguous TT arena with configurable size
static size_t    g_tt_count = 0;      // number of clusters
static size_t    g_tt_mask  = 0;      // count - 1 (power of 2)
static TTCluster* g_TT      = nullptr;
static uint8_t   g_tt_age   = 0;
static void*     g_tt_arena = nullptr;
static size_t    g_tt_arena_bytes = 0;
static constexpr std::align_val_t TT_ARENA_ALIGN = std::align_val_t(64);
// Thread-safe TT striping for SMP probe/store.
static constexpr size_t TT_LOCK_STRIPES = 1024; // power-of-two
static std::array<EngineMutex, TT_LOCK_STRIPES> g_tt_locks;

static inline bool tt_locking_enabled() {
#if COMMANDER_ENABLE_THREADS
    return !get_engine_config().force_single_thread;
#else
    return false;
#endif
}

static inline EngineMutex& tt_lock_for_hash(uint64_t h) {
    return g_tt_locks[h & (TT_LOCK_STRIPES - 1)];
}

static void tt_arena_release() {
    if (!g_tt_arena) return;
    // WASM-SAFE: arena uses malloc + explicit alignment metadata.
    void* raw = reinterpret_cast<void**>(g_tt_arena)[-1];
    std::free(raw);
    g_tt_arena = nullptr;
    g_tt_arena_bytes = 0;
}

static void* tt_arena_alloc(size_t bytes) {
    if (bytes == 0) throw std::bad_alloc();
    const size_t align = static_cast<size_t>(TT_ARENA_ALIGN);
    const size_t total = bytes + align + sizeof(void*);
    void* raw = std::malloc(total);
    if (!raw) throw std::bad_alloc();

    void* aligned_base = static_cast<char*>(raw) + sizeof(void*);
    size_t space = total - sizeof(void*);
    void* aligned = std::align(align, bytes, aligned_base, space);
    if (!aligned) {
        std::free(raw);
        throw std::bad_alloc();
    }

    reinterpret_cast<void**>(aligned)[-1] = raw;
    return aligned;
}

static void tt_resize(size_t size_mb) {
    tt_arena_release();
    g_TT = nullptr;
    g_tt_count = 0;
    g_tt_mask = 0;
    size_t bytes = size_mb * 1024ULL * 1024ULL;
    g_tt_count = bytes / sizeof(TTCluster);
    if (g_tt_count == 0) throw std::bad_alloc();
    // Round down to power of 2
    size_t pot = 1;
    while (pot * 2 <= g_tt_count) pot *= 2;
    g_tt_count = pot;
    g_tt_mask  = g_tt_count - 1;
    g_tt_arena_bytes = g_tt_count * sizeof(TTCluster);
    g_tt_arena = tt_arena_alloc(g_tt_arena_bytes);
    g_TT = reinterpret_cast<TTCluster*>(g_tt_arena);
    memset(g_TT, 0, g_tt_arena_bytes);
}

static void tt_ensure_allocated() {
    if (g_TT) return;
    const size_t preferred_mb = std::max<std::size_t>(8, get_engine_config().tt_size_mb);
    if (preferred_mb > 0) {
        try { tt_resize(preferred_mb); return; } catch (...) {}
    }
#if defined(__EMSCRIPTEN__)
    for (size_t mb : {128, 96, 64, 48, 32, 16, 8}) {
#else
    for (size_t mb : {2048, 1024, 768, 512, 384, 256, 192, 128, 96, 64, 32, 8}) {
#endif
        if (mb == preferred_mb) continue;
        try { tt_resize(mb); return; } catch (...) {}
    }
}

static void tt_clear() {
    if (g_TT && g_tt_count > 0)
        memset(g_TT, 0, g_tt_count * sizeof(TTCluster));
    g_tt_age = 0;
}

static inline void tt_prefetch(uint64_t h) {
#if defined(__GNUC__) || defined(__clang__)
    if (g_TT) __builtin_prefetch(&g_TT[h & g_tt_mask], 0, 1);
#endif
}

// Zobrist hashing (flattened piece-state x 132-square table)
static uint64_t g_ZobristTurn[2];

// Fast kind_index: direct char-based switch (no map lookup)
static int kind_index(const std::string& k) {
    if (k.empty()) return 0;
    switch (k[0]) {
        case 'C': return 0;
        case 'H': return 1;
        case 'I': return 2;  // In
        case 'M': return (k.size()>1 && k[1]=='s') ? 8 : 3;  // Ms vs M
        case 'T': return 4;
        case 'E': return 5;
        case 'A': if (k.size()>1) { if (k[1]=='a') return 7; if (k[1]=='f') return 9; }
                  return 6;  // A
        case 'N': return 10;
        default: return 0;
    }
}

static constexpr int ZK_KINDS   = 11;
static constexpr int ZK_PLAYERS = 2;
static constexpr int ZK_HERO    = 2;
static constexpr int ZK_CARRIED = 2;
static constexpr int ZK_STATES  = ZK_KINDS * ZK_PLAYERS * ZK_HERO * ZK_CARRIED; // 88 states
static constexpr int ZK_SQUARES = COLS * ROWS; // 132
static uint64_t g_ZK_piece_sq[ZK_STATES][ZK_SQUARES];

static inline int zobrist_piece_state_index(const Piece& p) {
    int ki = kind_index(p.kind);
    int pl = p.player=="red" ? 0 : 1;
    int hi = p.hero ? 1 : 0;
    int ci = (p.carrier_id >= 0) ? 1 : 0;
    return (((ki * ZK_PLAYERS + pl) * ZK_HERO + hi) * ZK_CARRIED + ci);
}

static uint64_t splitmix64_next(uint64_t& x) {
    x += 0x9E3779B97F4A7C15ULL;
    uint64_t z = x;
    z = (z ^ (z >> 30)) * 0xBF58476D1CE4E5B9ULL;
    z = (z ^ (z >> 27)) * 0x94D049BB133111EBULL;
    return z ^ (z >> 31);
}

static void init_zobrist() {
    uint64_t seed = 0xC0FFEE1234567890ULL;
    for (int st = 0; st < ZK_STATES; st++)
        for (int sq = 0; sq < ZK_SQUARES; sq++)
            g_ZK_piece_sq[st][sq] = splitmix64_next(seed);
    g_ZobristTurn[0] = splitmix64_next(seed);
    g_ZobristTurn[1] = splitmix64_next(seed);
}

static uint64_t zobrist_hash(const PieceList& pieces, const std::string& turn) {
    uint64_t h = g_ZobristTurn[turn=="red" ? 0 : 1];
    for (auto& p : pieces) {
        if (p.row>=0 && p.row<12 && p.col>=0 && p.col<11) {
            int sq = sq_index(p.col, p.row);
            h ^= g_ZK_piece_sq[zobrist_piece_state_index(p)][sq];
        }
    }
    return h;
}

static inline uint64_t zobrist_cpu_perspective_salt(const std::string& cpu_player) {
    // Keep TT keys disjoint across root perspective in self-play (red-search vs blue-search).
    return (cpu_player == "red") ? 0x9E3779B97F4A7C15ULL : 0ULL;
}

static inline uint64_t zobrist_piece_key(const Piece& p) {
    if (!on_board(p.col, p.row)) return 0;
    int sq = sq_index(p.col, p.row);
    return g_ZK_piece_sq[zobrist_piece_state_index(p)][sq];
}

static SearchState make_search_state(const PieceList& pieces, const std::string& turn,
                                     const std::string& cpu_player) {
    SearchState st;
    st.pieces = pieces;
    st.turn = turn;
    st.hash = zobrist_hash(st.pieces, st.turn) ^ zobrist_cpu_perspective_salt(cpu_player);
    st.quick_eval = quick_eval_cpu(st.pieces, cpu_player);
    st.atk.valid = false;
    st.rebuild_caches();
    return st;
}

static void debug_validate_state_or_abort(const PieceList& pieces,
                                          const std::string& last_mover,
                                          const char* where) {
#ifdef DEBUG
    std::string reason;
    if (!validate_state_for_sim(pieces, last_mover, &reason)) {
        std::cerr << "[DEBUG] " << where << " produced invalid state: " << reason << "\n";
        std::abort();
    }
#else
    (void)pieces;
    (void)last_mover;
    (void)where;
#endif
}

// === CHANGED ===
static bool make_move_inplace_snapshot(SearchState& st, const MoveTriple& m,
                                       const std::string& cpu_player, UndoMove& u) {
    u = UndoMove{};
    if (!on_board(m.dc, m.dr)) return false;
    int moved_idx = find_piece_idx_by_id(st.pieces, m.pid);
    if (moved_idx < 0) return false;
    if (st.pieces[moved_idx].player != st.turn) return false;
    if (!has_legal_destination(st.pieces[moved_idx], st.pieces, m.dc, m.dr)) return false;

    u.snapshot_pieces = st.pieces;
    u.turn_before = st.turn;
    u.hash_before = st.hash;
    u.quick_eval_before = st.quick_eval;
    u.moved_piece = st.pieces[moved_idx];

    int captured_idx = find_piece_idx_at(st.pieces, m.dc, m.dr);
    if (captured_idx >= 0 && st.pieces[captured_idx].player != st.turn) {
        u.had_capture = true;
        u.captured_piece = st.pieces[captured_idx];
    }

    st.pieces = apply_move_unchecked(st.pieces, m.pid, m.dc, m.dr, st.turn);
    st.turn = opp(st.turn);
    st.hash = zobrist_hash(st.pieces, st.turn) ^ zobrist_cpu_perspective_salt(cpu_player);
    st.quick_eval = quick_eval_cpu(st.pieces, cpu_player);
    st.atk.valid = false;
    st.rebuild_caches();
    debug_validate_state_or_abort(st.pieces, u.turn_before, "make_move_inplace");
    return true;
}

/*
 * make_move_inplace safety policy (WASM-SAFE):
 *  1) Carrying / stacking transitions (including nested passenger sync)
 *  2) Heroic promotions after decisive checks
 *  3) AF anti-air interception on non-hero entry
 *  4) AF bombardment return-to-origin when landing is unsafe
 *  5) Navy/Tank stay-and-fire behavior on non-enterable sea squares
 *
 * These rules are all handled by apply_move(). We always snapshot and replay
 * that canonical path to avoid incremental state-corruption bugs.
 */
static bool make_move_inplace(SearchState& st, const MoveTriple& m,
                              const std::string& cpu_player, UndoMove& u) {
    return make_move_inplace_snapshot(st, m, cpu_player, u);

#if 0
    // Future optimization:
    // Re-introduce an incremental in-place move path once it is formally
    // proven equivalent to snapshot replay for all special Commander rules.
#endif
}

/*
 * unmake_move_inplace safety policy (perfect inverse of make):
 *  1) Carrying / stacking links are restored exactly from snapshot.
 *  2) Heroic promotions are reversed by snapshot restore.
 *  3) AF anti-air interception outcomes are restored exactly.
 *  4) AF bombardment return-to-origin outcomes are restored exactly.
 *  5) Navy/Tank stay-and-fire outcomes are restored exactly.
 *
 * Full snapshot restore (pieces + turn + hash + eval) guarantees no drift.
 */
static void unmake_move_inplace(SearchState& st, const UndoMove& u) {
    st.turn = u.turn_before;
    st.hash = u.hash_before;
    st.quick_eval = u.quick_eval_before;
    st.pieces = u.snapshot_pieces;
    st.atk.valid = false;
    st.rebuild_caches();
    debug_validate_state_or_abort(st.pieces, opp(st.turn), "unmake_move_inplace");
}

// === CHANGED ===
// Move-generator regression helper.
static uint64_t perft_impl(SearchState& st, int depth, const std::string& cpu_player) {
    if (depth <= 0) return 1ULL;
    AllMoves moves = all_moves_for(st.pieces, st.turn);
    if (depth == 1) return (uint64_t)moves.size();
    uint64_t nodes = 0;
    for (const auto& m : moves) {
        UndoMove u;
        if (!make_move_inplace(st, m, cpu_player, u)) continue;
        nodes += perft_impl(st, depth - 1, cpu_player);
        unmake_move_inplace(st, u);
    }
    return nodes;
}

static uint64_t perft(const PieceList& pieces, const std::string& turn, int depth) {
    SearchState st = make_search_state(pieces, turn, turn);
    return perft_impl(st, depth, turn);
}

static uint64_t perft(int depth) {
    PieceList init = make_initial_pieces();
    return perft(init, "red", depth);
}

// ── Killer moves & History ─────────────────────────────────────────────────
static const int MAX_PLY = 32;

// Board dimensions for history indexing: [player][kind][col][row]
static const int H_PLAYERS = 2, H_KINDS = 11, H_COLS = 11, H_ROWS = 12;

// ── Per-thread search data for Lazy SMP ──────────────────────────────────
struct alignas(64) ThreadData {
    MoveTriple killers[MAX_PLY][2];
    bool killers_set[MAX_PLY][2];
    // Flat history: [player][kind_index][col][row] — O(1) access, memset-clearable
    int history[H_PLAYERS][H_KINDS][H_COLS][H_ROWS];
    // Flat continuation history: [prev_col][prev_row][kind_index][col][row]
    int16_t cont_history[H_COLS][H_ROWS][H_KINDS][H_COLS][H_ROWS];
    MoveTriple pv[MAX_PLY][MAX_PLY];
    int pv_len[MAX_PLY];
    MoveTriple counter[11][12];
    bool counter_set[11][12];
    int thread_id = 0;

    void reset() {
        memset(history, 0, sizeof(history));
        memset(cont_history, 0, sizeof(cont_history));
        for (int i = 0; i < MAX_PLY; i++) killers_set[i][0] = killers_set[i][1] = false;
        memset(pv_len, 0, sizeof(pv_len));
        memset(counter_set, 0, sizeof(counter_set));
    }
};

// Legacy globals — flat arrays for single-thread fallback & headless sim
static MoveTriple g_killers[MAX_PLY][2];
static bool g_killers_set[MAX_PLY][2];
static int g_history[H_PLAYERS][H_KINDS][H_COLS][H_ROWS];
static int16_t g_cont_history[H_COLS][H_ROWS][H_KINDS][H_COLS][H_ROWS];

// ── Correction History forward declarations (full implementation below SEE) ─
static const int CORR_HIST_SIZE     = 16384;
static const int CORR_MAT_SIZE      = 512;
static const int CORR_TERR_SIZE     = 2048;
static int g_corr_hist[2][CORR_HIST_SIZE] = {};
static int g_corr_hist_mat[2][CORR_MAT_SIZE] = {};
static int g_corr_hist_terrain[2][CORR_TERR_SIZE] = {};
static MoveTriple g_pv[MAX_PLY][MAX_PLY];
static int g_pv_len[MAX_PLY];
static MoveTriple g_counter[11][12];
static bool g_counter_set[11][12];

// Default thread data used by legacy single-thread path
static ThreadData g_default_td;

static void init_lmr_table();  // forward declaration

static void reset_search_tables() {
    tt_ensure_allocated();
    // Don't wipe TT — just age it so old entries get displaced naturally
    g_tt_age++;
    init_lmr_table();
    memset(g_history, 0, sizeof(g_history));
    memset(g_cont_history, 0, sizeof(g_cont_history));
    for (int i=0; i<MAX_PLY; i++) g_killers_set[i][0]=g_killers_set[i][1]=false;
    memset(g_pv_len, 0, sizeof(g_pv_len));
    memset(g_counter_set, 0, sizeof(g_counter_set));
    // Correction history is soft-reset: halve values so prior game info fades
    // but strong patterns carry over (same approach as Stockfish inter-game).
    for (int pi = 0; pi < 2; pi++) {
        for (int i = 0; i < CORR_HIST_SIZE; i++) g_corr_hist[pi][i] /= 2;
        for (int i = 0; i < CORR_MAT_SIZE;  i++) g_corr_hist_mat[pi][i] /= 2;
        for (int i = 0; i < CORR_TERR_SIZE; i++) g_corr_hist_terrain[pi][i] /= 2;
    }
    g_default_td.reset();
}

// ── TT probe / store ──────────────────────────────────────────────────────
static const TTEntry* tt_probe(uint64_t h) {
    if (!g_TT) return nullptr;
    auto probe_impl = [&]() -> const TTEntry* {
        const TTCluster& c = g_TT[h & g_tt_mask];
        const TTEntry* dp = &c.e[0];
        const TTEntry* ar = &c.e[1];
        bool dp_hit = (dp->key == h);
        bool ar_hit = (ar->key == h);
        if (dp_hit && ar_hit) {
            // Prefer same-generation entry, then deeper
            bool dp_current = (dp->age == g_tt_age);
            bool ar_current = (ar->age == g_tt_age);
            if (dp_current != ar_current) return dp_current ? dp : ar;
            return (dp->depth >= ar->depth) ? dp : ar;
        }
        if (dp_hit) return dp;
        if (ar_hit) return ar;
        return nullptr;
    };
    if (tt_locking_enabled()) {
        std::lock_guard<EngineMutex> lk(tt_lock_for_hash(h));
        return probe_impl();
    }
    return probe_impl();
}

static void tt_store(uint64_t h, int depth, int flag, int val, MoveTriple best) {
    if (!g_TT) return;
    auto store_impl = [&]() {
        TTCluster& c = g_TT[h & g_tt_mask];
        auto write_entry = [&](TTEntry& e) {
            // Write key last so probes either see old entry or a mostly-complete new entry.
            e.key   = 0;
            e.depth = (int16_t)std::min(depth, (int)INT16_MAX);
            e.flag  = (uint8_t)flag;
            e.val   = (int16_t)std::max(-32000, std::min(32000, val));
            e.age   = g_tt_age;
            tt_pack_move(e, best);
            e.key   = h;
        };

        // Slot 0: depth-preferred, but prefer overwriting stale entries.
        TTEntry& depth_slot = c.e[0];
        bool slot0_stale = (depth_slot.age != g_tt_age);
        if (depth_slot.key == h) {
            if (depth >= depth_slot.depth || flag == TT_EXACT) write_entry(depth_slot);
        } else if (depth_slot.key == 0 || slot0_stale || depth >= depth_slot.depth) {
            write_entry(depth_slot);
        }

        // Slot 1: always replace.
        TTEntry& always_slot = c.e[1];
        write_entry(always_slot);
    };
    if (tt_locking_enabled()) {
        std::lock_guard<EngineMutex> lk(tt_lock_for_hash(h));
        store_impl();
        return;
    }
    store_impl();
}

static void store_killer(const MoveTriple& m, int ply) {
    if (ply >= MAX_PLY) return;
    if (!g_killers_set[ply][0] || !(g_killers[ply][0].pid==m.pid && g_killers[ply][0].dc==m.dc && g_killers[ply][0].dr==m.dr)) {
        g_killers[ply][1] = g_killers[ply][0];
        g_killers_set[ply][1] = g_killers_set[ply][0];
        g_killers[ply][0] = m;
        g_killers_set[ply][0] = true;
    }
}

// ── ThreadData-aware versions for SMP ─────────────────────────────────────
static void td_store_killer(ThreadData& td, const MoveTriple& m, int ply) {
    if (ply >= MAX_PLY) return;
    if (!td.killers_set[ply][0] || !(td.killers[ply][0].pid==m.pid && td.killers[ply][0].dc==m.dc && td.killers[ply][0].dr==m.dr)) {
        td.killers[ply][1] = td.killers[ply][0];
        td.killers_set[ply][1] = td.killers_set[ply][0];
        td.killers[ply][0] = m;
        td.killers_set[ply][0] = true;
    }
}

static int td_history_score(const ThreadData& td, int pl, int ki, int dc, int dr) {
    if (pl<0||pl>=H_PLAYERS||ki<0||ki>=H_KINDS||dc<0||dc>=H_COLS||dr<0||dr>=H_ROWS) return 0;
    return td.history[pl][ki][dc][dr];
}

static void td_update_history(ThreadData& td, int pl, int ki, int dc, int dr, int depth) {
    if (pl<0||pl>=H_PLAYERS||ki<0||ki>=H_KINDS||dc<0||dc>=H_COLS||dr<0||dr>=H_ROWS) return;
    int& v = td.history[pl][ki][dc][dr];
    int bonus = std::min(depth * depth, 1600);
    v += bonus - v * std::abs(bonus) / 32000;
    v = std::max(-32000, std::min(32000, v));
}

static void td_penalise_history(ThreadData& td, int pl, int ki, int dc, int dr, int depth) {
    if (pl<0||pl>=H_PLAYERS||ki<0||ki>=H_KINDS||dc<0||dc>=H_COLS||dr<0||dr>=H_ROWS) return;
    int& v = td.history[pl][ki][dc][dr];
    int malus = -std::min(depth * depth, 1600);
    v += malus - v * std::abs(malus) / 32000;
    v = std::max(-32000, std::min(32000, v));
}

static int td_cont_history_score(const ThreadData& td, const MoveTriple* prev, int ki, int dc, int dr) {
    if (!prev || !on_board(prev->dc, prev->dr)) return 0;
    if (ki<0||ki>=H_KINDS||dc<0||dc>=H_COLS||dr<0||dr>=H_ROWS) return 0;
    return (int)td.cont_history[prev->dc][prev->dr][ki][dc][dr];
}

static void td_update_cont_history(ThreadData& td, const MoveTriple* prev, int ki, int dc, int dr, int depth) {
    if (!prev || !on_board(prev->dc, prev->dr)) return;
    if (ki<0||ki>=H_KINDS||dc<0||dc>=H_COLS||dr<0||dr>=H_ROWS) return;
    int bonus = std::min(depth * depth, 1600);
    int v = (int)td.cont_history[prev->dc][prev->dr][ki][dc][dr];
    v += bonus - v * std::abs(bonus) / 32000;
    td.cont_history[prev->dc][prev->dr][ki][dc][dr] = (int16_t)std::max(-32000, std::min(32000, v));
}

static int history_score(int pl, int ki, int dc, int dr) {
    if (pl<0||pl>=H_PLAYERS||ki<0||ki>=H_KINDS||dc<0||dc>=H_COLS||dr<0||dr>=H_ROWS) return 0;
    return g_history[pl][ki][dc][dr];
}

static void update_history(int pl, int ki, int dc, int dr, int depth) {
    if (pl<0||pl>=H_PLAYERS||ki<0||ki>=H_KINDS||dc<0||dc>=H_COLS||dr<0||dr>=H_ROWS) return;
    int& v = g_history[pl][ki][dc][dr];
    // Stockfish 18 gravity: bonus - entry * |bonus| / MAX_HISTORY
    // This naturally decays old values and prevents saturation.
    int bonus = std::min(depth * depth, 1600);
    v += bonus - v * std::abs(bonus) / 32000;
    v = std::max(-32000, std::min(32000, v));
}

static void penalise_history(int pl, int ki, int dc, int dr, int depth) {
    if (pl<0||pl>=H_PLAYERS||ki<0||ki>=H_KINDS||dc<0||dc>=H_COLS||dr<0||dr>=H_ROWS) return;
    int& v = g_history[pl][ki][dc][dr];
    int malus = -std::min(depth * depth, 1600);
    v += malus - v * std::abs(malus) / 32000;
    v = std::max(-32000, std::min(32000, v));
}

static int cont_history_score(const MoveTriple* prev, int ki, int dc, int dr) {
    if (!prev || !on_board(prev->dc, prev->dr)) return 0;
    if (ki<0||ki>=H_KINDS||dc<0||dc>=H_COLS||dr<0||dr>=H_ROWS) return 0;
    return (int)g_cont_history[prev->dc][prev->dr][ki][dc][dr];
}

static void update_cont_history(const MoveTriple* prev, int ki, int dc, int dr, int depth) {
    if (!prev || !on_board(prev->dc, prev->dr)) return;
    if (ki<0||ki>=H_KINDS||dc<0||dc>=H_COLS||dr<0||dr>=H_ROWS) return;
    int bonus = std::min(depth * depth, 1600);
    int v = (int)g_cont_history[prev->dc][prev->dr][ki][dc][dr];
    v += bonus - v * std::abs(bonus) / 32000;
    g_cont_history[prev->dc][prev->dr][ki][dc][dr] = (int16_t)std::max(-32000, std::min(32000, v));
}

// ═══════════════════════════════════════════════════════════════════════════
// CORRECTION HISTORY  (Stockfish 18 technique)
// ═══════════════════════════════════════════════════════════════════════════
//
// Tracks the signed difference between the static evaluation and the final
// alpha-beta search score, indexed by:
//   (a) a position-hash bucket   — captures transient positional features
//   (b) a material-count bucket  — captures stable material imbalances
//
// These correction values are blended into the static eval before every node
// is pruned, giving the engine a cheap but meaningful bias toward positions
// where history says the static eval under/over-estimates the true score.
// This is the same principle used in Stockfish 16-18 and directly improves
// RFP, Razoring, Probcut, Futility, and LMR accuracy.
// ─────────────────────────────────────────────────────────────────────────

// (CORR_HIST_SIZE, CORR_MAT_SIZE, CORR_TERR_SIZE and corr tables declared above)
static const int CORR_MAX_VAL       = 32000;
static const int CORR_WEIGHT_DENOM  = 256;    // fixed-point denominator

// Material key: sum weighted piece values, bucketed.
static int material_corr_key(const PieceList& pieces, int pi) {
    int key = 0;
    for (const auto& p : pieces) {
        if (p.kind == "H") continue;
        int side = (p.player == "red") ? 0 : 1;
        int sign = (side == pi) ? 1 : -1;
        key += sign * piece_value_fast(p.kind) / 50;
    }
    return (((key % CORR_MAT_SIZE) + CORR_MAT_SIZE) % CORR_MAT_SIZE);
}

static bool commander_near_water_square(int c, int r) {
    if (!on_board(c, r)) return false;
    if (is_sea(c, r) || r == 5 || r == 6) return true;
    for (int dc = -1; dc <= 1; dc++) for (int dr = -1; dr <= 1; dr++) {
        int nc = c + dc, nr = r + dr;
        if (!on_board(nc, nr)) continue;
        if (is_sea(nc, nr) || nr == 5 || nr == 6) return true;
    }
    return false;
}

// === NEW: Terrain-Aware Correction History (~+70 Elo) ===
// Terrain/control/stacking key for fortress-like structure recognition.
static int terrain_corr_key(const PieceList& pieces, int pi) {
    int sea_occ[2] = {0, 0};
    int river_occ[2] = {0, 0};
    int sky_control[2] = {0, 0};
    int cmd_col[2] = {-1, -1};
    int cmd_row[2] = {-1, -1};
    int cmd_exposure[2] = {0, 0};
    int cmd_stack_density[2] = {0, 0};
    int navy_near_water_cmd[2] = {0, 0};

    for (const auto& p : pieces) {
        int s = player_idx(p.player);
        if (!on_board(p.col, p.row)) continue;
        if (is_sea(p.col, p.row)) sea_occ[s] += (p.kind == "N") ? 2 : 1;
        if (p.row == 5 || p.row == 6) river_occ[s] += (p.kind == "E") ? 2 : 1;
        if (p.kind == "Af") sky_control[s] += 3;
        else if (p.kind == "Aa" || p.kind == "Ms") sky_control[s] += 2;
        else if (p.kind == "N") sky_control[s] += 1;
        if (p.kind == "C") { cmd_col[s] = p.col; cmd_row[s] = p.row; }
    }

    for (const auto& p : pieces) {
        int s = player_idx(p.player);
        if (p.kind == "N" && cmd_col[s] >= 0 && commander_near_water_square(cmd_col[s], cmd_row[s])) {
            int dist = std::abs(p.col - cmd_col[s]) + std::abs(p.row - cmd_row[s]);
            if (dist <= 4) navy_near_water_cmd[s] += (5 - dist);
        }
        if (p.carrier_id >= 0 && cmd_col[s] >= 0) {
            int cheb = std::max(std::abs(p.col - cmd_col[s]), std::abs(p.row - cmd_row[s]));
            if (cheb <= 2) cmd_stack_density[s] += 2;
            else if (cheb <= 4) cmd_stack_density[s] += 1;
        }
    }

    for (int s = 0; s < 2; s++) {
        if (cmd_col[s] < 0) continue;
        int c = cmd_col[s], r = cmd_row[s];
        int enemy_touch = 0, friendly_touch = 0, open_touch = 0;
        for (int dc = -1; dc <= 1; dc++) for (int dr = -1; dr <= 1; dr++) {
            if (dc == 0 && dr == 0) continue;
            int nc = c + dc, nr = r + dr;
            if (!on_board(nc, nr)) continue;
            const Piece* occ = piece_at_c(pieces, nc, nr);
            if (!occ) open_touch++;
            else if (player_idx(occ->player) == s) friendly_touch++;
            else enemy_touch++;
        }
        cmd_exposure[s] = enemy_touch * 3 + open_touch - friendly_touch;
        if (commander_near_water_square(c, r)) cmd_exposure[s] += 2;
    }

    auto diff = [&](const int arr[2]) { return arr[pi] - arr[1 - pi]; };
    int d_sea = diff(sea_occ);
    int d_river = diff(river_occ);
    int d_sky = diff(sky_control);
    int d_exposure = diff(cmd_exposure);
    int d_stack = diff(cmd_stack_density);
    int d_navy = diff(navy_near_water_cmd);

    uint64_t mix = 0x9E3779B97F4A7C15ULL;
    auto fold = [&](int v) {
        uint64_t x = (uint64_t)(v + 512);
        mix ^= x + 0x9E3779B97F4A7C15ULL + (mix << 6) + (mix >> 2);
    };
    fold(d_sea);
    fold(d_river);
    fold(d_sky);
    fold(d_exposure);
    fold(d_stack);
    fold(d_navy);
    return (int)(mix & (CORR_TERR_SIZE - 1));
}

static void update_correction_history(uint64_t hash, const PieceList& pieces,
                                      const std::string& player, int depth,
                                      int search_val, int raw_static_eval) {
    // Don't correct near-mate scores — they're exact.
    if (std::abs(search_val) >= 20000 || std::abs(raw_static_eval) >= 20000) return;
    int pi = player_idx(player);
    if (pi < 0) return;

    int diff = search_val - raw_static_eval;
    diff = std::max(-2000, std::min(2000, diff));  // cap individual sample
    int scale = std::max(1, std::min(depth, 16));

    // Hash bucket update — exponential moving average.
    int hk = (int)((hash >> 4) & (CORR_HIST_SIZE - 1));
    {
        int& e = g_corr_hist[pi][hk];
        e = (e * (CORR_WEIGHT_DENOM - scale) + diff * scale * CORR_WEIGHT_DENOM)
            / CORR_WEIGHT_DENOM;
        e = std::max(-CORR_MAX_VAL, std::min(CORR_MAX_VAL, e));
    }

    // Material bucket update.
    int mk = material_corr_key(pieces, pi);
    {
        int& e = g_corr_hist_mat[pi][mk];
        e = (e * (CORR_WEIGHT_DENOM - scale) + diff * scale * CORR_WEIGHT_DENOM)
            / CORR_WEIGHT_DENOM;
        e = std::max(-CORR_MAX_VAL, std::min(CORR_MAX_VAL, e));
    }

    // Terrain/context bucket update.
    int tk = terrain_corr_key(pieces, pi);
    {
        int& e = g_corr_hist_terrain[pi][tk];
        e = (e * (CORR_WEIGHT_DENOM - scale) + diff * scale * CORR_WEIGHT_DENOM)
            / CORR_WEIGHT_DENOM;
        e = std::max(-CORR_MAX_VAL, std::min(CORR_MAX_VAL, e));
    }
}

// Returns the corrected static eval (raw + blended correction offset).
// The blend weight (0.50 hash + 0.30 material + 0.20 terrain/context) is
// intentionally conservative to stabilize pruning without distorting eval shape.
// enough to improve pruning without distorting the eval surface.
static int corrected_static_eval(uint64_t hash, const PieceList& pieces,
                                 const std::string& player, int raw_eval) {
    int pi = player_idx(player);
    if (pi < 0) return raw_eval;
    int hk = (int)((hash >> 4) & (CORR_HIST_SIZE - 1));
    int mk = material_corr_key(pieces, pi);
    int tk = terrain_corr_key(pieces, pi);
    int hash_corr = g_corr_hist[pi][hk] / CORR_WEIGHT_DENOM;
    int mat_corr  = g_corr_hist_mat[pi][mk] / CORR_WEIGHT_DENOM;
    int terr_corr = g_corr_hist_terrain[pi][tk] / CORR_WEIGHT_DENOM;
    // Blend: 50% hash, 30% material, 20% terrain/context.
    int correction = (hash_corr * 5 + mat_corr * 3 + terr_corr * 2) / 10;
    correction = std::max(-180, std::min(180, correction));  // safety clamp
    return raw_eval + correction;
}

// ── Static Exchange Evaluation (SEE) ─────────────────────────────────────
// Returns the material gain/loss of a capture sequence on (col,row).
// Positive = winning capture, negative = losing capture.
static int see(const PieceList& pieces, int col, int row,
               const std::string& attacker_player, int depth=0) {
    if (depth > 6) return 0;
    // Build context once for all pieces in this SEE node.
    MoveGenContext ctx = build_movegen_context(pieces);
    int target_sq = sq_index(col, row);
    // Find least-valuable attacker for attacker_player
    const Piece* best_atk = nullptr;
    int best_val = 999999;
    for (auto& p : pieces) {
        if (p.player != attacker_player) continue;
        BB132 attacks = get_move_mask_bitboard(p, ctx);
        if (attacks.test(target_sq)) {
            int v = std::max(1, piece_value_fast(p.kind));
            if (v < best_val) { best_val=v; best_atk=&p; }
        }
    }
    if (!best_atk) return 0;

    const Piece* target = piece_at_c(pieces, col, row);
    int gain = target ? piece_value_fast(target->kind) : 0;

    // SF18-style early exit: capturing with LVA and still ahead => prune
    if (depth >= 2 && gain - best_val > 0) return gain - best_val;

    PieceList np = apply_move_unchecked(pieces, best_atk->id, col, row, attacker_player);
    return gain - see(np, col, row, opp(attacker_player), depth+1);
}

// ── Move ordering ──────────────────────────────────────────────────────────
static AllMoves order_moves(const AllMoves& moves, const PieceList& pieces,
                             const std::string& player, int ply,
                             const MoveTriple* hash_move,
                             const MoveTriple* pv_move = nullptr,
                             const MoveTriple* prev_move = nullptr,
                             ThreadData* td = nullptr) {
    std::vector<std::pair<int,MoveTriple>> scored;
    scored.reserve(moves.size());
    const MoveTriple* counter_move = nullptr;
    if (prev_move && on_board(prev_move->dc, prev_move->dr)) {
        bool cs = td ? td->counter_set[prev_move->dc][prev_move->dr]
                      : g_counter_set[prev_move->dc][prev_move->dr];
        if (cs) counter_move = td ? &td->counter[prev_move->dc][prev_move->dr]
                                   : &g_counter[prev_move->dc][prev_move->dr];
    }
    int hist_pl = player_idx(player);
    if (hist_pl < 0) hist_pl = 0;
    for (auto& m : moves) {
        const Piece* piece = nullptr;
        for (auto& p : pieces) if (p.id==m.pid) { piece=&p; break; }
        if (!piece) continue;
        const Piece* target = piece_at_c(pieces, m.dc, m.dr);

        int score = 0;
        // 1. Hash move — search first always
        if (hash_move && same_move(*hash_move, m)) {
            score = 3000000;
        }
        // 1b. PV move from previous iteration
        else if (pv_move && same_move(*pv_move, m)) {
            score = 2500000;
        }
        // 2. Captures — scored by SEE (winning captures first, losing last)
        else if (target && target->player != player) {
            int victim_val = piece_value_fast(target->kind);
            int attacker_val = std::max(1, piece_value_fast(piece->kind));
            int mvv_lva = victim_val * 16 - attacker_val;
            int see_val = see(pieces, m.dc, m.dr, player);
            if (see_val >= 0)
                score = 1100000 + mvv_lva * 4 + see_val;   // winning / equal capture
            else
                score = 520000  + mvv_lva * 2 + see_val;   // losing capture (still above quiets)
        }
        // 2b. Counter move for previous move context
        else if (counter_move && same_move(*counter_move, m))
            score = 95000;
        // 3. Killer moves
        else if (ply<MAX_PLY && (td ? td->killers_set[ply][0] : g_killers_set[ply][0]) &&
                   (td ? td->killers[ply][0] : g_killers[ply][0]).pid==m.pid &&
                   (td ? td->killers[ply][0] : g_killers[ply][0]).dc==m.dc &&
                   (td ? td->killers[ply][0] : g_killers[ply][0]).dr==m.dr)
            score = 90000;
        else if (ply<MAX_PLY && (td ? td->killers_set[ply][1] : g_killers_set[ply][1]) &&
                   (td ? td->killers[ply][1] : g_killers[ply][1]).pid==m.pid &&
                   (td ? td->killers[ply][1] : g_killers[ply][1]).dc==m.dc &&
                   (td ? td->killers[ply][1] : g_killers[ply][1]).dr==m.dr)
            score = 89000;
        // 4. History heuristic for quiet moves
        else {
            int ki = kind_index(piece->kind);
            score = td ? td_history_score(*td, hist_pl, ki, m.dc, m.dr)
                       : history_score(hist_pl, ki, m.dc, m.dr);
            score += td ? td_cont_history_score(*td, prev_move, ki, m.dc, m.dr)
                        : cont_history_score(prev_move, ki, m.dc, m.dr);
        }

        scored.push_back({score, m});
    }
    std::sort(scored.begin(), scored.end(), [](auto& a, auto& b){ return a.first > b.first; });
    AllMoves result;
    result.reserve(scored.size());
    for (auto& s : scored) result.push_back(s.second);
    return result;
}

static int attackers_to_square(const PieceList& pieces, int col, int row,
                               const std::string& attacker_player,
                               const AttackCache* cache = nullptr) {
    if (cache && cache->valid) {
        int pl = attacker_player=="red" ? 0 : 1;
        return cache->counts[pl][row][col];
    }
    const int target_sq = sq_index(col, row);
    MoveGenContext ctx = build_movegen_context(pieces);
    int attackers = 0;
    for (auto& p : pieces) {
        if (p.player != attacker_player) continue;
        BB132 attacks = get_move_mask_bitboard(p, ctx);
        if (attacks.test(target_sq)) attackers++;
    }
    return attackers;
}

static int count_kind_for(const PieceList& pieces, const std::string& player, const std::string& kind) {
    int n = 0;
    for (auto& p : pieces) if (p.player==player && p.kind==kind) n++;
    return n;
}

static bool side_has_only_pawn_militia_material(const PieceList& pieces, const std::string& player) {
    bool has_non_commander = false;
    for (const auto& p : pieces) {
        if (p.player != player) continue;
        if (p.kind == "C" || p.kind == "H") continue;
        has_non_commander = true;
        if (p.kind != "In" && p.kind != "M") return false;
    }
    return has_non_commander;
}

static int commander_attackers_cached(SearchState& st, const std::string& player) {
    int pi = (player == "red") ? 0 : 1;
    int cc = st.cmd_col[pi], cr = st.cmd_row[pi];
    if (cc < 0) return 0;
    ensure_attack_cache(st);
    return attackers_to_square(st.pieces, cc, cr, opp(player), &st.atk);
}

struct ObjectiveCounts {
    int commander = 0;
    int navy = 0;
    int air_force = 0;
    int tank = 0;
    int infantry = 0;
    int artillery = 0;
    int active_non_hq = 0;
    int carried_units = 0;
};

static ObjectiveCounts collect_objective_counts(const PieceList& pieces, const std::string& side) {
    ObjectiveCounts out;
    for (const auto& p : pieces) {
        if (p.player != side || !on_board(p.col, p.row)) continue;
        if (p.kind != "H") out.active_non_hq++;
        if (p.carrier_id >= 0) out.carried_units++;
        if (p.kind == "C") out.commander++;
        else if (p.kind == "N") out.navy++;
        else if (p.kind == "Af") out.air_force++;
        else if (p.kind == "T") out.tank++;
        else if (p.kind == "In") out.infantry++;
        else if (p.kind == "A") out.artillery++;
    }
    return out;
}

static bool side_fulfills_win_objective(const ObjectiveCounts& self,
                                        const ObjectiveCounts& enemy) {
    (void)self;
    switch (g_game_mode) {
    case GameMode::MARINE_BATTLE:
        return enemy.commander == 0 || enemy.navy == 0;
    case GameMode::AIR_BATTLE:
        return enemy.commander == 0 || enemy.air_force == 0;
    case GameMode::LAND_BATTLE:
        return enemy.commander == 0 ||
               (enemy.tank == 0 && enemy.infantry == 0 && enemy.artillery == 0);
    case GameMode::FULL_BATTLE:
    default:
        return enemy.commander == 0;
    }
}

// === NEW: Low-Depth Fortress & Special Draw Recognizer (~+30 Elo) ===
// Triggered only at depth <= 3 (AB) and q_depth <= 3 (QSearch).
// Handles:
//  • objective-complete decisive states (variant-specific)
//  • practical fortress/no-progress draws
//  • carrier-stacking loop-like dead-draw signatures
static bool low_depth_special_outcome(SearchState& st, const std::string& perspective,
                                      int depth_hint, int* out_score) {
    if (!out_score || depth_hint > 3) return false;

    const std::string enemy = opp(perspective);
    ObjectiveCounts me = collect_objective_counts(st.pieces, perspective);
    ObjectiveCounts them = collect_objective_counts(st.pieces, enemy);

    // Objective-based decisive recognizer (independent of "last mover").
    bool me_wins = side_fulfills_win_objective(me, them);
    bool them_wins = side_fulfills_win_objective(them, me);
    if (me_wins || them_wins) {
        if (me_wins && them_wins) {
            *out_score = 0;
            return true;
        }
        int base = 36000 + std::max(0, std::min(depth_hint, 6)) * 80;
        *out_score = me_wins ? base : -base;
        return true;
    }

    if (depth_hint <= 0) return false;
    if (me.commander == 0 || them.commander == 0) return false;

    ensure_attack_cache(st);
    int my_pi = player_idx(perspective);
    int op_pi = 1 - my_pi;
    int my_cc = st.cmd_col[my_pi], my_cr = st.cmd_row[my_pi];
    int op_cc = st.cmd_col[op_pi], op_cr = st.cmd_row[op_pi];
    if (my_cc < 0 || op_cc < 0) return false;

    // Fortress recognizer requires both commanders to be currently safe.
    if (st.atk.counts[op_pi][my_cr][my_cc] > 0) return false;
    if (st.atk.counts[my_pi][op_cr][op_cc] > 0) return false;

    const int total_active = me.active_non_hq + them.active_non_hq;
    if (total_active > 12) return false;

    AllMoves my_moves = all_moves_for(st.pieces, perspective);
    AllMoves op_moves = all_moves_for(st.pieces, enemy);
    if (my_moves.empty() || op_moves.empty()) return false;

    auto classify_activity = [&](const std::string& side,
                                 const AllMoves& moves,
                                 const Piece* enemy_cmd,
                                 int* captures,
                                 int* progress) {
        *captures = 0;
        *progress = 0;
        int inspected = 0;
        for (const auto& m : moves) {
            if (++inspected > 96) break; // cap for browser/runtime safety
            const Piece* tgt = piece_at_c(st.pieces, m.dc, m.dr);
            if (tgt && tgt->player != side) { (*captures)++; continue; }

            int idx = find_piece_idx_by_id(st.pieces, m.pid);
            if (idx < 0 || !enemy_cmd) continue;
            const Piece& p = st.pieces[idx];
            if (p.kind == "C" || p.kind == "H") continue;
            int before = std::abs(p.col - enemy_cmd->col) + std::abs(p.row - enemy_cmd->row);
            int after = std::abs(m.dc - enemy_cmd->col) + std::abs(m.dr - enemy_cmd->row);
            if (after + 1 < before) (*progress)++;
        }
    };

    const Piece* my_enemy_cmd = nullptr;
    const Piece* op_enemy_cmd = nullptr;
    for (const auto& p : st.pieces) {
        if (p.player == enemy && p.kind == "C") my_enemy_cmd = &p;
        if (p.player == perspective && p.kind == "C") op_enemy_cmd = &p;
    }

    int my_caps = 0, my_progress = 0;
    int op_caps = 0, op_progress = 0;
    classify_activity(perspective, my_moves, my_enemy_cmd, &my_caps, &my_progress);
    classify_activity(enemy, op_moves, op_enemy_cmd, &op_caps, &op_progress);

    bool no_captures = (my_caps == 0 && op_caps == 0);
    bool low_mobility = ((int)my_moves.size() <= 18 && (int)op_moves.size() <= 18);
    bool no_progress = (my_progress <= 1 && op_progress <= 1);
    bool carrier_loop_signature = (me.carried_units + them.carried_units >= 4);

    if (no_captures && low_mobility && (no_progress || carrier_loop_signature)) {
        if (!has_immediate_winning_move(st.pieces, perspective) &&
            !has_immediate_winning_move(st.pieces, enemy)) {
            *out_score = 0;
            return true;
        }
    }

    return false;
}

// ── Static evaluation (Phase-Interpolated) ────────────────────────────────
// Quadratic attacker penalty table: more attackers = exponentially worse
static const int CMD_ATTACKER_PENALTY[] = {0, 40, 120, 260, 450, 700, 1000};

enum class EvalBackendKind { CPU, WEBGPU };
static EvalBackendKind g_eval_backend = EvalBackendKind::CPU;
static std::atomic<bool> g_eval_webgpu_notice{false};

static const char* eval_backend_name(EvalBackendKind backend) {
    return backend == EvalBackendKind::WEBGPU ? "webgpu" : "cpu";
}

static bool eval_backend_webgpu_compiled() {
#if COMMANDER_HAS_WEBGPU_HEADER
    return true;
#else
    return false;
#endif
}

static std::string lower_ascii(std::string s) {
    for (char& ch : s)
        ch = (char)std::tolower((unsigned char)ch);
    return s;
}

static bool configure_eval_backend(const std::string& mode_raw, std::string* note = nullptr) {
    if (note) note->clear();
    std::string mode = lower_ascii(mode_raw);
    if (mode == "cpu") {
        g_eval_backend = EvalBackendKind::CPU;
        return true;
    }
    if (mode == "webgpu") {
        if (eval_backend_webgpu_compiled()) {
            g_eval_backend = EvalBackendKind::WEBGPU;
        } else {
            g_eval_backend = EvalBackendKind::CPU;
            if (note) *note = "WebGPU backend requested but build has no WebGPU/Dawn headers; using CPU evaluator.";
        }
        return true;
    }
    if (mode == "auto") {
        g_eval_backend = eval_backend_webgpu_compiled()
                         ? EvalBackendKind::WEBGPU
                         : EvalBackendKind::CPU;
        return true;
    }
    return false;
}

static EvalBackendKind active_eval_backend() {
    return g_eval_backend;
}

static bool is_win_condition_piece_kind(const std::string& kind) {
    return kind == "N" || kind == "Af" || kind == "T" || kind == "In" || kind == "A";
}

// === NEW: Advanced Threat Evaluation (~+80 Elo) ===
// Fast classical threat model:
//  • hanging/undefended pressure (scaled by unit value + carrier payload)
//  • cross-domain threats (Af/Navy/Artillery/Missile pressure)
//  • commander pressure and win-condition target pressure
//  • potential discovered attacks from loaded carriers (unload threats)
static int side_advanced_threat_score(const PieceList& pieces,
                                      const std::string& side,
                                      const AttackCache* cache,
                                      const MoveGenContext& ctx) {
    const std::string enemy = opp(side);
    const int side_pi = player_idx(side);
    const int enemy_pi = 1 - side_pi;
    int score = 0;

    const Piece* enemy_cmd = nullptr;
    for (const auto& p : pieces) {
        if (p.player == enemy && p.kind == "C") { enemy_cmd = &p; break; }
    }

    std::array<int, PieceList::kMaxPieces> payload_count{};
    for (const auto& p : pieces) {
        if (p.carrier_id >= 0 && p.carrier_id < (int)payload_count.size()) payload_count[p.carrier_id]++;
    }

    if (enemy_cmd) {
        int direct = cache ? cache->counts[side_pi][enemy_cmd->row][enemy_cmd->col]
                           : attackers_to_square(pieces, enemy_cmd->col, enemy_cmd->row, side, cache);
        int defenders = cache ? cache->counts[enemy_pi][enemy_cmd->row][enemy_cmd->col]
                              : attackers_to_square(pieces, enemy_cmd->col, enemy_cmd->row, enemy, cache);
        score += direct * 120;
        score += std::max(0, direct - defenders) * 170;
    }

    // Undefended / overloaded enemy pieces (higher value for carriers + objective units).
    for (const auto& ep : pieces) {
        if (ep.player != enemy || ep.kind == "H") continue;
        int atk = cache ? cache->counts[side_pi][ep.row][ep.col]
                        : attackers_to_square(pieces, ep.col, ep.row, side, cache);
        if (atk == 0) continue;
        int def = cache ? cache->counts[enemy_pi][ep.row][ep.col]
                        : attackers_to_square(pieces, ep.col, ep.row, enemy, cache);
        int val = piece_value_fast(ep.kind);
        int weight = val / 9;
        if (ep.kind == "C") weight += 260;
        if (ep.kind == "N" || ep.kind == "Af") weight += 140;
        if (is_win_condition_piece_kind(ep.kind)) weight += 80;
        if (ep.id >= 0 && ep.id < (int)payload_count.size() && payload_count[ep.id] > 0) {
            weight += 60 * payload_count[ep.id];
        }
        if (def == 0) score += weight + val / 4;
        else if (atk > def) score += weight / 2 + (atk - def) * 24;
        else if (atk == def && val >= 200) score += weight / 4;
    }

    // Cross-domain attack pressure + potential discovered attacks after unloading carriers.
    for (const auto& p : pieces) {
        if (p.player != side || p.kind == "H") continue;

        int payload = (p.id >= 0 && p.id < (int)payload_count.size()) ? payload_count[p.id] : 0;
        if (payload > 0 && enemy_cmd) {
            int cmd_dist = std::abs(p.col - enemy_cmd->col) + std::abs(p.row - enemy_cmd->row);
            if (cmd_dist <= 6) score += payload * std::max(0, 90 - cmd_dist * 12);
        }

        auto mvs = get_moves_with_ctx(p, ctx);
        for (const auto& mv : mvs) {
            const Piece* tgt = piece_at_c(pieces, mv.first, mv.second);
            if (!tgt || tgt->player == side) continue;

            int bonus = 0;
            if (p.kind == "Af") {
                if (tgt->kind != "Af") bonus += 36;
                if (is_sea(tgt->col, tgt->row) || tgt->kind == "N") bonus += 30;
            } else if (p.kind == "N") {
                if (is_sea(tgt->col, tgt->row) || tgt->kind == "N" || tgt->kind == "Af") bonus += 34;
            } else if (p.kind == "A" || p.kind == "Ms") {
                int dist = std::max(std::abs(p.col - tgt->col), std::abs(p.row - tgt->row));
                if (dist >= 2) bonus += 30 + dist * 4;
            }

            if (tgt->kind == "C") bonus += 160;
            if (is_win_condition_piece_kind(tgt->kind)) bonus += 48;
            score += bonus;
        }
    }

    // Loaded passengers near enemy commander indicate likely discovered-attack motifs.
    if (enemy_cmd) {
        for (const auto& p : pieces) {
            if (p.player != side || p.carrier_id < 0) continue;
            const Piece* carrier = piece_by_id_c(pieces, p.carrier_id);
            if (!carrier || carrier->player != side) continue;
            int dist = std::abs(carrier->col - enemy_cmd->col) + std::abs(carrier->row - enemy_cmd->row);
            if (dist > 7) continue;
            int payload_threat = piece_value_fast(p.kind) / 10;
            if (p.kind == "T" || p.kind == "A" || p.kind == "Ms" || p.kind == "Af" || p.kind == "C")
                payload_threat += 45;
            score += std::max(0, payload_threat + 70 - dist * 10);
        }
    }

    return score;
}

static int advanced_threat_eval(const PieceList& pieces, const std::string& perspective,
                                const AttackCache* cache = nullptr) {
    MoveGenContext ctx = build_movegen_context(pieces);
    int my_threats = side_advanced_threat_score(pieces, perspective, cache, ctx);
    int opp_threats = side_advanced_threat_score(pieces, opp(perspective), cache, ctx);
    return my_threats - opp_threats;
}

static int board_score_cpu_impl(const PieceList& pieces, const std::string& perspective,
                                const AttackCache* cache = nullptr,
                                const std::string* side_to_move = nullptr) {
    // ── Game Phase ───────────────────────────────────────────────────────
    int phase = compute_game_phase(pieces);

    // ── Constants (some phase-interpolated) ──────────────────────────────
    int THREAT_BONUS       = 350;     // was 260: stronger incentive to threaten commander
    int SPACE_ADV_WEIGHT   = (phase > 128) ? 4 : 6;  // was 2/4: push forward more
    int SPACE_CENTER_BONUS = (phase > 128) ? 12 : 18; // was 10/16
    int CMD_ATTACK_WEIGHT  = (phase > 128) ? 150 : 110; // was 90/70: much stronger attack reward
    int TEMPO_BONUS        = 20;       // was 18
    int CONTEMPT_BONUS     = 35;       // was 12: strongly prefer playing on over draws

    int score = 0;

    // ── Piece counts for strategic assessment ────────────────────────────
    int my_navy = 0, opp_navy = 0;
    int my_af = 0, opp_af = 0;
    int my_land = 0, opp_land = 0;
    int my_aa = 0, opp_aa = 0;
    int my_tank = 0, opp_tank = 0;
    int my_ms = 0, opp_ms = 0;
    int my_piece_count = 0, opp_piece_count = 0;

    const Piece* my_cmd  = nullptr;
    const Piece* opp_cmd = nullptr;

    for (auto& p : pieces) {
        bool mine = (p.player == perspective);
        if (p.kind=="C") { if (mine) my_cmd = &p; else opp_cmd = &p; continue; }
        if (p.kind=="H") continue;
        if (mine) my_piece_count++; else opp_piece_count++;
        if (p.kind=="N")  { if (mine) my_navy++; else opp_navy++; }
        if (p.kind=="Af") { if (mine) my_af++;   else opp_af++; }
        if (p.kind=="Aa") { if (mine) my_aa++;   else opp_aa++; }
        if (p.kind=="T")  { if (mine) my_tank++; else opp_tank++; }
        if (p.kind=="Ms") { if (mine) my_ms++;   else opp_ms++; }
        if (p.kind=="A" || p.kind=="T" || p.kind=="In") {
            if (mine) my_land++; else opp_land++;
        }
    }

    // ── Per-piece evaluation ─────────────────────────────────────────────
    for (auto& p : pieces) {
        if (p.kind == "H") continue; // HQ has no eval contribution
        bool mine = (p.player == perspective);
        int sign = mine ? 1 : -1;

        // Material
        int mat = piece_value_fast(p.kind);
        if (p.hero) mat = (mat * 3) / 2;  // heroes are 50% more valuable

        // Phase-interpolated PST
        int pst = get_pst_phased(p.kind, p.player, p.col, p.row, phase);

        // Threat bonus: piece can capture enemy Commander
        int threat = 0;
        if (p.kind != "H" && p.kind != "C" && !p.hero) {
            const Piece* oc = mine ? opp_cmd : my_cmd;
            if (oc && cache) {
                // Use attack cache: check if this side attacks the enemy commander's square
                int my_pl_idx = (p.player == "red") ? 0 : 1;
                if (cache->counts[my_pl_idx][oc->row][oc->col] > 0) {
                    threat = THREAT_BONUS;
                }
            } else if (oc) {
                auto mvs = get_moves(p, pieces);
                for (auto& m : mvs) {
                    if (m.first==oc->col && m.second==oc->row) {
                        threat = THREAT_BONUS; break;
                    }
                }
            }
        }

        // Hero proximity to enemy Commander
        int hero_bonus = 0;
        if (p.hero) {
            const Piece* ec = mine ? opp_cmd : my_cmd;
            if (ec) {
                int dist = std::abs(p.col - ec->col) + std::abs(p.row - ec->row);
                hero_bonus = std::max(0, 160 - dist * 18);
            }
        }

        // Space advance bonus (bigger in endgame)
        int space = 0;
        if (p.kind != "C" && p.kind != "H" && p.kind != "N") {
            int advance = (p.player=="red") ? p.row : (11 - p.row);
            space += advance * SPACE_ADV_WEIGHT;
            if (p.col >= 3 && p.col <= 7 && p.row >= 4 && p.row <= 7)
                space += SPACE_CENTER_BONUS;
        }

        // Hanging piece penalty: attacked but not defended
        int hanging = 0;
        if (cache && p.kind != "C") {
            int opp_pl = (p.player=="red") ? 1 : 0;
            int own_pl = 1 - opp_pl;
            int atk = cache->counts[opp_pl][p.row][p.col];
            int def = cache->counts[own_pl][p.row][p.col];
            if (atk > 0 && def == 0) {
                // Undefended and attacked: strong penalty proportional to piece value
                hanging = -(mat * 2 / 3);
            } else if (atk > def && mat > 200) {
                // Overloaded: penalty if attacked more than defended
                hanging = -(mat / 4);
            }
        }

        // Piece-type specific bonuses
        int special = 0;

        // Navy safety
        if (p.kind == "N") {
            int atk_n = attackers_to_square(pieces, p.col, p.row, opp(p.player), cache);
            int def_n = attackers_to_square(pieces, p.col, p.row, p.player, cache);
            special -= atk_n * 180;
            special += def_n * 70;
            if (atk_n > def_n) special -= (atk_n - def_n) * 140;
            if (is_sea(p.col, p.row)) special += 25;
        }

        // Air Force safety + Aa interaction
        if (p.kind == "Af") {
            int atk_f = attackers_to_square(pieces, p.col, p.row, opp(p.player), cache);
            int def_f = attackers_to_square(pieces, p.col, p.row, p.player, cache);
            special -= atk_f * 180;
            special += def_f * 65;
            if (atk_f > def_f) special -= (atk_f - def_f) * 300;
        }

        // Anti-air: bonus for covering friendly Af
        if (p.kind == "Aa") {
            for (auto& q : pieces) {
                if (q.player != p.player || q.kind != "Af") continue;
                int dist = std::abs(q.col - p.col) + std::abs(q.row - p.row);
                if (dist <= 3) special += 15;
                if (dist <= 1) special += 10;
            }
        }

        // Missile: bonus for being in range of high-value enemy targets
        if (p.kind == "Ms") {
            const Piece* ec = mine ? opp_cmd : my_cmd;
            if (ec) {
                int dist = std::abs(p.col - ec->col) + std::abs(p.row - ec->row);
                if (dist <= 4) special += 35;
                if (dist <= 2) special += 25;
            }
        }

        int total = mat + pst * 2 + threat + hero_bonus + space + hanging + special;
        score += sign * total;
    }

    // === NEW: Advanced Threat Evaluation (~+80 Elo) ===
    // Uses attack-cache counts + single movegen context to keep the model fast.
    score += advanced_threat_eval(pieces, perspective, cache);

    // ── Commander Safety (phase-scaled) ──────────────────────────────────
    if (my_cmd) {
        int attackers = attackers_to_square(pieces, my_cmd->col, my_cmd->row, opp(perspective), cache);
        int n = std::min(attackers, 6);
        int cmd_penalty = CMD_ATTACKER_PENALTY[n];
        // Phase scale: safety matters much more in midgame
        cmd_penalty = (cmd_penalty * (128 + phase)) / 256;
        score -= cmd_penalty;

        // Shelter bonus: friendly pieces adjacent to our Commander
        int shelter = 0;
        for (int dc = -1; dc <= 1; dc++) for (int dr = -1; dr <= 1; dr++) {
            if (dc == 0 && dr == 0) continue;
            int c = my_cmd->col + dc, r = my_cmd->row + dr;
            if (!on_board(c, r)) continue;
            const Piece* occ = piece_at_c(pieces, c, r);
            if (occ && occ->player == perspective) shelter += 12;
        }
        score += (shelter * phase) / 256; // shelter matters more in midgame

        // Commander virtual mobility: count escape squares
        int escapes = 0;
        auto cmd_moves = get_moves(*my_cmd, pieces);
        for (auto& m : cmd_moves) {
            int opp_pl = (perspective == "red") ? 1 : 0;
            if (!cache || cache->counts[opp_pl][m.second][m.first] == 0) escapes++;
        }
        if (escapes <= 1) score -= 80;
        if (escapes == 0) score -= 150;
    }

    // ── Attack pressure on enemy Commander ───────────────────────────────
    if (opp_cmd) {
        int direct = attackers_to_square(pieces, opp_cmd->col, opp_cmd->row, perspective, cache);
        int defenders = attackers_to_square(pieces, opp_cmd->col, opp_cmd->row, opp(perspective), cache);
        score += direct * CMD_ATTACK_WEIGHT;
        score -= defenders * 18;

        // Ring control: attack squares around enemy Commander
        int ring_att = 0, ring_def = 0, ring_escape = 0;
        for (int dc = -1; dc <= 1; dc++) for (int dr = -1; dr <= 1; dr++) {
            if (dc == 0 && dr == 0) continue;
            int c = opp_cmd->col + dc, r = opp_cmd->row + dr;
            if (!on_board(c, r)) continue;
            ring_att += attackers_to_square(pieces, c, r, perspective, cache);
            ring_def += attackers_to_square(pieces, c, r, opp(perspective), cache);
            const Piece* occ = piece_at_c(pieces, c, r);
            if (!occ || occ->player != opp(perspective)) ring_escape++;
        }
        score += (ring_att - ring_def) * 18;  // was 12: stronger ring control incentive
        score -= ring_escape * 12; // was 8: more reward for trapping enemy commander
    }

    // ── Approximate mobility from attack cache ──────────────────────────
    // Much faster than generating all legal moves (the old method).
    if (cache) {
        int my_pl  = (perspective == "red") ? 0 : 1;
        int opp_pl = 1 - my_pl;
        int my_squares = cache->attacked_square_count[my_pl];
        int opp_squares = cache->attacked_square_count[opp_pl];
        int mob_weight = (phase > 128) ? 3 : 5; // mobility matters more in endgame
        score += (my_squares - opp_squares) * mob_weight;
    }

    // ── Piece pair bonuses ───────────────────────────────────────────────
    // Having both of a pair provides synergy
    if (my_navy == 2)  score += 100;
    if (opp_navy == 2) score -= 100;
    if (my_af == 2)    score += 80;
    if (opp_af == 2)   score -= 80;
    if (my_tank == 2)  score += 50;
    if (opp_tank == 2) score -= 50;

    // ── Structural bonuses ───────────────────────────────────────────────
    for (auto& p : pieces) {
        int bonus = 0;
        if      (p.kind == "Aa") bonus = 14;
        else if (p.kind == "Ms") bonus = 18;
        else if (p.kind == "N")  bonus = 10;
        score += (p.player == perspective ? 1 : -1) * bonus;
    }

    // ── Strategic objective pressure (navy — smoothed lookup table) ─────
    // Navy count → strategic value: {0: -2000, 1: +600, 2: +2500}
    // This avoids the huge non-linear jump between 1 and 2 navies.
    static const int NAVY_STRAT[] = {-2000, 600, 2500};
    score += NAVY_STRAT[std::min(my_navy, 2)] - NAVY_STRAT[std::min(opp_navy, 2)];

    score += (my_af - opp_af) * 700;
    if (my_af == 1)  score -= 450;
    if (opp_af == 1) score += 450;
    if (my_af == 0)  score -= 1200;
    if (opp_af == 0) score += 1200;

    score += (my_land - opp_land) * 220;
    if (my_land <= 2)  score -= 350;
    if (opp_land <= 2) score += 350;

    // ── Tempo & contempt ─────────────────────────────────────────────────
    if (side_to_move)
        score += (*side_to_move == perspective) ? TEMPO_BONUS : -TEMPO_BONUS;

    // Material advantage conversion: when ahead, fewer opponent pieces = better.
    // This encourages trading when ahead (amplifies advantage).
    int mat_diff = my_piece_count - opp_piece_count;
    if (mat_diff > 0) {
        // Reward: bonus scales with our advantage AND how few pieces opponent has
        int trade_bonus = mat_diff * (20 - opp_piece_count) * 3;
        if (trade_bonus > 0) score += trade_bonus;
    } else if (mat_diff < 0) {
        int trade_bonus = (-mat_diff) * (20 - my_piece_count) * 3;
        if (trade_bonus > 0) score -= trade_bonus;
    }

    // Contempt: always prefer playing on rather than accepting a draw.
    // Applied unconditionally (not just in close positions) to fight draw epidemic.
    score += CONTEMPT_BONUS;

    return score;
}

struct EvalBatchRequest {
    const PieceList* pieces;
    const std::string* perspective;
    const AttackCache* cache;
    const std::string* side_to_move;
};

static std::vector<int> board_score_batch_cpu_impl(const std::vector<EvalBatchRequest>& batch) {
    std::vector<int> out;
    out.reserve(batch.size());
    for (const auto& req : batch) {
        if (!req.pieces || !req.perspective) {
            out.push_back(0);
            continue;
        }
        out.push_back(board_score_cpu_impl(*req.pieces, *req.perspective, req.cache, req.side_to_move));
    }
    return out;
}

static std::vector<int> board_score_batch_webgpu_impl(const std::vector<EvalBatchRequest>& batch) {
    // Placeholder for true GPU batched eval: keep API stable and route to CPU now.
    bool expected = false;
    if (g_eval_webgpu_notice.compare_exchange_strong(expected, true, std::memory_order_relaxed)) {
        std::cerr << "[eval] webgpu backend selected; batched evaluator path enabled, CPU fallback active.\n";
    }
    return board_score_batch_cpu_impl(batch);
}

static std::vector<int> board_score_batch(const std::vector<EvalBatchRequest>& batch) {
    if (active_eval_backend() == EvalBackendKind::WEBGPU)
        return board_score_batch_webgpu_impl(batch);
    return board_score_batch_cpu_impl(batch);
}

static int board_score_webgpu_impl(const PieceList& pieces, const std::string& perspective,
                                   const AttackCache* cache = nullptr,
                                   const std::string* side_to_move = nullptr) {
    EvalBatchRequest req{&pieces, &perspective, cache, side_to_move};
    auto out = board_score_batch_webgpu_impl({req});
    return out.empty() ? 0 : out[0];
}

static int board_score(const PieceList& pieces, const std::string& perspective,
                       const AttackCache* cache = nullptr,
                       const std::string* side_to_move = nullptr) {
    if (active_eval_backend() == EvalBackendKind::WEBGPU)
        return board_score_webgpu_impl(pieces, perspective, cache, side_to_move);
    return board_score_cpu_impl(pieces, perspective, cache, side_to_move);
}

// ── Quiescence ────────────────────────────────────────────────────────────
static std::atomic<uint64_t> g_nodes{0};  // global node counter for NPS / time mgmt
static const int Q_LIMIT   = 6;   // raised from 4 for deeper tactical vision
static const int DELTA_MARGIN = 200; // delta pruning margin

static int quiesce(SearchState& st, int alpha, int beta,
                   const std::string& perspective, const std::string& cpu_player,
                   int q_depth=0) {
    g_nodes.fetch_add(1, std::memory_order_relaxed);
    int stand = (perspective == cpu_player) ? st.quick_eval : -st.quick_eval;
    if (q_depth == 0) {
        ensure_attack_cache(st);
        int precise = board_score(st.pieces, perspective, &st.atk, &perspective);
        stand = (stand * 2 + precise) / 3;
    }

    if (q_depth <= 3) {
        int special_score = 0;
        if (low_depth_special_outcome(st, perspective, 3 - q_depth, &special_score))
            return special_score;
    }

    // ── Commander in check detection (SF18 style) ─────────────────────────
    // When the side-to-move's commander is currently attacked, we cannot
    // apply the stand-pat cut-off or delta pruning — every move must be
    // tried (including quiet evasions) to avoid the horizon effect.
    bool in_check = false;
    {
        const Piece* my_cmd = nullptr;
        for (const auto& p : st.pieces) {
            if (p.player == perspective && p.kind == "C") { my_cmd = &p; break; }
        }
        if (my_cmd) {
            ensure_attack_cache(st);
            int pl_atk = (perspective == "red") ? 1 : 0;
            in_check = (st.atk.counts[pl_atk][my_cmd->row][my_cmd->col] > 0);
        }
    }

    if (!in_check) {
        if (stand >= beta) return beta;
        // Delta pruning: skip positions where even the best capture can't improve alpha
        if (stand < alpha - DELTA_MARGIN - 800) return alpha;
        if (alpha < stand) alpha = stand;
    }
    if (q_depth >= Q_LIMIT) return in_check ? stand : alpha;

    // Order captures by SEE score before iterating (stack-allocated, no heap)
    struct CapMove { int pid, dc, dr, see_val; bool is_quiet; };
    CapMove caps[128];  // enough for captures + commander evasions
    int ncaps = 0;
    for (auto& p : st.pieces) {
        if (p.player != perspective) continue;
        auto mvs = get_moves(p, st.pieces);
        for (auto& m : mvs) {
            const Piece* t = piece_at_c(st.pieces, m.first, m.second);
            bool is_cap = (t && t->player != perspective);
            // In check: also include quiet commander moves as evasions
            bool is_evasion = (in_check && p.kind == "C" && !is_cap);
            if (!is_cap && !is_evasion) continue;
            int sv = is_cap ? see(st.pieces, m.first, m.second, perspective) : 0;
            if (ncaps < 128) caps[ncaps++] = {p.id, m.first, m.second, sv, !is_cap};
        }
    }
    // Insertion sort (fast for small N, no allocations): captures first by SEE, then evasions
    for (int i = 1; i < ncaps; i++) {
        CapMove key = caps[i];
        int j = i - 1;
        // Sort: non-quiet (captures) ranked by SEE descending; quiet evasions last
        auto rank = [](const CapMove& c) { return c.is_quiet ? -100000 : c.see_val; };
        while (j >= 0 && rank(caps[j]) < rank(key)) {
            caps[j+1] = caps[j];
            j--;
        }
        caps[j+1] = key;
    }

    for (int ci = 0; ci < ncaps; ci++) {
        auto& c = caps[ci];
        // For quiet evasions (in-check only): no SEE or delta pruning
        if (!c.is_quiet) {
            // SEE pruning: skip clearly losing captures in quiescence
            if (c.see_val < 0 && q_depth >= 1) continue;
            // Delta pruning: skip captures that can't raise alpha even optimistically
            if (!in_check && c.see_val + stand + DELTA_MARGIN < alpha) continue;
        }
        UndoMove u;
        if (!make_move_inplace(st, {c.pid, c.dc, c.dr}, cpu_player, u)) continue;
        int s = -quiesce(st, -beta, -alpha, opp(perspective), cpu_player, q_depth+1);
        unmake_move_inplace(st, u);
        if (s >= beta) return beta;
        if (s > alpha) alpha = s;
    }
    return alpha;
}

// ── LMR Reduction Table (logarithmic) ────────────────────────────────────
static int g_lmr_table[64][64];
static bool g_lmr_init = false;

static void init_lmr_table() {
    if (g_lmr_init) return;
    // Stockfish 18 LMR formula: reduction ≈ ln(depth) * ln(moves) / 2.0
    // (slightly more aggressive than the old /2.25; improves search speed
    //  at depth ≥ 6 where later moves are almost always sub-optimal)
    for (int d = 0; d < 64; d++) {
        for (int m = 0; m < 64; m++) {
            if (d == 0 || m == 0) { g_lmr_table[d][m] = 0; continue; }
            g_lmr_table[d][m] = (int)(0.50 + std::log(d) * std::log(m) / 2.0);
            if (g_lmr_table[d][m] < 0) g_lmr_table[d][m] = 0;
        }
    }
    g_lmr_init = true;
}

static int lmr_reduction(int depth, int move_index) {
    int d = std::min(depth, 63);
    int m = std::min(move_index, 63);
    return g_lmr_table[d][m];
}

// ── Alpha-Beta with PVS + LMR + NMP + SEE Pruning + Improving ───────────
static thread_local std::chrono::steady_clock::time_point g_deadline;
static thread_local const std::atomic<bool>* g_stop_flag = nullptr;

// Throttled time check: only syscall every 4096 nodes to reduce overhead.
static thread_local uint64_t g_time_check_counter = 0;
static thread_local bool g_time_up_cache = false;

static bool time_up() {
    if (g_time_up_cache) return true;
    // WASM-SAFE: throttle wall-clock reads to once per 4096 node checks.
    if (((++g_time_check_counter) & 4095ULL) != 0) return false;
    bool up = std::chrono::steady_clock::now() > g_deadline ||
              (g_stop_flag && g_stop_flag->load(std::memory_order_relaxed));
    if (up) g_time_up_cache = true;
    return up;
}

static void reset_time_state() {
    g_time_check_counter = 0;
    g_time_up_cache = false;
}

static thread_local std::vector<uint64_t> g_search_hash_path;

// Game-level repetition history: seeded into g_search_hash_path before search
// so the engine avoids moves that create threefold repetition with prior positions.
static thread_local std::vector<uint64_t> g_game_rep_history;

struct SearchPathGuard {
    bool active = false;
    explicit SearchPathGuard(uint64_t h) {
        g_search_hash_path.push_back(h);
        active = true;
    }
    ~SearchPathGuard() {
        if (active && !g_search_hash_path.empty()) g_search_hash_path.pop_back();
    }
};

static bool path_is_threefold(uint64_t h) {
    int cnt = 0;
    for (auto it = g_search_hash_path.rbegin(); it != g_search_hash_path.rend(); ++it) {
        if (*it == h && ++cnt >= 3) return true;
    }
    return false;
}

// Seed search repetition path from game history.
// The current root hash is expected to be added by SearchPathGuard, so when
// the history already ends with root_hash we drop one copy to avoid double-counting.
static void seed_search_hash_path_from_history(const std::vector<uint64_t>& history,
                                               uint64_t root_hash) {
    g_search_hash_path = history;
    if (!g_search_hash_path.empty() && g_search_hash_path.back() == root_hash) {
        g_search_hash_path.pop_back();
    }
}

static int alphabeta(SearchState& st, int depth, int alpha, int beta,
                     const std::string& cpu_player, int ply,
                     bool null_ok=true, const MoveTriple* prev_move=nullptr,
                     ThreadData* td=nullptr) {
    SearchPathGuard path_guard(st.hash);
    if (path_is_threefold(st.hash)) return 0;
    g_nodes.fetch_add(1, std::memory_order_relaxed);
    const bool node_is_max = (st.turn == cpu_player);
    if (ply < MAX_PLY) { if (td) td->pv_len[ply] = ply; else g_pv_len[ply] = ply; }

    // Hard safety guard against runaway recursion in extended lines.
    if (ply >= MAX_PLY) {
        if (node_is_max) return quiesce(st, alpha, beta, cpu_player, cpu_player);
        return -quiesce(st, -beta, -alpha, opp(cpu_player), cpu_player);
    }

    int orig_alpha = alpha;
    int orig_beta  = beta;
    bool pv_node   = (beta - alpha > 1);

    // ── Terminal: win check ───────────────────────────────────────────────
    std::string last_mover = opp(st.turn);
    std::string win = check_win(st.pieces, last_mover);
    if (!win.empty()) {
        int base = 40000 + depth*100;
        return (last_mover == cpu_player) ? base : -base;
    }
    if (depth <= 3 && depth > 0) {
        int special_score = 0;
        if (low_depth_special_outcome(st, cpu_player, depth, &special_score))
            return special_score;
    }
    if (depth == 0) {
        // Quiescence is negamax-style from side-to-move perspective.
        if (node_is_max) return quiesce(st, alpha, beta, cpu_player, cpu_player);
        return -quiesce(st, -beta, -alpha, opp(cpu_player), cpu_player);
    }

    // ── TT lookup ─────────────────────────────────────────────────────────
    uint64_t h = st.hash;
    const MoveTriple* hash_move_ptr = nullptr;
    MoveTriple hash_move_buf{};
    const TTEntry* tte = tt_probe(h);
    if (tte && tte->depth >= depth && !pv_node) {
        if      (tte->flag==TT_EXACT) return tte->val;
        else if (tte->flag==TT_LOWER && tte->val>alpha) alpha=tte->val;
        else if (tte->flag==TT_UPPER && tte->val<beta)  beta=tte->val;
        if (alpha >= beta) return tte->val;
    }
    if (tte) { hash_move_buf = tt_unpack_move(*tte); hash_move_ptr = &hash_move_buf; }

    // ── Internal Iterative Reduction (IIR) ───────────────────────────────
    // When we have no hash move, reduce depth by 1 instead of expensive IID.
    // The search at reduced depth will populate the TT for future iterations.
    // FIX: Do NOT mutate `depth` in-place — that corrupts RFP/razoring margins,
    // correction history update depth, and TT store depth. Use a separate variable.
    int search_depth = depth;
    if (!hash_move_ptr && depth >= 6 && !pv_node) {
        search_depth = depth - 1;
    }

    // ── Corrected static eval (Stockfish 18 Correction History) ────────────
    // Apply position- and material-indexed correction offsets to the cheap
    // quick_eval so that all depth-pruning thresholds (RFP, Razoring, Futility,
    // Probcut, LMR-improving) are based on a more accurate baseline.
    int raw_static_eval = st.quick_eval;
    int static_eval = corrected_static_eval(h, st.pieces, st.turn, raw_static_eval);

    // ── "Improving" heuristic: is our eval better than 2 plies ago? ──────
    // FIX: reset at root so stale values from the previous search can't
    // incorrectly influence the improving flag in the new search.
    static thread_local int ply_eval[MAX_PLY + 4];
    if (ply == 0) std::fill(std::begin(ply_eval), std::end(ply_eval), 0);
    int eval_from_perspective = node_is_max ? static_eval : -static_eval;
    if (ply < MAX_PLY) ply_eval[ply] = eval_from_perspective;
    bool improving = (ply >= 2 && eval_from_perspective > ply_eval[ply - 2]);

    // ── Pruning safety check ─────────────────────────────────────────────
    // Disable aggressive pruning when either commander is under attack at any depth.
    bool pruning_safe = true;
    {
        int cpu_cmd_atk = commander_attackers_cached(st, cpu_player);
        int opp_cmd_atk = commander_attackers_cached(st, opp(cpu_player));
        pruning_safe = (cpu_cmd_atk == 0 && opp_cmd_atk == 0);
    }

    // ── Reverse Futility Pruning (Stockfish 18 tuning, extended to depth 4) ─
    // SF18 pushes RFP to depth 4 with tighter margins; the correction-history
    // improved static eval makes these thresholds more reliable.
    if (pruning_safe && !pv_node && depth <= 4) {
        int rfp_margin = (improving ? 100 : 160) * depth + 80;
        if (node_is_max && static_eval - rfp_margin >= beta) return static_eval;
        if (!node_is_max && static_eval + rfp_margin <= alpha) return static_eval;
    }

    // ── Razoring (extended to depth 1-3) ─────────────────────────────────
    if (pruning_safe && !pv_node && depth <= 3) {
        int razor_margin = 200 + 180 * (depth - 1);
        if (node_is_max && static_eval + razor_margin <= alpha) {
            if (depth <= 1) return quiesce(st, alpha, beta, cpu_player, cpu_player);
            int razor_val = quiesce(st, alpha, beta, cpu_player, cpu_player);
            if (razor_val <= alpha) return razor_val;
        }
        if (!node_is_max && static_eval - razor_margin >= beta) {
            if (depth <= 1) return -quiesce(st, -beta, -alpha, opp(cpu_player), cpu_player);
            int razor_val = -quiesce(st, -beta, -alpha, opp(cpu_player), cpu_player);
            if (razor_val >= beta) return razor_val;
        }
    }

    // ── Probcut: shallow search at elevated beta to skip cut nodes ───────
    if (pruning_safe && !pv_node && depth >= 5 && null_ok &&
        std::abs(beta) < 30000) {
        int probcut_beta = beta + 200;
        int probcut_depth = depth - 4;
        if (probcut_depth < 1) probcut_depth = 1;
        // Quick check: if static eval already beats probcut_beta, likely a cut
        if (node_is_max && static_eval >= probcut_beta) {
            int pc_val = alphabeta(st, probcut_depth, probcut_beta - 1, probcut_beta,
                                   cpu_player, ply, false, prev_move, td);
            if (pc_val >= probcut_beta) return pc_val;
        }
        if (!node_is_max && static_eval <= alpha - 200) {
            int probcut_alpha = alpha - 200;
            int pc_val = alphabeta(st, probcut_depth, probcut_alpha, probcut_alpha + 1,
                                   cpu_player, ply, false, prev_move, td);
            if (pc_val <= probcut_alpha) return pc_val;
        }
    }

    // ── Dynamic Null Move Pruning tuned for 11x12 volatility ──────────────
    if (null_ok && depth >= 3 && !pv_node) {
        int stm_pieces = 0;
        for (const auto& p : st.pieces) if (p.player == st.turn) stm_pieces++;

        // Disable NMP in likely zugzwang-ish reduced-material states.
        bool zugzwang_risk = side_has_only_pawn_militia_material(st.pieces, st.turn);
        if (stm_pieces > 2 && !zugzwang_risk) {
            int eval_margin = node_is_max ? (static_eval - beta) : (alpha - static_eval);

            // If static eval is far below bound, null move is unlikely to cut.
            if (eval_margin >= -64) {
                int cmd_tension = commander_attackers_cached(st, st.turn) +
                                  commander_attackers_cached(st, opp(st.turn));
                bool volatile_pos = (cmd_tension > 0);

                int R = 2;
                if (depth >= 10 && eval_margin >= 320) R = 4;
                else if (depth >= 7 && eval_margin >= 140) R = 3;

                // In complex/volatile or low-material positions use conservative reduction.
                if (volatile_pos || stm_pieces <= 7) R = 2;
                if (R > depth - 1) R = depth - 1;

                UndoMove nu;
                SearchState& ns = st;
                nu.turn_before = ns.turn;
                nu.hash_before = ns.hash;
                nu.quick_eval_before = ns.quick_eval;
                ns.hash ^= g_ZobristTurn[ns.turn=="red" ? 0 : 1];
                ns.turn = opp(ns.turn);
                ns.hash ^= g_ZobristTurn[ns.turn=="red" ? 0 : 1];
                ns.atk.valid = false;

                int null_val;
                if (node_is_max) {
                    // Minimax search: keep cpu_player perspective and do not negate.
                    null_val = alphabeta(ns, depth-1-R, beta-1, beta, cpu_player, ply+1, false, prev_move, td);
                } else {
                    null_val = alphabeta(ns, depth-1-R, alpha, alpha+1, cpu_player, ply+1, false, prev_move, td);
                }
                ns.turn = nu.turn_before;
                ns.hash = nu.hash_before;
                ns.quick_eval = nu.quick_eval_before;
                ns.atk.valid = false;
                ns.rebuild_caches();  // FIX: restore cached cmd positions/navy counts

                if (node_is_max) {
                    if (null_val >= beta) {
                        if (depth >= 8) {
                            int verify = alphabeta(st, depth-R-1, beta-1, beta, cpu_player, ply+1, false, prev_move, td);
                            if (verify >= beta) return beta;
                        } else {
                            return beta;
                        }
                    }
                } else {
                    if (null_val <= alpha) {
                        if (depth >= 8) {
                            int verify = alphabeta(st, depth-R-1, alpha, alpha+1, cpu_player, ply+1, false, prev_move, td);
                            if (verify <= alpha) return alpha;
                        } else {
                            return alpha;
                        }
                    }
                }
            }
        }
    }

    int pre_cpu_cmd_atk = commander_attackers_cached(st, cpu_player);
    int pre_opp_cmd_atk = commander_attackers_cached(st, opp(cpu_player));
    int pre_my_navy = st.navy_count[(cpu_player == "red") ? 0 : 1];
    AllMoves moves = all_moves_for(st.pieces, st.turn);
    if (moves.empty()) {
        ensure_attack_cache(st);
        return board_score(st.pieces, cpu_player, &st.atk, &st.turn);
    }

    const MoveTriple* pv_move_ptr = nullptr;
    MoveTriple pv_move_buf{};
    if (ply < MAX_PLY && (td ? td->pv_len[ply] : g_pv_len[ply]) > ply) {
        pv_move_buf = td ? td->pv[ply][ply] : g_pv[ply][ply];
        pv_move_ptr = &pv_move_buf;
    }
    moves = order_moves(moves, st.pieces, st.turn, ply, hash_move_ptr, pv_move_ptr, prev_move, td);

    int val = node_is_max ? -999999 : 999999;
    MoveTriple best_move = moves[0];
    int move_index = 0;
    int hist_pl = player_idx(st.turn);
    if (hist_pl < 0) hist_pl = 0;

    // Track quiet moves searched (for history malus on cutoff)
    struct QuietEntry { int ki; int dc; int dr; };
    std::array<QuietEntry, 64> searched_quiets{};
    int searched_quiet_count = 0;

    for (auto& m : moves) {
        if (time_up()) break;
        int moved_idx0 = find_piece_idx_by_id(st.pieces, m.pid);
        int moved_ki = (moved_idx0 >= 0) ? kind_index(st.pieces[moved_idx0].kind) : -1;
        const Piece* target = piece_at_c(st.pieces, m.dc, m.dr);
        bool is_capture = (target && target->player != st.turn);
        const bool captures_navy = is_capture && target && target->kind=="N";
        bool is_critical_capture = is_capture &&
            (target->kind=="C" || target->kind=="N" || target->kind=="Af" ||
             target->kind=="A" || target->kind=="T" || target->kind=="In");
        int full_depth = search_depth - 1 + ((is_critical_capture && search_depth <= 4) ? 1 : 0);
        if (full_depth < 0) full_depth = 0;

        bool is_killer  = (ply<MAX_PLY &&
                           (((td ? td->killers_set[ply][0] : g_killers_set[ply][0]) &&
                             same_move(td ? td->killers[ply][0] : g_killers[ply][0], m)) ||
                            ((td ? td->killers_set[ply][1] : g_killers_set[ply][1]) &&
                             same_move(td ? td->killers[ply][1] : g_killers[ply][1], m))));

        bool is_hash_move = (hash_move_ptr && same_move(*hash_move_ptr, m));
        bool is_quiet = (!is_capture && !is_killer && !is_critical_capture && !is_hash_move);

        // ── Late Move Pruning (LMP) — improving-aware thresholds ─────────
        if (is_quiet && depth <= 4 && !pv_node) {
            int lmp_base = improving ? 5 : 3;
            int lmp_threshold = lmp_base + depth * depth;
            if (move_index >= lmp_threshold && pre_cpu_cmd_atk == 0 && pre_opp_cmd_atk == 0) {
                move_index++;
                continue;
            }
        }

        // ── History-Based Pruning ─────────────────────────────────────────
        // Skip quiet moves at shallow depth whose history score is strongly
        // negative — the engine has repeatedly found them to be bad moves.
        // Adapted from Stockfish's history pruning; gains ~6 Elo by cutting
        // ~8% of nodes at low depths with almost no accuracy loss.
        if (is_quiet && depth <= 6 && !pv_node && move_index > 1 && moved_ki >= 0 &&
            pre_cpu_cmd_atk == 0 && pre_opp_cmd_atk == 0) {
            int hval = td ? td_history_score(*td, hist_pl, moved_ki, m.dc, m.dr)
                          : history_score(hist_pl, moved_ki, m.dc, m.dr);
            if (hval < -55 * depth * depth) {
                move_index++;
                continue;
            }
        }

        // ── Futility Pruning (both sides, depth 1-3) ────────────────────
        if (is_quiet && !pv_node && depth <= 3 && pre_cpu_cmd_atk == 0 && pre_opp_cmd_atk == 0) {
            int fut_margin = (improving ? 130 : 170) * depth + 80;
            if (node_is_max && static_eval + fut_margin <= alpha) {
                move_index++;
                continue;
            }
            if (!node_is_max && static_eval - fut_margin >= beta) {
                move_index++;
                continue;
            }
        }

        // ── SEE Pruning: skip losing captures at shallow depth ──────────
        if (is_capture && !is_critical_capture && depth <= 4 && !pv_node && move_index > 0) {
            int see_val = see(st.pieces, m.dc, m.dr, st.turn);
            if (see_val < -80 * depth) {
                move_index++;
                continue;
            }
        }

        // ── Singular / Negative / Double Extension logic ──────────────────
        // Inspired by Stockfish's SE + negative extension combo (+8-12 Elo).
        //
        // For the TT-best (hash) move:
        //   • Singular (+1): no other move beats tte->val - 90 at depth-2.
        //   • Double-singular (+2): singular AND no move even came close
        //     (near-miss count == 0 after testing >= 4 alternatives).
        //
        // For non-hash moves when we have a reliable TT entry:
        //   • Negative (-1): TT says another move clearly fails high, so
        //     this move is unlikely to be the best — reduce its search.
        //   • Mild negative (-1): TT value is close to beta.
        //
        // se_extension is applied additively to rule_ext below.
        int se_extension = 0;
        {
            const int tt_val = tte ? tte->val : 0;
            if (is_hash_move && tte && tte->depth >= search_depth - 1 && search_depth >= 5 &&
                !time_up() && std::abs(tt_val) < 30000) {
                int sing_beta = tt_val - 90;
                bool is_singular = true;
                int tested = 0, near_miss = 0;
                for (auto& om : moves) {
                    if (same_move(om, m)) continue;
                    if (tested >= 16 || time_up()) break;
                    UndoMove su;
                    if (!make_move_inplace(st, om, cpu_player, su)) continue;
                    int sv = alphabeta(st, search_depth - 2, sing_beta - 1, sing_beta, cpu_player, ply + 1, false, &om, td);
                    unmake_move_inplace(st, su);
                    ++tested;
                    if (sv >= sing_beta) { is_singular = false; break; }
                    if (sv >= sing_beta - 30) ++near_miss;
                }
                if (is_singular) {
                    // Double extension: no alternative came even close
                    bool doubly_singular = (near_miss == 0 && tested >= 4 && !pv_node);
                    se_extension = doubly_singular ? 2 : 1;
                }
            } else if (!is_hash_move && tte && search_depth >= 5 &&
                       std::abs(tt_val) < 30000 && tte->flag == TT_LOWER) {
                // Negative extension: TT reports another move scores >= beta here,
                // so this non-best move is unlikely to matter — search it less.
                if (tt_val >= beta)       se_extension = -2;
                else if (tt_val >= beta - 60) se_extension = -1;
            }
        }

        UndoMove u;
        if (!make_move_inplace(st, m, cpu_player, u)) continue;
        tt_prefetch(st.hash);  // prefetch child's TT entry to hide latency

        // Rule-aware selective extensions.
        int post_cpu_cmd_atk = commander_attackers_cached(st, cpu_player);
        int post_opp_cmd_atk = commander_attackers_cached(st, opp(cpu_player));
        int post_my_navy = st.navy_count[(cpu_player == "red") ? 0 : 1];
        int rule_ext = 0;
        if (pre_cpu_cmd_atk > 0 && post_cpu_cmd_atk < pre_cpu_cmd_atk) rule_ext++;
        if (node_is_max && post_opp_cmd_atk > 0) rule_ext++;
        if (captures_navy) rule_ext++;
        if (pre_my_navy == 1 && post_my_navy == 1 && post_cpu_cmd_atk == 0) rule_ext++;
        // Singular / double-singular: add se_extension (1 or 2).
        // Negative extension handled separately below.
        if (se_extension > 0) rule_ext += se_extension;
        // Recapture extension: resolving captures on the same square as the
        // previous move prevents horizon-effect blunders in tactical sequences.
        if (prev_move && is_capture &&
            m.dc == prev_move->dc && m.dr == prev_move->dr) rule_ext++;
        if (rule_ext > 2) rule_ext = 2;

        int ext_depth = full_depth + rule_ext;
        // Apply negative extension after positive cap — keeps it meaningful.
        if (se_extension < 0) ext_depth = std::max(0, ext_depth + se_extension);
        if (ext_depth >= search_depth) ext_depth = search_depth - 1;
        if (ext_depth < 0) ext_depth = 0;
        int child;
        if (move_index == 0) {
            // PV move: full window
            child = alphabeta(st, ext_depth, alpha, beta, cpu_player, ply+1, true, &m, td);
        } else {
            int new_depth = ext_depth;

            // ── LMR: table-driven reductions for late quiet moves ────────
            if (is_quiet && move_index >= 2 && search_depth >= 2) {
                int R = lmr_reduction(search_depth, move_index);
                if (pv_node) R -= 1;
                if (improving) R -= 1;
                if (!improving && search_depth >= 6) R += 1;
                // SF18: history-based LMR adjustment
                // Good history → reduce less; bad history → reduce more.
                if (moved_ki >= 0) {
                    int hval = td ? td_history_score(*td, hist_pl, moved_ki, m.dc, m.dr)
                                  : history_score(hist_pl, moved_ki, m.dc, m.dr);
                    R -= hval / 6000;  // ±5 range from history
                }
                if (R < 0) R = 0;
                new_depth = ext_depth - R;
                if (new_depth < 1) new_depth = 1;
            }

            // Zero-window (PVS) search
            if (node_is_max)
                child = alphabeta(st, new_depth, alpha, alpha+1, cpu_player, ply+1, true, &m, td);
            else
                child = alphabeta(st, new_depth, beta-1,  beta, cpu_player, ply+1, true, &m, td);

            // Re-search at full depth if LMR-reduced search beats the bound
            bool lmr_fail = node_is_max ? (child > alpha) : (child < beta);
            if (new_depth < ext_depth && lmr_fail) {
                if (pv_node) {
                    // PV node: re-search directly with full window (skip extra ZW)
                    child = alphabeta(st, ext_depth, alpha, beta, cpu_player, ply+1, true, &m, td);
                } else {
                    if (node_is_max)
                        child = alphabeta(st, ext_depth, alpha, alpha+1, cpu_player, ply+1, true, &m, td);
                    else
                        child = alphabeta(st, ext_depth, beta-1, beta, cpu_player, ply+1, true, &m, td);
                }
            }

            // Full-window re-search if PVS fails in PV node (only needed when LMR wasn't already re-searched full)
            if (!lmr_fail || new_depth >= ext_depth) {
                bool pvs_fail = node_is_max ? (child > alpha && child < beta)
                                            : (child < beta  && child > alpha);
                if (pvs_fail && pv_node) {
                    child = alphabeta(st, ext_depth, alpha, beta, cpu_player, ply+1, true, &m, td);
                }
            }
        }

        unmake_move_inplace(st, u);

        // Track searched quiet moves for history malus
        if (is_quiet && moved_ki >= 0) {
            if (searched_quiet_count < (int)searched_quiets.size()) {
                searched_quiets[searched_quiet_count++] = {moved_ki, m.dc, m.dr};
            }
        }

        move_index++;

        if (node_is_max) {
            if (child > val) {
                val=child; best_move=m;
                if (ply < MAX_PLY) {
                    auto& pv_arr = td ? td->pv : g_pv;
                    auto& pv_l   = td ? td->pv_len : g_pv_len;
                    pv_arr[ply][ply] = m;
                    pv_l[ply] = ply + 1;
                    if (ply+1 < MAX_PLY && pv_l[ply+1] > ply+1) {
                        for (int i = ply+1; i < pv_l[ply+1] && i < MAX_PLY; i++)
                            pv_arr[ply][i] = pv_arr[ply+1][i];
                        pv_l[ply] = pv_l[ply+1];
                    }
                }
            }
            alpha = std::max(alpha, val);
            if (beta <= alpha) {
                if (!is_capture) {
                    if (td) { td_store_killer(*td, m, ply); } else { store_killer(m, ply); }
                    if (moved_ki >= 0) {
                        if (td) { td_update_history(*td, hist_pl, moved_ki, m.dc, m.dr, depth);
                                  td_update_cont_history(*td, prev_move, moved_ki, m.dc, m.dr, depth); }
                        else    { update_history(hist_pl, moved_ki, m.dc, m.dr, depth);
                                  update_cont_history(prev_move, moved_ki, m.dc, m.dr, depth); }
                    }
                    // History malus: penalise other quiet moves that didn't cause cutoff
                    for (int qi = 0; qi < searched_quiet_count; qi++) {
                        const auto& sq = searched_quiets[qi];
                        if (sq.ki == moved_ki && sq.dc == m.dc && sq.dr == m.dr) continue;
                        if (td) td_penalise_history(*td, hist_pl, sq.ki, sq.dc, sq.dr, depth);
                        else    penalise_history(hist_pl, sq.ki, sq.dc, sq.dr, depth);
                    }
                    if (prev_move && on_board(prev_move->dc, prev_move->dr)) {
                        if (td) { td->counter[prev_move->dc][prev_move->dr] = m;
                                  td->counter_set[prev_move->dc][prev_move->dr] = true; }
                        else    { g_counter[prev_move->dc][prev_move->dr] = m;
                                  g_counter_set[prev_move->dc][prev_move->dr] = true; }
                    }
                }
                break;
            }
        } else {
            if (child < val) {
                val=child; best_move=m;
                if (ply < MAX_PLY) {
                    auto& pv_arr = td ? td->pv : g_pv;
                    auto& pv_l   = td ? td->pv_len : g_pv_len;
                    pv_arr[ply][ply] = m;
                    pv_l[ply] = ply + 1;
                    if (ply+1 < MAX_PLY && pv_l[ply+1] > ply+1) {
                        for (int i = ply+1; i < pv_l[ply+1] && i < MAX_PLY; i++)
                            pv_arr[ply][i] = pv_arr[ply+1][i];
                        pv_l[ply] = pv_l[ply+1];
                    }
                }
            }
            beta = std::min(beta, val);
            if (beta <= alpha) {
                if (!is_capture) {
                    if (td) { td_store_killer(*td, m, ply); } else { store_killer(m, ply); }
                    if (moved_ki >= 0) {
                        if (td) { td_update_history(*td, hist_pl, moved_ki, m.dc, m.dr, depth);
                                  td_update_cont_history(*td, prev_move, moved_ki, m.dc, m.dr, depth); }
                        else    { update_history(hist_pl, moved_ki, m.dc, m.dr, depth);
                                  update_cont_history(prev_move, moved_ki, m.dc, m.dr, depth); }
                    }
                    for (int qi = 0; qi < searched_quiet_count; qi++) {
                        const auto& sq = searched_quiets[qi];
                        if (sq.ki == moved_ki && sq.dc == m.dc && sq.dr == m.dr) continue;
                        if (td) td_penalise_history(*td, hist_pl, sq.ki, sq.dc, sq.dr, depth);
                        else    penalise_history(hist_pl, sq.ki, sq.dc, sq.dr, depth);
                    }
                    if (prev_move && on_board(prev_move->dc, prev_move->dr)) {
                        if (td) { td->counter[prev_move->dc][prev_move->dr] = m;
                                  td->counter_set[prev_move->dc][prev_move->dr] = true; }
                        else    { g_counter[prev_move->dc][prev_move->dr] = m;
                                  g_counter_set[prev_move->dc][prev_move->dr] = true; }
                    }
                }
                break;
            }
        }
    }

    if (move_index == 0) {
        ensure_attack_cache(st);
        return board_score(st.pieces, cpu_player, &st.atk, &st.turn);
    }

    int flag = (val<=orig_alpha) ? TT_UPPER : (val>=orig_beta ? TT_LOWER : TT_EXACT);
    tt_store(h, depth, flag, val, best_move);
    // ── Update Correction History (Stockfish 18) ──────────────────────────
    // Only update on EXACT (inside-window) nodes: fail-high/low scores are
    // one-sided bounds and would bias the correction in the wrong direction.
    // FIX: Both search_val and raw_static_eval must be from the same
    // player's perspective. raw_static_eval is always from cpu_player's view.
    // For min nodes (opponent's turn), negate both so the correction is
    // computed from the opponent's perspective before storing.
    if (flag == TT_EXACT && depth >= 1 && std::abs(val) < 20000) {
        int corr_val = node_is_max ? val : -val;
        int corr_static = node_is_max ? raw_static_eval : -raw_static_eval;
        update_correction_history(h, st.pieces, node_is_max ? cpu_player : opp(cpu_player),
                                  depth, corr_val, corr_static);
    }
    return val;
}

struct AIResult { bool found; MoveTriple move; };

// ═══════════════════════════════════════════════════════════════════════════
// HYBRID MCTS + ALPHA-BETA ROOT SEARCH  (AlphaZero-style)
// ═══════════════════════════════════════════════════════════════════════════
//
// Architecture:
//   • Root:  Monte-Carlo Tree Search with PUCT selection guided by a
//            heuristic "policy head" (captures/mobility/positional priors).
//   • Leaf:  Alpha-beta at engine_mcts_ab_depth() plies — acts as the "value head".
//   • This eliminates the horizon effect that pure AB suffers at the root:
//     promising moves receive exponentially more AB evaluations, naturally
//     extending the effective search horizon.
// ────────────────────────────────────────────────────────────────────────────

static constexpr float MCTS_CPUCT    = 1.8f;  // exploration constant
static constexpr float MCTS_VIRTUAL_LOSS = 0.35f;
static constexpr int   MCTS_MAX_THREADS = 8;
static constexpr int   MCTS_EVAL_BATCH_CPU = 16;
static constexpr int   MCTS_EVAL_BATCH_WEBGPU = 128;

// ── Heuristic policy prior (simulates NNUE policy head) ──────────────────
// Returns a softmax probability vector over the given moves.
static std::vector<float> mcts_policy_priors(const AllMoves& moves,
                                              const PieceList& pieces,
                                              const std::string& player) {
    if (moves.empty()) return {};
    std::vector<float> raw(moves.size(), 0.0f);
    int hist_pl = player_idx(player);
    if (hist_pl < 0) hist_pl = 0;

    // Pre-locate commanders for threat/escape bonuses (O(n) once).
    const Piece* my_cmd  = nullptr;
    const Piece* opp_cmd = nullptr;
    for (const auto& p : pieces) {
        if (p.kind != "C") continue;
        if (p.player == player) my_cmd = &p;
        else                    opp_cmd = &p;
    }

    for (size_t i = 0; i < moves.size(); i++) {
        const auto& m = moves[i];
        float s = 0.0f;

        // Capture bonus: MVV/LVA-weighted with SEE refinement
        const Piece* tgt = piece_at_c(pieces, m.dc, m.dr);
        if (tgt && tgt->player != player) {
            int victim = piece_value_fast(tgt->kind);
            int atk_idx = find_piece_idx_by_id(pieces, m.pid);
            int attacker = (atk_idx >= 0) ? std::max(1, piece_value_fast(pieces[atk_idx].kind)) : 1;
            s += 300.0f + victim * 2.0f - attacker * 0.25f;
            int sv = see(pieces, m.dc, m.dr, player);
            s += sv >= 0 ? (50.0f + sv * 0.05f) : (sv * 0.02f);
        }

        // Central-control bonus
        float cdist = std::abs(m.dc - 5) + std::abs(m.dr - 6);
        s += std::max(0.0f, 18.0f - cdist * 2.5f);

        // Forward-advance bonus (push pieces toward opponent)
        int atk_idx = find_piece_idx_by_id(pieces, m.pid);
        if (atk_idx >= 0) {
            const Piece& ap = pieces[atk_idx];
            float adv = (player == "blue") ? (float)(ap.row - m.dr)
                                           : (float)(m.dr - ap.row);
            s += adv * 3.5f;
        }

        // History heuristic bonus from global table
        if (atk_idx >= 0 && atk_idx < (int)pieces.size()) {
                int ki = kind_index(pieces[atk_idx].kind);
                if (ki >= 0 && ki < H_KINDS) {
                    int hist = g_history[hist_pl][ki][m.dc][m.dr];
                    s += (float)hist * 0.008f;
                }
            }

        // ── Commander threat bonus ────────────────────────────────────────
        // Moves that bring a piece close to the enemy commander or that
        // directly threaten to capture it are far more important in
        // Commander Chess than central control alone.
        if (opp_cmd) {
            int dist = std::abs(m.dc - opp_cmd->col) + std::abs(m.dr - opp_cmd->row);
            if (dist == 0)      s += 800.0f;  // captures commander (shouldn't happen normally)
            else if (dist <= 1) s += 350.0f;  // adjacent — direct threat
            else if (dist <= 2) s += 180.0f;  // very close
            else if (dist <= 4) s +=  60.0f;  // approaching
        }

        // ── Own-commander shelter / escape bonus ──────────────────────────
        // When our commander is threatened, prioritise moves that place a
        // piece as a bodyguard (nearby defender) or move commander to safety.
        if (my_cmd) {
            bool my_cmd_piece = (atk_idx >= 0 && pieces[atk_idx].kind == "C");
            int dist_to = std::abs(m.dc - my_cmd->col) + std::abs(m.dr - my_cmd->row);
            if (my_cmd_piece) {
                // Commander moving: bonus for moving away from danger
                s += 30.0f;
            } else if (dist_to <= 2 && atk_idx >= 0) {
                int dist_from = std::abs(pieces[atk_idx].col - my_cmd->col)
                              + std::abs(pieces[atk_idx].row - my_cmd->row);
                if (dist_to < dist_from) s += 40.0f; // moving toward own commander = shelter
            }
        }

        raw[i] = s;
    }

    // Softmax with temperature τ = 25 (was 80).
    // Sharper temperature focuses simulations on stronger moves while
    // still preserving enough exploration for PUCT to function correctly.
    float max_s = *std::max_element(raw.begin(), raw.end());
    float sum = 0.0f;
    for (auto& v : raw) { v = std::exp((v - max_s) / 25.0f); sum += v; }
    if (sum > 1e-9f) for (auto& v : raw) v /= sum;
    return raw;
}

// ── Per-child node at the MCTS root ──────────────────────────────────────
struct MCTSRootChild {
    MoveTriple  move{};
    float       prior       = 0.0f;
    int         visits      = 0;
    int         virtual_loss = 0;
    float       total_value = 0.0f;
    SearchState state;                  // board snapshot after this move

    float q() const {
        return visits > 0 ? total_value / (float)visits : 0.0f;
    }
};

// ── Two-level MCTS: root children + their children ───────────────────────
// Each root child can be further expanded one more ply.
struct MCTSLevel2Child {
    MoveTriple  move{};
    float       prior       = 0.0f;
    int         visits      = 0;
    int         virtual_loss = 0;
    float       total_value = 0.0f;
    SearchState state;
    float q() const { return visits > 0 ? total_value / (float)visits : 0.0f; }
    float q_with_virtual_loss() const {
        int v = visits + virtual_loss;
        if (v <= 0) return 0.0f;
        float tv = total_value - MCTS_VIRTUAL_LOSS * (float)virtual_loss;
        return tv / (float)v;
    }
    int visits_with_virtual_loss() const { return visits + virtual_loss; }
};

struct MCTSLevel1Child {
    MoveTriple  move{};
    float       prior       = 0.0f;
    int         visits      = 0;
    int         virtual_loss = 0;
    float       total_value = 0.0f;
    SearchState state;
    bool        expanded    = false;
    std::vector<MCTSLevel2Child> children;

    float q() const { return visits > 0 ? total_value / (float)visits : 0.0f; }
    float q_with_virtual_loss() const {
        int v = visits + virtual_loss;
        if (v <= 0) return 0.0f;
        float tv = total_value - MCTS_VIRTUAL_LOSS * (float)virtual_loss;
        return tv / (float)v;
    }
    int visits_with_virtual_loss() const { return visits + virtual_loss; }
};

// ── Main MCTS+AB root search ──────────────────────────────────────────────
static AIResult mcts_ab_root_search(const PieceList& pieces,
                                     const std::string& cpu_player,
                                     int ab_depth,
                                     double time_limit_secs,
                                     const std::atomic<bool>* stop_flag = nullptr) {
    auto deadline = std::chrono::steady_clock::now() +
                    std::chrono::milliseconds((long long)(time_limit_secs * 1000));
    g_deadline = deadline;
    g_stop_flag = stop_flag;
    reset_time_state();
    g_nodes.store(0, std::memory_order_relaxed);

    SearchState root_st = make_search_state(pieces, cpu_player, cpu_player);
    seed_search_hash_path_from_history(g_game_rep_history, root_st.hash);
    AllMoves all_moves  = all_moves_for(root_st.pieces, cpu_player);
    if (all_moves.empty()) return {false, {}};
    if (all_moves.size() == 1) return {true, all_moves[0]};

    std::vector<float> root_priors =
        mcts_policy_priors(all_moves, root_st.pieces, cpu_player);

    std::vector<MCTSLevel1Child> children;
    children.reserve(all_moves.size());
    for (size_t i = 0; i < all_moves.size(); i++) {
        MCTSLevel1Child c;
        c.move  = all_moves[i];
        c.prior = root_priors[i];
        c.state = root_st;
        UndoMove u;
        if (!make_move_inplace(c.state, all_moves[i], cpu_player, u)) continue;
        children.push_back(std::move(c));
    }
    if (children.empty()) return {false, {}};

    struct SelectionPath {
        int l1_idx = -1;
        int l2_idx = -1;
        SearchState eval_st;
        MoveTriple prev_move{};
    };

    int root_visits = 1;
    EngineMutex tree_mutex;
    const std::string opp_player = opp(cpu_player);

    auto evaluate_leaf_value = [&](SelectionPath& sel, int* out_val) -> bool {
        if (!out_val) return false;
        int val = alphabeta(sel.eval_st, ab_depth, -999999, 999999,
                            cpu_player, (sel.l2_idx >= 0 ? 2 : 1), true, &sel.prev_move, nullptr);
        if (time_up()) return false;
        *out_val = val;
        return true;
    };

    auto apply_leaf_result = [&](const SelectionPath& sel, float leaf_val) -> bool {
        std::lock_guard<EngineMutex> lk(tree_mutex);
        if (sel.l1_idx < 0 || sel.l1_idx >= (int)children.size()) return false;
        MCTSLevel1Child& l1 = children[sel.l1_idx];
        if (l1.virtual_loss > 0) l1.virtual_loss--;

        if (sel.l2_idx >= 0 && sel.l2_idx < (int)l1.children.size()) {
            MCTSLevel2Child& l2 = l1.children[sel.l2_idx];
            if (l2.virtual_loss > 0) l2.virtual_loss--;
            l2.visits++;
            // Level-2 node is opponent-to-move; store from opponent perspective.
            l2.total_value -= leaf_val;
        }

        l1.visits++;
        l1.total_value += leaf_val;
        root_visits++;
        return true;
    };

    auto rollback_virtual_loss = [&](const SelectionPath& sel) {
        std::lock_guard<EngineMutex> lk(tree_mutex);
        if (sel.l1_idx < 0 || sel.l1_idx >= (int)children.size()) return;
        MCTSLevel1Child& l1 = children[sel.l1_idx];
        if (l1.virtual_loss > 0) l1.virtual_loss--;
        if (sel.l2_idx >= 0 && sel.l2_idx < (int)l1.children.size()) {
            MCTSLevel2Child& l2 = l1.children[sel.l2_idx];
            if (l2.virtual_loss > 0) l2.virtual_loss--;
        }
    };

    auto select_path = [&](SelectionPath& sel) -> bool {
        std::lock_guard<EngineMutex> lk(tree_mutex);
        if (children.empty()) return false;

        float sqrt_root = std::sqrt((float)std::max(1, root_visits));
        int l1_idx = 0;
        float best_puct = -1e18f;
        for (int i = 0; i < (int)children.size(); i++) {
            auto& c = children[i];
            float q = c.q_with_virtual_loss();
            float u = MCTS_CPUCT * c.prior * sqrt_root /
                      (1.0f + (float)c.visits_with_virtual_loss());
            float puct = q + u;
            if (puct > best_puct) { best_puct = puct; l1_idx = i; }
        }

        MCTSLevel1Child& l1 = children[l1_idx];
        l1.virtual_loss++;
        sel.l1_idx = l1_idx;
        sel.eval_st = l1.state;
        sel.prev_move = l1.move;

        if (l1.visits >= 2) {
            if (!l1.expanded) {
                l1.expanded = true;
                AllMoves l2_moves = all_moves_for(l1.state.pieces, opp_player);
                std::vector<float> l2_priors =
                    mcts_policy_priors(l2_moves, l1.state.pieces, opp_player);
                l1.children.reserve(l2_moves.size());
                for (size_t j = 0; j < l2_moves.size(); j++) {
                    MCTSLevel2Child c2;
                    c2.move  = l2_moves[j];
                    c2.prior = l2_priors[j];
                    c2.state = l1.state;
                    UndoMove u2;
                    if (!make_move_inplace(c2.state, l2_moves[j], opp_player, u2)) continue;
                    l1.children.push_back(std::move(c2));
                }
            }

            if (!l1.children.empty()) {
                float sqrt_l1 = std::sqrt((float)std::max(1, l1.visits_with_virtual_loss()));
                int l2_idx = 0;
                float best_puct2 = -1e18f;
                for (int j = 0; j < (int)l1.children.size(); j++) {
                    auto& c2 = l1.children[j];
                    float q2 = c2.q_with_virtual_loss();
                    float u2 = MCTS_CPUCT * c2.prior * sqrt_l1 /
                               (1.0f + (float)c2.visits_with_virtual_loss());
                    // q2 is stored from opponent perspective at level-2.
                    float puct2 = q2 + u2;
                    if (puct2 > best_puct2) { best_puct2 = puct2; l2_idx = j; }
                }
                MCTSLevel2Child& l2 = l1.children[l2_idx];
                l2.virtual_loss++;
                sel.l2_idx = l2_idx;
                sel.eval_st = l2.state;
                sel.prev_move = l2.move;
            }
        }
        return true;
    };

    auto worker = [&](int tid) {
        g_deadline = deadline;
        g_stop_flag = stop_flag;
        reset_time_state();
        (void)tid;

        const bool use_webgpu = (active_eval_backend() == EvalBackendKind::WEBGPU);
        int eval_batch_size = use_webgpu ? MCTS_EVAL_BATCH_WEBGPU : MCTS_EVAL_BATCH_CPU;
        eval_batch_size = std::max(1, std::min(eval_batch_size, (int)children.size()));

        while (!time_up()) {
            if (stop_flag && stop_flag->load(std::memory_order_relaxed)) break;

            std::vector<SelectionPath> selected;
            selected.reserve((size_t)eval_batch_size);
            for (int i = 0; i < eval_batch_size && !time_up(); i++) {
                SelectionPath sel;
                if (!select_path(sel)) break;
                selected.push_back(std::move(sel));
            }
            if (selected.empty()) break;

            std::vector<int> values(selected.size(), 0);
            std::vector<uint8_t> ok(selected.size(), 0);
            for (size_t i = 0; i < selected.size(); i++) {
                int val = 0;
                if (evaluate_leaf_value(selected[i], &val)) {
                    values[i] = val;
                    ok[i] = 1;
                }
            }

            // Node queue batching path: blend AB leaf values with batched evaluator scores.
            std::vector<EvalBatchRequest> reqs;
            std::vector<size_t> req_idx;
            reqs.reserve(selected.size());
            req_idx.reserve(selected.size());
            for (size_t i = 0; i < selected.size(); i++) {
                if (!ok[i]) continue;
                ensure_attack_cache(selected[i].eval_st);
                reqs.push_back(EvalBatchRequest{
                    &selected[i].eval_st.pieces,
                    &cpu_player,
                    &selected[i].eval_st.atk,
                    &selected[i].eval_st.turn
                });
                req_idx.push_back(i);
            }
            if (!reqs.empty()) {
                std::vector<int> batch_scores = board_score_batch(reqs);
                size_t n = std::min(batch_scores.size(), req_idx.size());
                for (size_t j = 0; j < n; j++) {
                    size_t idx = req_idx[j];
                    if (use_webgpu) values[idx] = (values[idx] * 3 + batch_scores[j]) / 4;
                    else            values[idx] = (values[idx] * 7 + batch_scores[j]) / 8;
                }
            }

            bool any_applied = false;
            for (size_t i = 0; i < selected.size(); i++) {
                if (!ok[i]) {
                    rollback_virtual_loss(selected[i]);
                    continue;
                }
                float leaf_val = std::max(-1.0f, std::min(1.0f, (float)values[i] / 6000.0f));
                if (apply_leaf_result(selected[i], leaf_val)) {
                    any_applied = true;
                } else {
                    rollback_virtual_loss(selected[i]);
                }
            }
            if (!any_applied && time_up()) {
                break;
            }
        }
    };

    int num_workers = 1;
#if COMMANDER_ENABLE_THREADS
    if (!get_engine_config().force_single_thread) {
        int hw_threads = (int)std::thread::hardware_concurrency();
        if (hw_threads <= 0) hw_threads = 1;
        num_workers = std::max(1, std::min(hw_threads, MCTS_MAX_THREADS));
    }
#endif
    if (time_limit_secs <= 0.10 || (int)children.size() <= 2) num_workers = 1;

    if (num_workers == 1) {
        worker(0);
    } else {
#if COMMANDER_ENABLE_THREADS
        std::vector<std::thread> threads;
        threads.reserve(num_workers);
        for (int i = 0; i < num_workers; i++) threads.emplace_back(worker, i);
        for (auto& t : threads) if (t.joinable()) t.join();
#else
        worker(0);
#endif
    }

    int best_idx = 0;
    int best_visits = -1;
    float best_q = -1e18f;
    for (int i = 0; i < (int)children.size(); i++) {
        const auto& c = children[i];
        if (c.visits > best_visits ||
            (c.visits == best_visits && c.q() > best_q)) {
            best_visits = c.visits;
            best_q = c.q();
            best_idx = i;
        }
    }

    if (best_visits <= 0) return {false, {}};
    return {true, children[best_idx].move};
}

static bool is_legal_book_move(const SearchState& st, const std::string& cpu_player, const MoveTriple& cand) {
    int idx = find_piece_idx_by_id(st.pieces, cand.pid);
    if (idx < 0) return false;
    const Piece& p = st.pieces[idx];
    if (p.player != cpu_player) return false;
    auto mvs = get_moves(p, st.pieces);
    for (auto& mv : mvs) if (mv.first==cand.dc && mv.second==cand.dr) return true;
    return false;
}

static void append_book_move_from_square(std::vector<MoveTriple>& book,
                                         const SearchState& st,
                                         const std::string& cpu_player,
                                         int from_c, int from_r,
                                         int to_c, int to_r) {
    int idx = find_piece_idx_at(st.pieces, from_c, from_r);
    if (idx < 0) return;
    const Piece& p = st.pieces[idx];
    if (p.player != cpu_player) return;
    book.push_back({p.id, to_c, to_r});
}

static int opening_immediate_risk(const PieceList& pieces, const std::string& cpu_player) {
    AllMoves om = all_moves_for(pieces, opp(cpu_player));
    bool commander_hanging = false;
    std::set<int> af_hanging;
    std::set<int> navy_hanging;
    std::set<int> land_hanging;

    for (auto& m : om) {
        const Piece* t = piece_at_c(pieces, m.dc, m.dr);
        if (!t || t->player != cpu_player) continue;
        if (t->kind == "C") commander_hanging = true;
        else if (t->kind == "Af") af_hanging.insert(t->id);
        else if (t->kind == "N") navy_hanging.insert(t->id);
        else if (t->kind == "A" || t->kind == "T" || t->kind == "In")
            land_hanging.insert(t->id);
    }

    int risk = 0;
    if (commander_hanging) risk += 1000000;
    risk += (int)af_hanging.size() * 6000;
    risk += (int)navy_hanging.size() * 1400;
    risk += (int)land_hanging.size() * 250;
    return risk;
}

static bool opening_book_pick(const SearchState& st, const std::string& cpu_player, MoveTriple& out) {
    if (st.pieces.size() < 34) return false; // opening only
    const bool very_early_opening = (st.pieces.size() >= 36);
    auto prow = [&](int blue_row) { return (cpu_player == "red") ? (ROWS - 1 - blue_row) : blue_row; };

    std::vector<MoveTriple> book;

    // Prefer early navy stabilization + air control in opening (perspective-aware).
    const int r_back = prow(10);
    const int r_front = prow(8);
    const Piece* navy_back = piece_at_c(st.pieces, 0, r_back);
    const Piece* navy_front = piece_at_c(st.pieces, 0, r_front);
    bool have_back_navy = navy_back && navy_back->player == cpu_player && navy_back->kind == "N";
    bool have_front_navy = navy_front && navy_front->player == cpu_player && navy_front->kind == "N";
    if (have_back_navy && have_front_navy) {
        append_book_move_from_square(book, st, cpu_player, 0, r_front, 1, r_front);
        append_book_move_from_square(book, st, cpu_player, 0, r_back, 1, r_back);
    } else if (have_back_navy) {
        append_book_move_from_square(book, st, cpu_player, 0, r_back, 1, r_back);
    } else if (have_front_navy) {
        append_book_move_from_square(book, st, cpu_player, 0, r_front, 1, r_front);
    }
    // Delay non-capture AF flights in the very first turns.
    if (!very_early_opening) {
        append_book_move_from_square(book, st, cpu_player, 3, prow(7), 2, prow(7));
        append_book_move_from_square(book, st, cpu_player, 7, prow(7), 8, prow(7));
        append_book_move_from_square(book, st, cpu_player, 3, prow(7), 3, prow(8));
        append_book_move_from_square(book, st, cpu_player, 7, prow(7), 7, prow(8));
    }
    append_book_move_from_square(book, st, cpu_player, 5, prow(7), 5, prow(6));
    append_book_move_from_square(book, st, cpu_player, 4, prow(8), 4, prow(7));
    append_book_move_from_square(book, st, cpu_player, 6, prow(8), 6, prow(7));

    bool found = false;
    int best_score = -99999999;
    MoveTriple best{};
    const std::string stm_after = opp(cpu_player);
    for (auto& m : book) {
        if (!is_legal_book_move(st, cpu_player, m)) continue;
        PieceList np = apply_move(st.pieces, m.pid, m.dc, m.dr, cpu_player);
        if (has_immediate_winning_move(np, opp(cpu_player))) continue;
        int risk = opening_immediate_risk(np, cpu_player);
        if (risk >= 1000000) continue; // never allow immediate commander hangs
        int score = board_score(np, cpu_player, nullptr, &stm_after) - risk;
        if (!found || score > best_score) {
            best_score = score;
            best = m;
            found = true;
        }
    }
    if (found) { out = best; return true; }
    return false;
}

static AIResult cpu_pick_move(const PieceList& pieces, const std::string& cpu_player,
                               int max_depth, double time_limit_secs,
                               const std::atomic<bool>* stop_flag = nullptr,
                               ThreadData* td = nullptr) {
    const EngineConfig& cfg = get_engine_config();
    if (max_depth <= 0) max_depth = std::max(1, cfg.max_depth);
    if (time_limit_secs <= 0.0) {
        time_limit_secs = std::max(0.01, cfg.time_limit_ms / 1000.0);
    }

    struct StopFlagScope {
        const std::atomic<bool>* prev = nullptr;
        explicit StopFlagScope(const std::atomic<bool>* flag) : prev(g_stop_flag) { g_stop_flag = flag; }
        ~StopFlagScope() { g_stop_flag = prev; }
    } stop_scope(stop_flag);

    g_deadline = std::chrono::steady_clock::now() +
                 std::chrono::milliseconds((int)(time_limit_secs * 1000));
    auto soft_deadline = std::chrono::steady_clock::now() +
                         std::chrono::milliseconds((int)(time_limit_secs * 550));
    reset_time_state();
    g_nodes.store(0, std::memory_order_relaxed);

    SearchState root = make_search_state(pieces, cpu_player, cpu_player);
    // Seed search path with game-level repetition history so the engine
    // avoids moves that create threefold repetition with prior positions.
    seed_search_hash_path_from_history(g_game_rep_history, root.hash);
    AllMoves all_moves = all_moves_for(root.pieces, cpu_player);
    if (all_moves.empty()) return {false, {}};
    if (all_moves.size() == 1) return {true, all_moves[0]};  // easy move

    MoveTriple book_move{};
    if (g_use_opening_book && opening_book_pick(root, cpu_player, book_move)) {
        return {true, book_move};
    }

    // Keep deterministic root order for stronger, reproducible play.

    MoveTriple best = all_moves[0];
    int prev_score  = 0;
    int move_stability = 0;
    const bool opening_phase = (root.pieces.size() >= 34);
    const bool very_early_opening = (root.pieces.size() >= 36);
    const int base_opening_risk = opening_phase ? opening_immediate_risk(root.pieces, cpu_player) : 0;

    for (int cur_depth = 1; cur_depth <= max_depth; cur_depth++) {
        if (time_up()) break;

        // ── Aspiration Windows ────────────────────────────────────────────
        // Start with a tight window (δ=12 at depth≥5, δ=40 earlier).
        // Widen ASYMMETRICALLY: only expand in the direction of the failure,
        // which halves wasted re-searches vs the old symmetric ×2 approach.
        int delta = (cur_depth >= 5) ? 12 : 40;
        int alpha = (cur_depth > 1) ? prev_score - delta : -999999;
        int beta  = (cur_depth > 1) ? prev_score + delta :  999999;

        MoveTriple cur_best = best;
        int cur_best_val    = -999999;  // raw search value (for aspiration logic)
        int cur_best_rank   = -999999;  // style-adjusted root ranking
        bool completed      = false;

        while (!time_up()) {
            cur_best_val = -999999;
            cur_best_rank = -999999;
            cur_best     = best;

            MoveTriple root_hash_buf{};
            const MoveTriple* root_hash_move = nullptr;
            const TTEntry* rt = tt_probe(root.hash);
            if (rt) { root_hash_buf = tt_unpack_move(*rt); root_hash_move = &root_hash_buf; }

            MoveTriple root_pv_buf{};
            const MoveTriple* root_pv_move = nullptr;
            int rpv_len = td ? td->pv_len[0] : g_pv_len[0];
            if (rpv_len > 0) {
                root_pv_buf = td ? td->pv[0][0] : g_pv[0][0];
                root_pv_move = &root_pv_buf;
            }

            AllMoves root_moves = order_moves(all_moves, root.pieces, cpu_player, 0,
                                              root_hash_move ? root_hash_move : &best,
                                              root_pv_move, nullptr, td);

            int window_alpha = alpha;
            int window_beta  = beta;
            int root_move_idx = 0;
            for (auto& m : root_moves) {
                if (time_up()) break;
                int moved_idx = find_piece_idx_by_id(root.pieces, m.pid);
                std::string moved_kind = (moved_idx >= 0) ? root.pieces[moved_idx].kind : "";
                const Piece* root_target = piece_at_c(root.pieces, m.dc, m.dr);
                bool root_is_capture = (root_target && root_target->player != cpu_player);

                UndoMove u;
                if (!make_move_inplace(root, m, cpu_player, u)) continue;

                int root_risk = 0;
                bool opp_immediate_win = false;
                if (opening_phase) {
                    root_risk = opening_immediate_risk(root.pieces, cpu_player);
                    opp_immediate_win = has_immediate_winning_move(root.pieces, opp(cpu_player));
                    if (root_risk >= 1000000) { // never allow immediate commander hangs
                        unmake_move_inplace(root, u);
                        continue;
                    }
                }

                int val;
                if (root_move_idx == 0) {
                    // First move: full window search
                    val = alphabeta(root, cur_depth-1, window_alpha, window_beta,
                                    cpu_player, 1, true, &m, td);
                } else {
                    // PVS: zero-window search first
                    val = alphabeta(root, cur_depth-1, window_alpha, window_alpha+1,
                                    cpu_player, 1, true, &m, td);
                    // Re-search with full window if it beats alpha but doesn't reach beta
                    if (val > window_alpha && val < window_beta) {
                        val = alphabeta(root, cur_depth-1, window_alpha, window_beta,
                                        cpu_player, 1, true, &m, td);
                    }
                }

                int style_penalty = 0;
                if (opening_phase) {
                    style_penalty += root_risk / (very_early_opening ? 3 : 6);
                    if (opp_immediate_win) style_penalty += 250000;
                    if (very_early_opening && root_risk > base_opening_risk + 4500)
                        style_penalty += 900;  // avoid lines that newly hang key units
                    if (moved_kind == "Af" && !root_is_capture)
                        style_penalty += very_early_opening ? 280 : 120;
                    if (moved_kind == "Af" && root_risk > base_opening_risk)
                        style_penalty += 180;
                }
                int ranked = val - style_penalty;

                unmake_move_inplace(root, u);
                if (val > cur_best_val) cur_best_val = val;
                if (ranked > cur_best_rank) { cur_best_rank = ranked; cur_best = m; }
                window_alpha = std::max(window_alpha, val);
                root_move_idx++;
                // Beta cutoff: no need to search remaining root moves
                if (val >= window_beta) break;
            }

            if (time_up()) break;

            if      (cur_best_val <= alpha) { /* fail-low */ }
            else if (cur_best_val >= beta ) { /* fail-high */ }
            else { completed = true; break; }  // inside window — done

            // Widen window and retry — ASYMMETRIC: only expand in the fail direction.
            // Growth factor 1.44 + 5 gives geometric widening that converges faster
            // than the old ×2 approach while avoiding thrashing near the true score.
            delta = (int)(delta * 1.44f) + 5;
            if (cur_best_val <= alpha) alpha = std::max(-999999, cur_best_val - delta);
            else                       beta  = std::min( 999999, cur_best_val + delta);
            if (delta > 800) break; // give up on aspiration, accept result
        }

        if (completed) {
            MoveTriple old_best = best;
            best = cur_best;
            // Track best-move stability
            if (same_move(best, old_best)) move_stability++;
            else move_stability = 0;
            prev_score = cur_best_val;
            // Soft-stop: stable best move past soft deadline
            if (move_stability >= 3 && cur_depth >= 4 &&
                std::chrono::steady_clock::now() > soft_deadline) {
                break;
            }
        }
    }
    return {true, best};
}

// ═══════════════════════════════════════════════════════════════════════════
// LAZY SMP — Multi-threaded search
// ═══════════════════════════════════════════════════════════════════════════

static int g_smp_thread_count = 0; // 0 = auto-detect

static int smp_thread_count() {
#if !COMMANDER_ENABLE_THREADS
    return 1;
#else
    if (get_engine_config().force_single_thread) return 1;
    if (g_smp_thread_count > 0) return g_smp_thread_count;
    int hw = (int)std::thread::hardware_concurrency();
    if (hw <= 0) hw = 1;
    // Use all available hardware threads by default.
    return std::max(hw, 1);
#endif
}

struct SMPShared {
    std::atomic<bool>   stop{false};
    std::atomic<int>    best_score{-999999};
    EngineMutex         best_mutex;
    MoveTriple          best_move{};
    bool                best_found{false};
    std::chrono::steady_clock::time_point deadline;       // hard limit
    std::chrono::steady_clock::time_point soft_deadline;  // soft limit (stop if stable)
    std::atomic<int>    best_move_stability{0}; // consecutive iterations with same best move
    std::atomic<int>    last_best_pid{-1};
    std::atomic<int>    last_best_dc{-1};
    std::atomic<int>    last_best_dr{-1};
};

static void smp_worker(int thread_id, const PieceList& pieces,
                        const std::string& cpu_player,
                        int max_depth, SMPShared& shared) {
    init_lmr_table();
    reset_time_state();
    // Each thread gets its own ThreadData
    ThreadData td;
    td.thread_id = thread_id;
    td.reset();

    // Set up stop flag and deadline for this thread
    g_deadline = shared.deadline;

    SearchState root = make_search_state(pieces, cpu_player, cpu_player);
    seed_search_hash_path_from_history(g_game_rep_history, root.hash);
    AllMoves all_moves = all_moves_for(root.pieces, cpu_player);
    if (all_moves.empty()) return;

    // Diversify move ordering: thread 0 uses normal order, others shuffle early moves
    if (thread_id > 0 && all_moves.size() > 2) {
        std::mt19937 rng(thread_id * 7919 + 42);
        // Shuffle only the first few moves to diversify while keeping structure
        int shuffle_count = std::min((int)all_moves.size(), 4 + thread_id);
        for (int i = 0; i < shuffle_count - 1; i++) {
            std::uniform_int_distribution<int> dist(i, shuffle_count - 1);
            std::swap(all_moves[i], all_moves[dist(rng)]);
        }
    }

    MoveTriple best = all_moves[0];
    int prev_score = 0;
    const bool opening_phase = (root.pieces.size() >= 34);
    const bool very_early_opening = (root.pieces.size() >= 36);
    const int base_opening_risk = opening_phase ? opening_immediate_risk(root.pieces, cpu_player) : 0;

    // Threads at higher IDs can start from a deeper depth to diversify
    int start_depth = 1 + (thread_id % 2); // odd threads skip depth 1

    for (int cur_depth = start_depth; cur_depth <= max_depth; cur_depth++) {
        if (shared.stop.load(std::memory_order_relaxed)) break;
        if (std::chrono::steady_clock::now() > shared.deadline) break;

        // ── Aspiration Windows (Stockfish 18 tuning) ─────────────────────
        // δ=10 at depth≥6, δ=25 at depth 4-5, full window earlier.
        // Tighter than the old δ=40/60 values for less re-search waste.
        int delta;
        if (cur_depth >= 6)      delta = 10;
        else if (cur_depth >= 4) delta = 25;
        else                     delta = 60;
        int alpha = (cur_depth > start_depth) ? prev_score - delta : -999999;
        int beta  = (cur_depth > start_depth) ? prev_score + delta :  999999;

        MoveTriple cur_best = best;
        int cur_best_val    = -999999;
        int cur_best_rank   = -999999;
        bool completed      = false;

        while (!shared.stop.load(std::memory_order_relaxed) &&
               std::chrono::steady_clock::now() <= shared.deadline) {
            cur_best_val = -999999;
            cur_best_rank = -999999;
            cur_best = best;

            MoveTriple root_hash_buf{};
            const MoveTriple* root_hash_move = nullptr;
            const TTEntry* rt = tt_probe(root.hash);
            if (rt) { root_hash_buf = tt_unpack_move(*rt); root_hash_move = &root_hash_buf; }

            MoveTriple root_pv_buf{};
            const MoveTriple* root_pv_move = nullptr;
            if (td.pv_len[0] > 0) { root_pv_buf = td.pv[0][0]; root_pv_move = &root_pv_buf; }

            AllMoves root_moves = order_moves(all_moves, root.pieces, cpu_player, 0,
                                              root_hash_move ? root_hash_move : &best,
                                              root_pv_move, nullptr, &td);

            int window_alpha = alpha;
            int window_beta  = beta;
            int root_move_idx = 0;

            for (auto& m : root_moves) {
                if (shared.stop.load(std::memory_order_relaxed)) break;
                if (std::chrono::steady_clock::now() > shared.deadline) break;

                int moved_idx = find_piece_idx_by_id(root.pieces, m.pid);
                std::string moved_kind = (moved_idx >= 0) ? root.pieces[moved_idx].kind : "";
                const Piece* root_target = piece_at_c(root.pieces, m.dc, m.dr);
                bool root_is_capture = (root_target && root_target->player != cpu_player);

                UndoMove u;
                if (!make_move_inplace(root, m, cpu_player, u)) continue;

                int root_risk = 0;
                bool opp_immediate_win = false;
                if (opening_phase) {
                    root_risk = opening_immediate_risk(root.pieces, cpu_player);
                    opp_immediate_win = has_immediate_winning_move(root.pieces, opp(cpu_player));
                    if (root_risk >= 1000000) {
                        unmake_move_inplace(root, u);
                        continue;
                    }
                }

                int val;
                if (root_move_idx == 0) {
                    val = alphabeta(root, cur_depth-1, window_alpha, window_beta,
                                    cpu_player, 1, true, &m, &td);
                } else {
                    // PVS: zero-window search first
                    val = alphabeta(root, cur_depth-1, window_alpha, window_alpha+1,
                                    cpu_player, 1, true, &m, &td);
                    if (val > window_alpha && val < window_beta) {
                        val = alphabeta(root, cur_depth-1, window_alpha, window_beta,
                                        cpu_player, 1, true, &m, &td);
                    }
                }

                int style_penalty = 0;
                if (opening_phase) {
                    style_penalty += root_risk / (very_early_opening ? 3 : 6);
                    if (opp_immediate_win) style_penalty += 250000;
                    if (very_early_opening && root_risk > base_opening_risk + 4500)
                        style_penalty += 900;
                    if (moved_kind == "Af" && !root_is_capture)
                        style_penalty += very_early_opening ? 280 : 120;
                    if (moved_kind == "Af" && root_risk > base_opening_risk)
                        style_penalty += 180;
                }
                int ranked = val - style_penalty;

                unmake_move_inplace(root, u);
                if (val > cur_best_val) cur_best_val = val;
                if (ranked > cur_best_rank) { cur_best_rank = ranked; cur_best = m; }
                window_alpha = std::max(window_alpha, val);
                root_move_idx++;
                if (val >= window_beta) break;
            }

            if (shared.stop.load(std::memory_order_relaxed)) break;
            if (std::chrono::steady_clock::now() > shared.deadline) break;

            if (cur_best_val <= alpha) { /* fail-low */ }
            else if (cur_best_val >= beta) { /* fail-high */ }
            else { completed = true; break; }

            // ── Asymmetric aspiration widening (Stockfish 18 style) ────────
            // Only expand in the direction of failure; 1.44× growth + 5
            // converges faster than the old ×2 symmetric expansion and
            // wastes fewer re-searches when score drifts in one direction.
            delta = (int)(delta * 1.44f) + 5;
            if (cur_best_val <= alpha) alpha = std::max(-999999, cur_best_val - delta);
            else                       beta  = std::min( 999999, cur_best_val + delta);
            if (delta > 800) break;
        }

        if (completed) best = cur_best;
        if (completed) prev_score = cur_best_val;

        // Report to shared best if this thread found something good
        if (completed) {
            int global_best = shared.best_score.load(std::memory_order_relaxed);
            if (cur_best_val > global_best || !shared.best_found) {
                std::lock_guard<EngineMutex> lk(shared.best_mutex);
                if (cur_best_val > shared.best_score.load(std::memory_order_relaxed) ||
                    !shared.best_found) {
                    shared.best_score.store(cur_best_val, std::memory_order_relaxed);
                    shared.best_move = best;
                    shared.best_found = true;
                }
            }

            // ── Best-move stability tracking (thread 0 only) ────────────
            if (thread_id == 0 && completed) {
                int prev_pid = shared.last_best_pid.load(std::memory_order_relaxed);
                int prev_dc  = shared.last_best_dc.load(std::memory_order_relaxed);
                int prev_dr  = shared.last_best_dr.load(std::memory_order_relaxed);
                bool move_changed = !(best.pid == prev_pid && best.dc == prev_dc && best.dr == prev_dr);
                if (!move_changed) {
                    shared.best_move_stability.fetch_add(1, std::memory_order_relaxed);
                } else {
                    shared.best_move_stability.store(0, std::memory_order_relaxed);
                    // ── SF18-style node-count time extension ─────────────────
                    // When the best move changes, the position is tactically
                    // complex: extend the soft deadline by 25% (capped at hard).
                    // This mirrors Stockfish 18's "bestMoveChanges" time manager.
                    if (cur_depth >= 4) {
                        std::lock_guard<EngineMutex> lk(shared.best_mutex);
                        auto now = std::chrono::steady_clock::now();
                        auto remaining = shared.deadline - now;
                        auto extension = remaining / 4;  // 25% of remaining time
                        auto new_soft = shared.soft_deadline + extension;
                        // Never push soft past hard limit
                        if (new_soft < shared.deadline)
                            shared.soft_deadline = new_soft;
                    }
                }
                shared.last_best_pid.store(best.pid, std::memory_order_relaxed);
                shared.last_best_dc.store(best.dc, std::memory_order_relaxed);
                shared.last_best_dr.store(best.dr, std::memory_order_relaxed);

                // ── Soft-stop: stable best move past soft deadline → stop ────
                int stability = shared.best_move_stability.load(std::memory_order_relaxed);
                if (stability >= 3 && cur_depth >= 4 &&
                    std::chrono::steady_clock::now() > shared.soft_deadline) {
                    shared.stop.store(true, std::memory_order_relaxed);
                }
            }
        }
    }
}

static AIResult smp_cpu_pick_move(const PieceList& pieces, const std::string& cpu_player,
                                   int max_depth, double time_limit_secs,
                                   const std::atomic<bool>* external_stop = nullptr) {
    // Opening book check (single-threaded)
    {
        SearchState root = make_search_state(pieces, cpu_player, cpu_player);
        AllMoves all_moves = all_moves_for(root.pieces, cpu_player);
        if (all_moves.empty()) return {false, {}};
        MoveTriple book_move{};
        if (g_use_opening_book && opening_book_pick(root, cpu_player, book_move)) {
            return {true, book_move};
        }
        // ── Easy move: only one legal move → use minimal time ────────────
        if (all_moves.size() == 1) {
            return {true, all_moves[0]};
        }
    }

    g_tt_age++;
    g_nodes.store(0, std::memory_order_relaxed);

    int num_threads = smp_thread_count();
    if (num_threads < 1) num_threads = 1;
    if (get_engine_config().force_single_thread) num_threads = 1; // WASM-SAFE

    // ── Dynamic Time Management ──────────────────────────────────────────
    // soft_limit: ideal time (stop if stable), hard_limit: absolute max
    double soft_limit = time_limit_secs * 0.55;
    double hard_limit = time_limit_secs;
    auto search_start = std::chrono::steady_clock::now();

    SMPShared shared;
    shared.deadline = search_start +
                      std::chrono::milliseconds((int)(hard_limit * 1000));
    shared.soft_deadline = search_start +
                           std::chrono::milliseconds((int)(soft_limit * 1000));
    g_deadline = shared.deadline;

    auto run_worker = [&](int thread_id) {
        g_stop_flag = external_stop;
        g_deadline = shared.deadline;
        reset_time_state();
        smp_worker(thread_id, pieces, cpu_player, max_depth, shared);
    };

    if (num_threads <= 1) {
        run_worker(0);
    } else {
#if COMMANDER_ENABLE_THREADS
        std::vector<std::thread> threads;
        threads.reserve(num_threads);
        for (int i = 0; i < num_threads; i++) {
            threads.emplace_back([&, i]() { run_worker(i); });
        }
        for (auto& t : threads) {
            if (t.joinable()) t.join();
        }
#else
        run_worker(0);
#endif
    }

    if (shared.best_found)
        return {true, shared.best_move};

    return {false, {}};
}
// COORDINATE HELPERS
// ═══════════════════════════════════════════════════════════════════════════

static int cx(int col) { return PAD + col*CELL; }
static int cy(int row) { return PAD + (ROWS-1-row)*CELL; }

static void canvas_to_board(int px, int py, int& col, int& row) {
    col = (int)std::round((float)(px - PAD) / CELL);
    row = ROWS - 1 - (int)std::round((float)(py - PAD) / CELL);
}

// ═══════════════════════════════════════════════════════════════════════════
// TEXTURE LOADING FROM EMBEDDED BASE64
// ═══════════════════════════════════════════════════════════════════════════

static std::map<std::string, SDL_Texture*> g_textures;
static std::map<std::string, SDL_Texture*> g_textures_small;

static SDL_Texture* load_texture_from_b64(SDL_Renderer* ren, const std::string& key, int target_size) {
    auto it = PIECE_B64.find(key);
    if (it == PIECE_B64.end()) return nullptr;

    std::vector<uint8_t> png_data = base64_decode(it->second);
    SDL_RWops* rw = SDL_RWFromMem(png_data.data(), (int)png_data.size());
    if (!rw) return nullptr;

    SDL_Surface* surf = IMG_LoadPNG_RW(rw);
    SDL_RWclose(rw);
    if (!surf) return nullptr;

    // Scale to target_size x target_size
    SDL_Surface* scaled = SDL_CreateRGBSurfaceWithFormat(0, target_size, target_size, 32, SDL_PIXELFORMAT_RGBA32);
    SDL_BlitScaled(surf, nullptr, scaled, nullptr);
    SDL_FreeSurface(surf);

    SDL_Texture* tex = SDL_CreateTextureFromSurface(ren, scaled);
    SDL_FreeSurface(scaled);
    return tex;
}

static void load_all_textures(SDL_Renderer* ren) {
    for (auto& kv : PIECE_B64) {
        SDL_Texture* t = load_texture_from_b64(ren, kv.first, 50);
        if (t) g_textures[kv.first] = t;
        SDL_Texture* ts = load_texture_from_b64(ren, kv.first, 20);
        if (ts) g_textures_small[kv.first] = ts;
    }
}
// GAME STATE
// ═══════════════════════════════════════════════════════════════════════════

enum class GameState { HUMAN_TURN, CPU_THINKING, GAME_OVER };

struct MoveRecord {
    int from_c = 0;
    int from_r = 0;
    int to_c = 0;
    int to_r = 0;
    bool capture = false;
    std::string player = "red";
};

struct Game {
    PieceList pieces;
    std::string current;
    int selected_id = -1;
    std::vector<Move2> valid_moves;
    GameState state = GameState::HUMAN_TURN;
    std::string win_msg;
    std::vector<std::string> move_log;
    std::vector<MoveRecord> move_records;
    std::vector<PieceList> state_history;      // board snapshot at ply index (0 = initial)
    std::vector<std::string> turn_history;     // side-to-move for each snapshot
    std::vector<uint64_t> position_history;
    int cpu_depth = 6;
    double cpu_time_limit = 3.0;
    std::string status_msg;
    int difficulty = 1; // 0=Easy, 1=Medium, 2=Hard
    GameMode selected_mode = GameMode::FULL_BATTLE;
    bool show_mode_menu = true;
    std::string human_player = "red";
    std::string cpu_player = "blue";
    std::string menu_side_choice = "red";
    bool menu_side_chosen = false;
    bool has_last_move = false;
    int last_from_c = 0;
    int last_from_r = 0;
    int last_to_c = 0;
    int last_to_r = 0;
    bool last_move_capture = false;
    std::string last_move_player = "red";
    int review_index = -1; // -1 = live board, else index into state_history

    // === CHANGED ===
    // CPU async (WASM-SAFE: synchronous fallback when threads are disabled).
#if COMMANDER_ENABLE_THREADS
    std::thread cpu_thread;
#endif
    EngineMutex cpu_mutex;
    std::atomic<bool> cpu_stop{false};
    bool cpu_done = false;
    AIResult cpu_result;

    Game() {
        pieces = make_initial_pieces();
        current = "red";
        state_history.clear();
        turn_history.clear();
        state_history.push_back(pieces);
        turn_history.push_back(current);
        position_history.clear();
        push_position_history(position_history, zobrist_hash(pieces, current));
        set_difficulty(difficulty);
        g_game_mode = selected_mode;
        status_msg = "Select mode, choose side, then click START GAME";
    }
    ~Game() { stop_cpu(); }

    void stop_cpu() {
        cpu_stop.store(true, std::memory_order_relaxed);
#if COMMANDER_ENABLE_THREADS
        if (cpu_thread.joinable()) cpu_thread.join();
#endif
        cpu_stop.store(false, std::memory_order_relaxed);
    }

    void set_difficulty(int d) {
        difficulty = d;
        EngineConfig cfg = get_engine_config();
        if (d==0) {
            cpu_depth=4; cpu_time_limit=2.5;
            cfg.use_mcts=false;
            cfg.max_depth=cpu_depth;
            cfg.time_limit_ms=(int)(cpu_time_limit * 1000.0);
        } else if (d==1) {
            cpu_depth=6; cpu_time_limit=3.0;
            cfg.use_mcts=false;
            cfg.max_depth=cpu_depth;
            cfg.time_limit_ms=(int)(cpu_time_limit * 1000.0);
        } else {
            cpu_depth=8; cpu_time_limit=8.0;
            cfg.use_mcts=true;
            cfg.max_depth=cpu_depth;
            cfg.time_limit_ms=(int)(cpu_time_limit * 1000.0);
        }
#if !COMMANDER_ENABLE_THREADS
        cfg.force_single_thread = true;
#endif
        set_engine_config(cfg);
    }

    void set_game_mode(GameMode mode) {
        selected_mode = mode;
        if (show_mode_menu) {
            if (menu_side_chosen) {
                status_msg = std::string("Mode selected: ") + game_mode_name(selected_mode) +
                             " | YOU = " + (menu_side_choice == "red" ? "RED" : "BLUE") +
                             " (click START GAME)";
            } else {
                status_msg = std::string("Mode selected: ") + game_mode_name(selected_mode) +
                             " (choose side, then START GAME)";
            }
        } else {
            status_msg = std::string("Mode selected: ") + game_mode_name(selected_mode) + " (applies on New Game)";
        }
    }

    void set_player_side(const std::string& side) {
        if (side != "red" && side != "blue") return;
        menu_side_choice = side;
        menu_side_chosen = true;
        if (show_mode_menu) {
            status_msg = std::string("Side selected: YOU = ") +
                         (side == "red" ? "RED" : "BLUE") +
                         " (click START GAME)";
        }
    }

    void open_mode_menu() {
        stop_cpu();
        show_mode_menu = true;
        review_index = -1;
        state = GameState::HUMAN_TURN;
        selected_id = -1;
        valid_moves.clear();
        win_msg.clear();
        menu_side_choice = human_player;
        menu_side_chosen = false;
        status_msg = std::string("Select mode: ") + game_mode_name(selected_mode) +
                     " — choose side, then START GAME";
    }

    void start_selected_mode_game() {
        if (!menu_side_chosen) {
            status_msg = "Choose your side first (RED or BLUE), then START GAME";
            return;
        }
        human_player = menu_side_choice;
        cpu_player = opp(human_player);
        show_mode_menu = false;
        new_game();
    }

    void set_status(const char* msg) {
        if (msg) { status_msg = msg; return; }
        if (current == human_player) {
            status_msg = std::string("Your turn (") +
                         (human_player == "red" ? "RED" : "BLUE") +
                         ") — select a piece to move";
        } else {
            status_msg = std::string("CPU thinking (") +
                         (cpu_player == "red" ? "RED" : "BLUE") +
                         ")...";
        }
    }

    Piece* get_piece(int id) {
        for (auto& p : pieces) if (p.id==id) return &p;
        return nullptr;
    }

    const PieceList& board_for_render() const {
        if (review_index >= 0 && review_index < (int)state_history.size())
            return state_history[review_index];
        return pieces;
    }

    bool is_reviewing() const {
        return review_index >= 0 && review_index < (int)state_history.size();
    }

    void set_review_status() {
        if (!is_reviewing()) return;
        if (review_index <= 0 || move_records.empty()) {
            status_msg = "Reviewing initial setup — use < > arrows or click board for LIVE";
            return;
        }
        int mv = review_index - 1;
        if (mv < 0 || mv >= (int)move_records.size()) {
            status_msg = "Reviewing history — use < > arrows or click board for LIVE";
            return;
        }
        const MoveRecord& mr = move_records[mv];
        status_msg = "Reviewing move " + std::to_string(mv + 1) + "/" +
                     std::to_string(move_records.size()) +
                     " (" + (mr.player == "red" ? "RED" : "BLUE") +
                     ") — use < > arrows or click board for LIVE";
    }

    void exit_review_mode() {
        if (!is_reviewing()) return;
        review_index = -1;
        set_status(nullptr);
    }

    void review_move_at(int move_idx) {
        if (move_idx < 0 || move_idx >= (int)move_records.size()) return;
        if (move_idx == (int)move_records.size() - 1) {
            // Clicking latest move snaps back to live board.
            exit_review_mode();
            return;
        }
        int target = move_idx + 1; // snapshot after this move
        if (target < 0 || target >= (int)state_history.size()) return;
        review_index = target;
        selected_id = -1;
        valid_moves.clear();
        set_review_status();
    }

    void review_prev_move() {
        if (state_history.size() <= 1) return;
        if (!is_reviewing()) {
            review_index = (int)state_history.size() - 2; // move before live
        } else if (review_index > 0) {
            review_index -= 1;
        }
        selected_id = -1;
        valid_moves.clear();
        set_review_status();
    }

    void review_next_move() {
        if (!is_reviewing()) return;
        int live_idx = (int)state_history.size() - 1;
        if (review_index >= live_idx - 1) {
            exit_review_mode(); // next from latest reviewed move -> live
            return;
        }
        review_index += 1;
        selected_id = -1;
        valid_moves.clear();
        set_review_status();
    }

    void new_game() {
        stop_cpu();
        g_game_mode = selected_mode;
        pieces = make_initial_pieces();
        current = "red"; // Red always starts; CPU may move first if user picked Blue.
        selected_id = -1;
        valid_moves.clear();
        state = GameState::HUMAN_TURN;
        win_msg.clear();
        move_log.clear();
        move_records.clear();
        has_last_move = false;
        review_index = -1;
        state_history.clear();
        turn_history.clear();
        state_history.push_back(pieces);
        turn_history.push_back(current);
        position_history.clear();
        push_position_history(position_history, zobrist_hash(pieces, current));
        cpu_done = false;
        reset_search_tables();
        if (current == cpu_player) {
            state = GameState::CPU_THINKING;
            status_msg = g_use_mcts ? "CPU thinking (MCTS)..." : "CPU is thinking...";
            play_sound("cpu");
            start_cpu_move();
        } else {
            set_status(nullptr);
        }
    }

    void on_click(int px, int py) {
        if (is_reviewing()) {
            exit_review_mode();
            return;
        }
        if (state != GameState::HUMAN_TURN) return;
        int col, row;
        canvas_to_board(px, py, col, row);
        if (!on_board(col,row)) { selected_id=-1; valid_moves.clear(); set_status(nullptr); return; }

        // If something selected and clicked valid move destination
        if (selected_id >= 0) {
            for (auto& m : valid_moves) {
                if (m.first==col && m.second==row) {
                    execute_move(col,row,false);
                    return;
                }
            }
        }

        // Select piece (cycle through stacked same-square pieces on repeated click).
        std::vector<Piece*> stack_candidates;
        for (auto& p : pieces) {
            if (p.player == current && p.col == col && p.row == row) stack_candidates.push_back(&p);
        }
        if (!stack_candidates.empty()) {
            Piece* clicked = stack_candidates[0];
            if (stack_candidates.size() > 1) {
                int cur_idx = -1;
                for (int i = 0; i < (int)stack_candidates.size(); i++) {
                    if (stack_candidates[i]->id == selected_id) { cur_idx = i; break; }
                }
                if (cur_idx >= 0) clicked = stack_candidates[(cur_idx + 1) % (int)stack_candidates.size()];
            }
            selected_id = clicked->id;
            valid_moves = get_moves(*clicked, pieces);
            if (valid_moves.empty()) play_sound("invalid");
            std::string nm = std::to_string(valid_moves.size());
            status_msg = "Selected " + PIECE_DEF[clicked->kind].name +
                         (clicked->hero ? " ★" : "") +
                         " — " + nm + " move" + (valid_moves.size()!=1?"s":"");
        } else {
            selected_id = -1; valid_moves.clear(); set_status(nullptr);
        }
    }

    void execute_move(int dc, int dr, bool is_cpu) {
        Piece* piece = get_piece(selected_id);
        if (!piece) return;
        if (!has_legal_destination(*piece, pieces, dc, dr)) {
            play_sound("invalid");
            return;
        }
        Piece before_piece = *piece;
        Piece* target = piece_at(pieces, dc, dr);

        std::string log = (is_cpu?"CPU ":"YOU ") + piece->kind +
                          "(" + std::to_string(piece->col) + "," + std::to_string(piece->row) + ")" +
                          "->(" + std::to_string(dc) + "," + std::to_string(dr) + ")";

        int enemy_before = 0;
        int own_before = 0;
        for (const auto& p : pieces) {
            if (p.player == current) own_before++;
            else enemy_before++;
        }

        if (target && target->player != current) log += " x" + target->kind;
        pieces = apply_move(pieces, selected_id, dc, dr, current);

        int enemy_after = 0;
        int own_after = 0;
        for (const auto& p : pieces) {
            if (p.player == current) own_after++;
            else enemy_after++;
        }
        bool is_capture = (enemy_after < enemy_before);
        bool self_lost_piece = (own_after < own_before);
        MoveRecord rec;
        rec.from_c = before_piece.col;
        rec.from_r = before_piece.row;
        rec.to_c = dc;
        rec.to_r = dr;
        rec.capture = is_capture;
        rec.player = current;
        has_last_move = true;
        last_from_c = before_piece.col;
        last_from_r = before_piece.row;
        last_to_c = dc;
        last_to_r = dr;
        last_move_capture = is_capture;
        last_move_player = current;

        Piece* after_piece = get_piece(selected_id);
        if (before_piece.kind == "Af" && is_capture && self_lost_piece && !after_piece) {
            log += " (kamikaze)";
            play_sound("boom");
        } else {
            play_sound(is_capture ? "capture" : "move");
        }

        if (after_piece && !before_piece.hero && after_piece->hero) {
            log += " *HERO";
            play_sound("hero");
        }
        if (after_piece && before_piece.kind == "Af" &&
            before_piece.col == after_piece->col && before_piece.row == after_piece->row &&
            is_capture && (dc != before_piece.col || dr != before_piece.row)) {
            log += " @RETURN";
        }

        finish_turn(log, rec);
    }

    void finish_turn(const std::string& log, const MoveRecord& rec) {
        if (is_reviewing()) review_index = -1;
        move_log.push_back(log);
        move_records.push_back(rec);

        std::string wm = check_win(pieces, current);
        if (!wm.empty()) {
            state_history.push_back(pieces);
            turn_history.push_back(opp(current));
            state = GameState::GAME_OVER;
            win_msg = wm;
            selected_id=-1; valid_moves.clear();
            play_sound("win");
            return;
        }

        current = opp(current);
        state_history.push_back(pieces);
        turn_history.push_back(current);
        uint64_t cur_hash = zobrist_hash(pieces, current);
        push_position_history(position_history, cur_hash);
        if (is_threefold_repetition(position_history, cur_hash)) {
            state = GameState::GAME_OVER;
            win_msg = "Draw — threefold repetition.";
            selected_id = -1;
            valid_moves.clear();
            return;
        }

        selected_id=-1; valid_moves.clear();
        set_status(nullptr);

        if (current == cpu_player) {
            state = GameState::CPU_THINKING;
            status_msg = g_use_mcts ? "CPU thinking (MCTS)..." : "CPU is thinking...";
            play_sound("cpu");
            start_cpu_move();
        }
    }

    void start_cpu_move() {
        stop_cpu();
        {
            std::lock_guard<EngineMutex> lk(cpu_mutex);
            cpu_done = false;
        }
        PieceList pieces_copy = pieces;
        std::string cpu_pl = cpu_player;
        int depth = cpu_depth;
        double tlimit = cpu_time_limit;

        auto run_cpu_search = [this, pieces_copy, cpu_pl, depth, tlimit]() {
            try {
                reset_search_tables();
                g_game_rep_history = position_history;  // let search see game repetition history
                AIResult res;
                if (g_use_mcts) {
                    // Hard difficulty: MCTS-guided root with AB value function
                    // Opening book is checked inside smp_cpu_pick_move, but we
                    // also check it here so MCTS skips it.
                    {
                        SearchState root_st = make_search_state(pieces_copy, cpu_pl, cpu_pl);
                        MoveTriple book_mv{};
                        if (g_use_opening_book && opening_book_pick(root_st, cpu_pl, book_mv)) {
                            if (!cpu_stop.load(std::memory_order_relaxed)) {
                                std::lock_guard<EngineMutex> lk(cpu_mutex);
                                cpu_result = {true, book_mv};
                                cpu_done   = true;
                            }
                            return;
                        }
                    }
                    // Run MCTS+AB for the bulk of the time, then verify the
                    // top candidate with a final deeper SMP pass on the last 30%.
                    double mcts_time = tlimit * 0.70;
                    double verify_time = tlimit * 0.28;
                    res = mcts_ab_root_search(pieces_copy, cpu_pl,
                                              engine_mcts_ab_depth(), mcts_time, &cpu_stop);
                    // If MCTS found a move, run quick SMP verification
                    if (res.found && !cpu_stop.load(std::memory_order_relaxed)) {
                        // Hint: put MCTS best move into TT so SMP searches it first
                        // (it's already there from MCTS AB calls, so just re-search)
                        AIResult verify = smp_cpu_pick_move(pieces_copy, cpu_pl,
                                                            depth, verify_time, &cpu_stop);
                        // Prefer the deeper AB result if it finds a move
                        if (verify.found) res = verify;
                    }
                } else {
                    res = smp_cpu_pick_move(pieces_copy, cpu_pl, depth, tlimit, &cpu_stop);
                }
                if (cpu_stop.load(std::memory_order_relaxed)) return;
                std::lock_guard<EngineMutex> lk(cpu_mutex);
                if (cpu_stop.load(std::memory_order_relaxed)) return;
                cpu_result = res;
                cpu_done = true;
            } catch (...) {
                std::lock_guard<EngineMutex> lk(cpu_mutex);
                cpu_result = {false, {}};
                cpu_done = true;
            }
        };

#if COMMANDER_ENABLE_THREADS
        cpu_thread = std::thread(run_cpu_search);
#else
        // WASM-SAFE: no detached worker threads in browser runtime.
        run_cpu_search();
#endif
    }

    void check_cpu_done() {
        if (state != GameState::CPU_THINKING) return;
        std::lock_guard<EngineMutex> lk(cpu_mutex);
        if (!cpu_done) return;
        cpu_done = false;

        if (!cpu_result.found) {
            current = human_player;
            state = GameState::HUMAN_TURN;
            set_status(nullptr);
            return;
        }

        MoveTriple& m = cpu_result.move;
        Piece* piece = get_piece(m.pid);
        if (!piece) {
            current = human_player;
            state = GameState::HUMAN_TURN;
            set_status(nullptr);
            return;
        }

        selected_id = piece->id;
        execute_move(m.dc, m.dr, true);
        if (state != GameState::GAME_OVER) {
            state = GameState::HUMAN_TURN;
            set_status(nullptr);
        }
    }
};

// ═══════════════════════════════════════════════════════════════════════════
// FONT SYSTEM  (SDL2_ttf)
// ═══════════════════════════════════════════════════════════════════════════

static TTF_Font* g_fnt_sm   = nullptr;  //  9pt  coords, log, small labels
static TTF_Font* g_fnt_md   = nullptr;  // 11pt  panel body
static TTF_Font* g_fnt_lg   = nullptr;  // 14pt  status bar text
static TTF_Font* g_fnt_xl   = nullptr;  // 20pt  title / game-over
static TTF_Font* g_fnt_btn  = nullptr;  // 12pt  buttons
static TTF_Font* g_fnt_head = nullptr;  // 12pt  panel section headings (bold)

static bool init_fonts() {
    if (TTF_Init() != 0) return false;

    // Bold monospace (coords, log)
    const char* mono[] = {
        // macOS — system fonts
        "/System/Library/Fonts/Supplemental/CourierNewBold.ttf",
        "/Library/Fonts/Courier New Bold.ttf",
        "/System/Library/Fonts/Monaco.ttf",
        "/System/Library/Fonts/Menlo.ttc",
        // macOS — Homebrew
        "/opt/homebrew/share/fonts/truetype/dejavu/DejaVuSansMono-Bold.ttf",
        "/usr/local/share/fonts/truetype/dejavu/DejaVuSansMono-Bold.ttf",
        // Linux
        "/usr/share/fonts/truetype/dejavu/DejaVuSansMono-Bold.ttf",
        "/usr/share/fonts/truetype/liberation/LiberationMono-Bold.ttf",
        "/usr/share/fonts/truetype/ubuntu/UbuntuMono-B.ttf",
        "/usr/share/fonts/TTF/DejaVuSansMono-Bold.ttf",
        // Windows
        "C:\\Windows\\Fonts\\consola.ttf",
        "C:\\Windows\\Fonts\\courbd.ttf",
        nullptr
    };
    // Bold sans-serif (headings, status, title)
    const char* sans[] = {
        // macOS
        "/System/Library/Fonts/HelveticaNeue.ttc",
        "/System/Library/Fonts/Helvetica.ttc",
        "/System/Library/Fonts/SFNS.ttf",
        "/System/Library/Fonts/SFNSDisplay.ttf",
        "/Library/Fonts/Arial Bold.ttf",
        "/System/Library/Fonts/Supplemental/Arial Bold.ttf",
        // macOS — Homebrew
        "/opt/homebrew/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf",
        "/usr/local/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf",
        // Linux
        "/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf",
        "/usr/share/fonts/truetype/liberation/LiberationSans-Bold.ttf",
        "/usr/share/fonts/truetype/ubuntu/Ubuntu-B.ttf",
        "/usr/share/fonts/TTF/DejaVuSans-Bold.ttf",
        // Windows
        "C:\\Windows\\Fonts\\arialbd.ttf",
        "C:\\Windows\\Fonts\\arial.ttf",
        nullptr
    };

    auto try_load = [](const char** list, int pt) -> TTF_Font* {
        for (int i = 0; list[i]; i++) {
            TTF_Font* f = TTF_OpenFont(list[i], pt);
            if (f) return f;
        }
        return nullptr;
    };
    auto load2 = [&](const char** a, const char** b, int pt) -> TTF_Font* {
        TTF_Font* f = try_load(a, pt);
        return f ? f : try_load(b, pt);
    };

    g_fnt_sm   = load2(mono, sans, 9);
    g_fnt_md   = load2(mono, sans, 11);
    g_fnt_lg   = load2(sans, mono, 14);
    g_fnt_xl   = load2(sans, mono, 20);
    g_fnt_btn  = load2(sans, mono, 12);
    g_fnt_head = load2(sans, mono, 11);
    return true;
}

// ── Text drawing helpers ──────────────────────────────────────────────────
// x/cy_ = anchor;  align: -1=left  0=center  +1=right
static void draw_text(SDL_Renderer* r, TTF_Font* fnt, const char* txt,
                      int x, int cy_, SDL_Color c, int align = 0) {
    if (!fnt) return;
    if (!txt || !*txt) return;
    SDL_Surface* s = TTF_RenderUTF8_Blended(fnt, txt, c);
    if (!s) return;
    SDL_Texture* t = SDL_CreateTextureFromSurface(r, s);
    int tw = s->w, th = s->h;
    SDL_FreeSurface(s);
    if (!t) return;
    int dx = (align == 0) ? x - tw/2 : (align < 0 ? x : x - tw);
    SDL_Rect dst = {dx, cy_ - th/2, tw, th};
    SDL_RenderCopy(r, t, nullptr, &dst);
    SDL_DestroyTexture(t);
}
static void dtc(SDL_Renderer* r, TTF_Font* f, const char* t, int x, int y, SDL_Color c)
    { draw_text(r, f, t, x, y, c,  0); }
static void dtl(SDL_Renderer* r, TTF_Font* f, const char* t, int x, int y, SDL_Color c)
    { draw_text(r, f, t, x, y, c, -1); }

// ═══════════════════════════════════════════════════════════════════════════
// PRIMITIVE HELPERS
// ═══════════════════════════════════════════════════════════════════════════

static void set_draw_color(SDL_Renderer* r, Color c) {
    SDL_SetRenderDrawColor(r, c.r, c.g, c.b, c.a);
}
static void fill_rect(SDL_Renderer* r, int x, int y, int w, int h) {
    SDL_Rect rc = {x,y,w,h}; SDL_RenderFillRect(r, &rc);
}
static void draw_rect(SDL_Renderer* r, int x, int y, int w, int h) {
    SDL_Rect rc = {x,y,w,h}; SDL_RenderDrawRect(r, &rc);
}
static void draw_circle(SDL_Renderer* r, int cx_, int cy_, int radius) {
    int x=radius, y=0, err=0;
    while (x >= y) {
        SDL_RenderDrawPoint(r,cx_+x,cy_+y); SDL_RenderDrawPoint(r,cx_-x,cy_+y);
        SDL_RenderDrawPoint(r,cx_+x,cy_-y); SDL_RenderDrawPoint(r,cx_-x,cy_-y);
        SDL_RenderDrawPoint(r,cx_+y,cy_+x); SDL_RenderDrawPoint(r,cx_-y,cy_+x);
        SDL_RenderDrawPoint(r,cx_+y,cy_-x); SDL_RenderDrawPoint(r,cx_-y,cy_-x);
        y++; if (err<=0) err+=2*y+1; if (err>0) { x--; err-=2*x+1; }
    }
}
static void fill_circle(SDL_Renderer* r, int cx_, int cy_, int radius) {
    for (int y = -radius; y <= radius; y++) {
        int dx = (int)sqrtf(float(radius*radius - y*y));
        SDL_RenderDrawLine(r, cx_-dx, cy_+y, cx_+dx, cy_+y);
    }
}
static void draw_dashed_circle(SDL_Renderer* r, int cx_, int cy_, int rad, int seg=8) {
    int n = std::max(4, (int)(2*M_PI*rad/seg));
    for (int i = 0; i < n; i += 2) {
        float a0 = 2*M_PI*i/n, a1 = 2*M_PI*(i+1)/n;
        SDL_RenderDrawLine(r,
            (int)(cx_+cosf(a0)*rad), (int)(cy_+sinf(a0)*rad),
            (int)(cx_+cosf(a1)*rad), (int)(cy_+sinf(a1)*rad));
    }
}
static void hline(SDL_Renderer* r, int x0, int y, int x1, int lw=1) {
    for (int i=0; i<lw; i++) SDL_RenderDrawLine(r, x0, y+i, x1, y+i);
}
static void vline(SDL_Renderer* r, int x, int y0, int y1, int lw=1) {
    for (int i=0; i<lw; i++) SDL_RenderDrawLine(r, x+i, y0, x+i, y1);
}

static void draw_thick_line(SDL_Renderer* r, int x0, int y0, int x1, int y1, int thickness) {
    if (thickness <= 1) {
        SDL_RenderDrawLine(r, x0, y0, x1, y1);
        return;
    }
    float dx = float(x1 - x0);
    float dy = float(y1 - y0);
    float len = std::sqrt(dx * dx + dy * dy);
    if (len < 0.5f) {
        fill_circle(r, x0, y0, std::max(1, thickness / 2));
        return;
    }
    float nx = -dy / len;
    float ny = dx / len;
    int half = thickness / 2;
    for (int i = -half; i <= half; i++) {
        int ox = (int)std::lround(nx * i);
        int oy = (int)std::lround(ny * i);
        SDL_RenderDrawLine(r, x0 + ox, y0 + oy, x1 + ox, y1 + oy);
    }
}

static void draw_arrow_head(SDL_Renderer* r, int tx, int ty, float ux, float uy, int size, int thickness) {
    float base_x = tx - ux * size;
    float base_y = ty - uy * size;
    float px = -uy;
    float py = ux;
    int lx = (int)std::lround(base_x + px * (size * 0.55f));
    int ly = (int)std::lround(base_y + py * (size * 0.55f));
    int rx = (int)std::lround(base_x - px * (size * 0.55f));
    int ry = (int)std::lround(base_y - py * (size * 0.55f));
    draw_thick_line(r, tx, ty, lx, ly, thickness);
    draw_thick_line(r, tx, ty, rx, ry, thickness);
}

// ═══════════════════════════════════════════════════════════════════════════
// TITLE BANNER  — top of window, full width
// Python equivalent: tk.Label "⭐ COMMANDER CHESS — Cờ Tư Lệnh ⭐"
// ═══════════════════════════════════════════════════════════════════════════

static void draw_title(SDL_Renderer* r) {
    set_draw_color(r, C_BG);
    fill_rect(r, 0, 0, WIN_W, TITLE_H);
    // Green accent line at bottom
    set_draw_color(r, C_GREEN);
    hline(r, 0, TITLE_H-2, WIN_W, 2);
    // Subtle glow behind title
    SDL_SetRenderDrawBlendMode(r, SDL_BLENDMODE_BLEND);
    set_draw_color(r, {0x58,0xc8,0x8c,0x15});
    fill_rect(r, WIN_W/2 - 200, 0, 400, TITLE_H);
    SDL_SetRenderDrawBlendMode(r, SDL_BLENDMODE_NONE);
    dtc(r, g_fnt_xl,
        "COMMANDER CHESS",
        WIN_W/2, TITLE_H/2,
        {0xe8,0xed,0xf2,0xff});
}

// ═══════════════════════════════════════════════════════════════════════════
// STATUS BAR  — below title, spans full width
// Python equivalent: self.status_lbl (Consolas 12 bold, dark red/blue bg)
// ═══════════════════════════════════════════════════════════════════════════

static void draw_status(SDL_Renderer* r, const Game& g) {
    int sy = TITLE_H;

    Color bg;
    if      (g.state == GameState::GAME_OVER) bg = {0x1a,0x1c,0x0e,0xff};
    else if (g.current == "red")              bg = {0x1a,0x12,0x14,0xff};
    else                                      bg = {0x12,0x14,0x1a,0xff};
    set_draw_color(r, bg);
    fill_rect(r, 0, sy, WIN_W, STATUS_H);

    set_draw_color(r, {0x22,0x2c,0x30,0xff});
    hline(r, 0, sy + STATUS_H - 1, WIN_W, 1);

    Color dc;
    if      (g.state == GameState::GAME_OVER) dc = C_AMBER;
    else if (g.current == "red")              dc = C_RED_DOT;
    else                                      dc = C_BLUE_DOT;
    // Glow behind dot
    SDL_SetRenderDrawBlendMode(r, SDL_BLENDMODE_BLEND);
    set_draw_color(r, {dc.r, dc.g, dc.b, 0x30});
    fill_circle(r, 24, sy + STATUS_H/2, 16);
    SDL_SetRenderDrawBlendMode(r, SDL_BLENDMODE_NONE);
    set_draw_color(r, dc);
    fill_circle(r, 24, sy + STATUS_H/2, 9);

    SDL_Color tc;
    if      (g.state == GameState::GAME_OVER) tc = {0xfb,0xbf,0x24,0xff};
    else if (g.current == "red")              tc = {0xf0,0x90,0x90,0xff};
    else                                      tc = {0x90,0x90,0xf0,0xff};

    std::string msg = (g.state == GameState::GAME_OVER)
        ? "  GAME OVER  -  " + g.win_msg
        : "  " + g.status_msg;
    dtl(r, g_fnt_lg, msg.c_str(), 44, sy + STATUS_H/2, tc);
}

// ═══════════════════════════════════════════════════════════════════════════
// BOARD  — rendered into viewport at y=(TITLE_H+STATUS_H), x=0, w=BW, h=BH
// ═══════════════════════════════════════════════════════════════════════════

static void draw_board(SDL_Renderer* r) {
    // Cell backgrounds
    for (int row = 0; row < ROWS; row++) {
        for (int col = 0; col < COLS; col++) {
            int x0 = cx(col)-CELL/2, y0 = cy(row)-CELL/2;
            Color fill;
            if (row==5||row==6 || is_sea(col, row)) fill = C_RIVER;
            else                fill = C_LAND;
            set_draw_color(r, fill);
            fill_rect(r, x0, y0, CELL, CELL);
        }
    }

    // River band (rows 5-6, full width)
    int ry0 = cy(6)-CELL/2, ry1 = cy(5)+CELL/2;
    set_draw_color(r, {0x88,0xd0,0xf0,0xff});
    fill_rect(r, cx(0)-CELL/2, ry0, (cx(10)+CELL/2)-(cx(0)-CELL/2), ry1-ry0);
    dtc(r, g_fnt_sm, "~ ~ ~  RIVER / SONG  ~ ~ ~",
        (cx(0)+cx(10))/2, (ry0+ry1)/2, {0x1a,0x55,0x80,0xff});

    // Keep the sea-river connector strip (col 2..2.5, row 4.5..6.5) blue.
    int seam_x0 = cx(2);
    int seam_y0 = ry0;
    int seam_h  = ry1 - ry0;
    set_draw_color(r, C_RIVER);
    fill_rect(r, seam_x0, seam_y0, CELL/2, seam_h);

    // Reef bridges at cols 5 and 7
    for (int rc : {5,7}) {
        int bx2 = cx(rc);
        set_draw_color(r, {0xc0,0xe8,0xf8,0xff});
        fill_rect(r, bx2-12, ry0+3, 24, ry1-ry0-6);
        set_draw_color(r, {0x44,0x88,0xaa,0xff});
        draw_rect(r, bx2-12, ry0+3, 24, ry1-ry0-6);
        // Python uses ≡ (U+2261); we use = as ASCII fallback
        dtc(r, g_fnt_md, "=", bx2, (ry0+ry1)/2, {0x22,0x66,0xaa,0xff});
    }

    // Grid lines — thicker on river rows
    for (int row = 0; row < ROWS; row++) {
        set_draw_color(r, C_GRID);
        hline(r, cx(0), cy(row), cx(COLS-1), (row==5||row==6) ? 2 : 1);
    }
    for (int col = 0; col < COLS; col++) {
        set_draw_color(r, C_GRID);
        vline(r, cx(col), cy(0), cy(ROWS-1), 1);
    }

    // Outer border 3px thick
    set_draw_color(r, {0x5a,0x4a,0x20,0xff});
    for (int i = 0; i < 3; i++) {
        SDL_Rect b = {cx(0)-CELL/2-i, cy(ROWS-1)-CELL/2-i,
                      (cx(COLS-1)+CELL/2)-(cx(0)-CELL/2) + 2*i,
                      (cy(0)+CELL/2)-(cy(ROWS-1)-CELL/2) + 2*i};
        SDL_RenderDrawRect(r, &b);
    }

    // Column numbers along bottom (Python: cx(col), cy(0)+CELL//2+14)
    SDL_Color coord = {0x6a,0x5a,0x30,0xff};
    for (int col = 0; col < COLS; col++) {
        char buf[4]; snprintf(buf,4,"%d",col);
        dtc(r, g_fnt_sm, buf, cx(col), cy(0)+CELL/2+16, coord);
    }
    // Row numbers along left (Python: cx(0)-CELL//2-12, cy(row))
    for (int row = 0; row < ROWS; row++) {
        char buf[4]; snprintf(buf,4,"%d",row);
        dtc(r, g_fnt_sm, buf, cx(0)-CELL/2-14, cy(row), coord);
    }

    // Territory labels
    dtc(r, g_fnt_sm, "RED TERRITORY",  cx(6), cy(2), {0xd0,0x90,0x90,0xff});
    dtc(r, g_fnt_sm, "BLUE TERRITORY", cx(6), cy(9), {0x90,0x90,0xd0,0xff});

}

static void draw_last_move_trail(SDL_Renderer* r, const Game& g) {
    int from_c = 0, from_r = 0, to_c = 0, to_r = 0;
    bool is_capture = false;
    std::string player = "red";
    bool have = false;
    if (g.is_reviewing()) {
        int mv = g.review_index - 1;
        if (mv >= 0 && mv < (int)g.move_records.size()) {
            const MoveRecord& rec = g.move_records[mv];
            from_c = rec.from_c;
            from_r = rec.from_r;
            to_c = rec.to_c;
            to_r = rec.to_r;
            is_capture = rec.capture;
            player = rec.player;
            have = true;
        }
    } else if (g.has_last_move) {
        from_c = g.last_from_c;
        from_r = g.last_from_r;
        to_c = g.last_to_c;
        to_r = g.last_to_r;
        is_capture = g.last_move_capture;
        player = g.last_move_player;
        have = true;
    }
    if (!have) return;

    int x0 = cx(from_c);
    int y0 = cy(from_r);
    int x1 = cx(to_c);
    int y1 = cy(to_r);
    Color main = (player == "red")
        ? Color{0xff,0x7a,0x7a,0xd8}
        : Color{0x7a,0xa0,0xff,0xd8};
    Color glow = is_capture
        ? Color{0xff,0xc0,0x55,0xb0}
        : Color{0xa8,0xe8,0xff,0x8a};

    SDL_SetRenderDrawBlendMode(r, SDL_BLENDMODE_BLEND);
    set_draw_color(r, glow);
    draw_thick_line(r, x0, y0, x1, y1, 10);
    set_draw_color(r, main);
    draw_thick_line(r, x0, y0, x1, y1, 4);

    float dx = float(x1 - x0);
    float dy = float(y1 - y0);
    float len = std::sqrt(dx * dx + dy * dy);
    if (len > 1.0f) {
        float ux = dx / len;
        float uy = dy / len;
        int tx = (int)std::lround(x1 - ux * (PIECE_R - 2));
        int ty = (int)std::lround(y1 - uy * (PIECE_R - 2));
        draw_arrow_head(r, tx, ty, ux, uy, 14, 4);
    }

    set_draw_color(r, {0xff,0xff,0xff,0x70});
    fill_circle(r, x0, y0, 6);
    set_draw_color(r, main);
    draw_circle(r, x0, y0, PIECE_R - 6);
    draw_circle(r, x1, y1, PIECE_R - 5);
    if (is_capture) {
        set_draw_color(r, {0xff,0x66,0x66,0xff});
        draw_dashed_circle(r, x1, y1, PIECE_R + 2, 6);
    }
    SDL_SetRenderDrawBlendMode(r, SDL_BLENDMODE_NONE);
}

static void draw_highlights(SDL_Renderer* r, const Game& g) {
    if (g.is_reviewing()) return;

    const PieceList& board = g.board_for_render();

    if (g.state == GameState::HUMAN_TURN &&
        g.current == g.human_player &&
        g.selected_id < 0) {
        SDL_SetRenderDrawBlendMode(r, SDL_BLENDMODE_BLEND);
        for (const auto& p : board) {
            if (p.carrier_id >= 0) continue;
            if (p.player != g.human_player) continue;
            auto mvs = get_moves(p, board);
            if (mvs.empty()) continue;
            set_draw_color(r, {0xf5,0xc8,0x42,0x42});
            fill_circle(r, cx(p.col), cy(p.row), PIECE_R + 8);
            set_draw_color(r, {0xf5,0xc8,0x42,0xb0});
            draw_dashed_circle(r, cx(p.col), cy(p.row), PIECE_R + 8, 8);
        }
        SDL_SetRenderDrawBlendMode(r, SDL_BLENDMODE_NONE);
    }

    if (g.selected_id >= 0) {
        const Piece* sel = nullptr;
        for (const auto& p : board) if (p.id==g.selected_id) { sel=&p; break; }
        if (sel) {
            set_draw_color(r, C_SEL);
            draw_dashed_circle(r, cx(sel->col), cy(sel->row), PIECE_R+6, 7);
            draw_dashed_circle(r, cx(sel->col), cy(sel->row), PIECE_R+7, 7);
        }
    }
    for (auto& m : g.valid_moves) {
        int x=cx(m.first), y=cy(m.second);
        const Piece* t = piece_at_c(board, m.first, m.second);
        if (t && t->player != g.current) {
            set_draw_color(r, C_CAPTURE);
            draw_dashed_circle(r, x, y, PIECE_R-2, 6);
            draw_dashed_circle(r, x, y, PIECE_R-1, 6);
        } else {
            SDL_SetRenderDrawColor(r, C_MOVE.r, C_MOVE.g, C_MOVE.b, 0xaa);
            SDL_SetRenderDrawBlendMode(r, SDL_BLENDMODE_BLEND);
            fill_circle(r, x, y, 9);
            SDL_SetRenderDrawBlendMode(r, SDL_BLENDMODE_NONE);
        }
    }
}

static void draw_pieces(SDL_Renderer* r, const Game& g) {
    const PieceList& board = g.board_for_render();
    std::function<int(int)> stack_size = [&](int carrier_id) -> int {
        int n = 0;
        for (const auto& p : board) {
            if (p.carrier_id != carrier_id) continue;
            n += 1;
            n += stack_size(p.id);
        }
        return n;
    };

    for (const auto& p : board) {
        if (p.carrier_id >= 0) continue;
        int x=cx(p.col), y=cy(p.row);
        std::string key = p.kind + "_" + p.player;
        if (p.hero) {
            set_draw_color(r, C_HERO_RING);
            draw_dashed_circle(r, x, y, PIECE_R+4, 5);
            draw_dashed_circle(r, x, y, PIECE_R+5, 5);
        }
        auto it = g_textures.find(key);
        if (it != g_textures.end() && it->second) {
            SDL_Rect dst = {x-25, y-25, 50, 50};
            SDL_RenderCopy(r, it->second, nullptr, &dst);
        } else {
            Color pc = p.player=="red"
                ? Color{0xcc,0x33,0x33,0xff}
                : Color{0x22,0x44,0xcc,0xff};
            set_draw_color(r, pc); fill_circle(r, x, y, PIECE_R);
            set_draw_color(r, {0xff,0xff,0xff,0xff}); draw_circle(r, x, y, PIECE_R);
            dtc(r, g_fnt_sm, p.kind.c_str(), x, y, {0xff,0xff,0xff,0xff});
        }
        if (p.hero)
            dtc(r, g_fnt_sm, "*", x+PIECE_R, y-PIECE_R+2, {0xff,0xee,0x00,0xff});
        int carried = stack_size(p.id);
        if (carried > 0) {
            std::string lbl = "+" + std::to_string(carried);
            dtc(r, g_fnt_sm, lbl.c_str(), x+PIECE_R-2, y+PIECE_R-2, {0xff,0xcc,0x66,0xff});
        }
    }
}

struct PanelMoveLogLayout {
    bool visible = false;
    int title_y = 0;
    int box_x = 0;
    int box_y = 0;
    int box_w = 0;
    int box_h = 0;
    int row_h = 13;
    int log_start = 0;
    int rows = 0;
    SDL_Rect prev_btn{0,0,0,0};
    SDL_Rect next_btn{0,0,0,0};
};

static PanelMoveLogLayout compute_panel_move_log_layout(const Game& g) {
    PanelMoveLogLayout ml;
    int y = TITLE_H + 8;

    // YOU/CPU row + separator
    y += 16; y += 8;
    // Difficulty section
    y += 18; // header spacing
    y += 18; y += 8; // radio row + separator
    // NEXT STEP section
    y += 16;          // header spacing
    y += 14 * 3;      // three guidance lines
    if (g.has_last_move) y += 14;
    y += 8;           // separator spacing
    // HIGHLIGHT LEGEND
    y += 15;
    y += 13 + 13 + 13 + 14;
    y += 8;           // separator spacing
    // PIECE GUIDE
    y += 18; y += 5;
    for (int i = 0; i < 11; i++) {
        y += 22;
        if (y > WIN_H - 140) break;
    }
    y += 8;           // separator spacing
    // WIN CONDITIONS
    y += 16;
    y += 16;
    for (int i = 0; i < 4; i++) {
        y += 16;
        if (y > WIN_H - 90) break;
    }
    y += 6;           // separator spacing
    // HERO NOTE
    if (y < WIN_H - 70) {
        y += 14;
        y += 14;
        y += 6;
    }

    if (y >= WIN_H - 50) return ml;

    ml.visible = true;
    ml.title_y = y;
    int nav_y = y - 8;
    ml.next_btn = SDL_Rect{BW + PANEL_W - 28, nav_y, 18, 14};
    ml.prev_btn = SDL_Rect{BW + PANEL_W - 50, nav_y, 18, 14};
    int text_y = y + 16;
    ml.box_x = BW + 6;
    ml.box_y = text_y;
    ml.box_w = PANEL_W - 12;
    ml.box_h = WIN_H - text_y - 6;
    if (ml.box_h <= 10) return ml;

    int rows_fit = 0;
    for (int yy = text_y; yy + 4 < WIN_H - 8; yy += ml.row_h) rows_fit++;
    int tail = std::min(14, rows_fit);
    if (g.is_reviewing()) {
        int focus = std::max(0, g.review_index - 1);
        int max_start = std::max(0, (int)g.move_log.size() - tail);
        int centered = focus - tail / 2;
        ml.log_start = std::max(0, std::min(centered, max_start));
    } else {
        ml.log_start = std::max(0, (int)g.move_log.size() - tail);
    }
    ml.rows = std::min((int)g.move_log.size() - ml.log_start, rows_fit);
    return ml;
}

static int move_log_nav_from_panel_click(const Game& g, int mx, int my) {
    PanelMoveLogLayout ml = compute_panel_move_log_layout(g);
    if (!ml.visible) return 0;
    auto inside = [&](const SDL_Rect& rc) {
        return mx >= rc.x && mx < rc.x + rc.w && my >= rc.y && my < rc.y + rc.h;
    };
    bool prev_enabled = g.state_history.size() > 1 && (!g.is_reviewing() || g.review_index > 0);
    bool next_enabled = g.is_reviewing();
    if (prev_enabled && inside(ml.prev_btn)) return -1;
    if (next_enabled && inside(ml.next_btn)) return +1;
    return 0;
}

static int move_log_index_from_panel_click(const Game& g, int mx, int my) {
    PanelMoveLogLayout ml = compute_panel_move_log_layout(g);
    if (!ml.visible || ml.rows <= 0) return -1;
    if (mx < ml.box_x || mx >= ml.box_x + ml.box_w ||
        my < ml.box_y || my >= ml.box_y + ml.box_h) return -1;
    int row = (my - ml.box_y) / ml.row_h;
    if (row < 0 || row >= ml.rows) return -1;
    return ml.log_start + row;
}

// ═══════════════════════════════════════════════════════════════════════════
// SIDE PANEL  — x=BW..BW+PANEL_W, y=0..WIN_H
// Matches Python _build_panel() layout
// ═══════════════════════════════════════════════════════════════════════════

static void draw_panel(SDL_Renderer* r, const Game& g) {
    int px = BW;
    int mid = px + PANEL_W/2;

    // Background
    set_draw_color(r, C_PANEL);
    fill_rect(r, px, 0, PANEL_W, WIN_H);
    // Left border — subtle green
    set_draw_color(r, {0x58,0xc8,0x8c,0x33});
    vline(r, px, 0, WIN_H, 1);

    SDL_Color green_hd = {0x58,0xc8,0x8c,0xff};  // section headers
    SDL_Color body_txt = {0x90,0xa4,0xae,0xff};   // body text
    SDL_Color amber    = {0xfb,0xbf,0x24,0xff};   // amber highlights

    // Helper: horizontal separator line
    auto sep = [&](int y) {
        SDL_SetRenderDrawBlendMode(r, SDL_BLENDMODE_BLEND);
        set_draw_color(r, {0xff,0xff,0xff,0x0a});
        hline(r, px+10, y, px+PANEL_W-10, 1);
        SDL_SetRenderDrawBlendMode(r, SDL_BLENDMODE_NONE);
    };

    int y = TITLE_H + 8;

    // ── YOU / CPU info ─────────────────────────────────────────────────
    Color you_dot = (g.human_player == "red") ? C_RED_DOT : C_BLUE_DOT;
    SDL_Color you_tc = (g.human_player == "red")
        ? SDL_Color{0xf0,0x90,0x90,0xff}
        : SDL_Color{0x90,0xb0,0xf0,0xff};
    const char* you_lbl = (g.human_player == "red") ? "YOU = RED" : "YOU = BLUE";

    Color cpu_dot = (g.cpu_player == "red") ? C_RED_DOT : C_BLUE_DOT;
    SDL_Color cpu_tc = (g.cpu_player == "red")
        ? SDL_Color{0xf0,0x90,0x90,0xff}
        : SDL_Color{0x90,0xb0,0xf0,0xff};
    const char* cpu_lbl = (g.cpu_player == "red") ? "CPU = RED" : "CPU = BLUE";

    set_draw_color(r, you_dot);
    fill_circle(r, px+12, y, 5);
    dtl(r, g_fnt_sm, you_lbl, px+24, y, you_tc);

    set_draw_color(r, cpu_dot);
    fill_circle(r, mid+10, y, 5);
    dtl(r, g_fnt_sm, cpu_lbl, mid+22, y, cpu_tc);

    y += 16; sep(y); y += 8;

    // ── CPU DIFFICULTY ────────────────────────────────────────────────────
    dtl(r, g_fnt_head, "DIFFICULTY", px+8, y, green_hd);
    y += 18;

    const char* dlbl[] = {"Beginner","Intermediate","Expert"};
    int rbx = px+10;
    for (int i = 0; i < 3; i++) {
        bool sel = (g.difficulty == i);
        // Pill highlight when selected
        if (sel) {
            SDL_SetRenderDrawBlendMode(r, SDL_BLENDMODE_BLEND);
            set_draw_color(r, {0x58,0xc8,0x8c,0x20});
            fill_rect(r, rbx-2, y-6, (i==1?90:70), 14);
            SDL_SetRenderDrawBlendMode(r, SDL_BLENDMODE_NONE);
        }
        set_draw_color(r, sel ? C_GREEN : Color{0x44,0x55,0x44,0xff});
        fill_circle(r, rbx+4, y+1, sel ? 4 : 3);
        SDL_Color tc = sel ? green_hd : body_txt;
        dtl(r, g_fnt_sm, dlbl[i], rbx+12, y+1, tc);
        rbx += (i==0 ? 72 : (i==1 ? 90 : 60));
    }
    y += 18; sep(y); y += 8;

    // ── NEXT STEP (beginner guidance) ──────────────────────────────────
    dtl(r, g_fnt_head, "NEXT STEP", px+8, y, green_hd);
    y += 16;
    std::string tip1, tip2, tip3;
    if (g.state == GameState::GAME_OVER) {
        tip1 = "Click NEW GAME to restart.";
        tip2 = "Pick mode + side and start again.";
        tip3 = "Try a lower difficulty first.";
    } else if (g.state == GameState::CPU_THINKING) {
        tip1 = "CPU is thinking...";
        tip2 = "Watch the trail for the last move.";
        tip3 = "Plan your next capture threat.";
    } else if (g.selected_id < 0) {
        tip1 = "Click a glowing piece to select it.";
        tip2 = "Green dots = where it can move.";
        tip3 = "Red rings = captures you can make.";
    } else if (g.valid_moves.empty()) {
        tip1 = "This piece can't move right now.";
        tip2 = "Click another highlighted piece.";
        tip3 = "Keep your Commander safe!";
    } else {
        tip1 = "Click a green dot to move there.";
        tip2 = "Red rings mean you can capture!";
        tip3 = "Don't leave your Commander exposed.";
    }
    dtl(r, g_fnt_sm, tip1.c_str(), px+8, y, body_txt); y += 14;
    dtl(r, g_fnt_sm, tip2.c_str(), px+8, y, body_txt); y += 14;
    dtl(r, g_fnt_sm, tip3.c_str(), px+8, y, body_txt); y += 14;
    if (g.has_last_move) {
        std::string lm = std::string("Last: ") +
            (g.last_move_player == "red" ? "R " : "B ") +
            "(" + std::to_string(g.last_from_c) + "," + std::to_string(g.last_from_r) + ")" +
            "->(" + std::to_string(g.last_to_c) + "," + std::to_string(g.last_to_r) + ")" +
            (g.last_move_capture ? " x" : "");
        dtl(r, g_fnt_sm, lm.c_str(), px+8, y, amber);
        y += 14;
    }
    sep(y); y += 8;

    // ── HIGHLIGHT LEGEND ───────────────────────────────────────────────
    dtl(r, g_fnt_head, "LEGEND", px+8, y, green_hd);
    y += 15;
    dtl(r, g_fnt_sm, "Yellow ring = selected unit", px+8, y, body_txt); y += 13;
    dtl(r, g_fnt_sm, "Green dot = legal move", px+8, y, body_txt); y += 13;
    dtl(r, g_fnt_sm, "Red ring = capture move", px+8, y, body_txt); y += 13;
    dtl(r, g_fnt_sm, "Trail arrow = previous move", px+8, y, body_txt); y += 14;
    sep(y); y += 8;

    // ── PIECE GUIDE ───────────────────────────────────────────────────
    dtl(r, g_fnt_head, "PIECE GUIDE", px+8, y, green_hd);
    y += 18; sep(y); y += 5;

    static const std::pair<const char*,const char*> guide[] = {
        {"C",  "Commander  PROTECT!"},
        {"H",  "HQ  immobile base"},
        {"In", "Infantry  1 sq fwd"},
        {"M",  "Militia  1 sq +diag"},
        {"T",  "Tank  2 sq straight"},
        {"E",  "Engineer  carries"},
        {"A",  "Artillery  range 3"},
        {"Aa", "Anti-Air  shoots air"},
        {"Ms", "Missile  range 2"},
        {"Af", "Air Force  flies! r4"},
        {"N",  "Navy  sea power r3"},
    };
    for (auto& kv : guide) {
        auto it = g_textures_small.find(std::string(kv.first) + "_red");
        if (it != g_textures_small.end() && it->second) {
            SDL_Rect dst = {px+6, y, 20, 20};
            SDL_RenderCopy(r, it->second, nullptr, &dst);
        } else {
            set_draw_color(r, {0xcc,0x33,0x33,0xff});
            fill_circle(r, px+16, y+10, 8);
        }
        dtl(r, g_fnt_sm, kv.second, px+30, y+10, body_txt);
        y += 22;
        if (y > WIN_H - 140) break;
    }
    sep(y); y += 8;

    // ── WIN CONDITIONS ────────────────────────────────────────────────────
    dtl(r, g_fnt_head, "HOW TO WIN", px+8, y, amber);
    y += 16;
    std::string mode_line = std::string("Mode: ") + game_mode_name(g.selected_mode);
    dtl(r, g_fnt_sm, mode_line.c_str(), px+8, y, {0xfb,0xbf,0x24,0xbb});
    y += 16;
    const char* wins[] = {
        "Capture enemy Commander",
        "Destroy all 2 Navy",
        "Destroy all 2 Air Force",
        "Destroy Arty+Tank+Infantry",
    };
    for (auto* w : wins) {
        dtl(r, g_fnt_sm, w, px+8, y, body_txt);
        y += 16;
        if (y > WIN_H-90) break;
    }
    sep(y); y += 6;

    // ── HERO NOTE ─────────────────────────────────────────────────────────
    if (y < WIN_H - 70) {
        dtl(r, g_fnt_sm, "Hero: checks opponent Commander", px+8, y, {0xfb,0xbf,0x24,0x99});
        y += 14;
        dtl(r, g_fnt_sm, "  +1 range, diagonal, Air=stealth", px+8, y, {0xfb,0xbf,0x24,0x77});
        y += 14; sep(y); y += 6;
    }

    // ── MOVE LOG (click a row to review that move) ───────────────────────
    PanelMoveLogLayout ml = compute_panel_move_log_layout(g);
    if (ml.visible) {
        const char* log_title = g.is_reviewing()
            ? "MOVE LOG  [click row or < > arrows]"
            : "MOVE LOG  [click row or < to review]";
        dtl(r, g_fnt_head, log_title, px+8, ml.title_y, green_hd);

        bool prev_enabled = g.state_history.size() > 1 && (!g.is_reviewing() || g.review_index > 0);
        bool next_enabled = g.is_reviewing();
        auto draw_nav_btn = [&](const SDL_Rect& rc, const char* lbl, bool enabled) {
            set_draw_color(r, enabled ? Color{0x1a,0x28,0x22,0xff} : Color{0x18,0x1c,0x22,0xff});
            fill_rect(r, rc.x, rc.y, rc.w, rc.h);
            set_draw_color(r, enabled ? Color{0x58,0xc8,0x8c,0x66} : Color{0x44,0x44,0x44,0xff});
            draw_rect(r, rc.x, rc.y, rc.w, rc.h);
            dtc(r, g_fnt_sm, lbl, rc.x + rc.w/2, rc.y + rc.h/2,
                enabled ? SDL_Color{0x58,0xc8,0x8c,0xff} : SDL_Color{0x55,0x55,0x55,0xff});
        };
        draw_nav_btn(ml.prev_btn, "<", prev_enabled);
        draw_nav_btn(ml.next_btn, ">", next_enabled);

        if (ml.box_h > 10) {
            set_draw_color(r, {0x0d,0x11,0x17,0xff});
            fill_rect(r, ml.box_x, ml.box_y, ml.box_w, ml.box_h);
            set_draw_color(r, {0x22,0x2c,0x30,0xff});
            draw_rect(r, ml.box_x, ml.box_y, ml.box_w, ml.box_h);
        }

        int selected_move = g.is_reviewing() ? (g.review_index - 1) : -1;
        int line_y = ml.box_y;
        for (int row = 0; row < ml.rows; row++) {
            int i = ml.log_start + row;
            bool selected = (i == selected_move);
            if (selected) {
                SDL_SetRenderDrawBlendMode(r, SDL_BLENDMODE_BLEND);
                set_draw_color(r, {0x58,0xc8,0x8c,0x22});
                fill_rect(r, ml.box_x + 1, line_y, ml.box_w - 2, ml.row_h);
                SDL_SetRenderDrawBlendMode(r, SDL_BLENDMODE_NONE);
            }

            bool you = !g.move_log[i].empty() && g.move_log[i][0]=='Y';
            SDL_Color tc = selected
                ? SDL_Color{0x58,0xc8,0x8c,0xff}
                : (you ? SDL_Color{0xf0,0x90,0x90,0xff}
                       : SDL_Color{0x90,0xb0,0xf0,0xff});
            std::string e = std::to_string(i + 1) + ". " + g.move_log[i];
            if (e.size() > 36) e = e.substr(0,35) + "..";
            dtl(r, g_fnt_sm, e.c_str(), px+10, line_y+7, tc);
            line_y += ml.row_h;
        }
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// GAME-OVER OVERLAY
// ═══════════════════════════════════════════════════════════════════════════

static void draw_game_over(SDL_Renderer* r, const Game& g) {
    int board_y = TITLE_H + STATUS_H;
    // Full board dim
    SDL_SetRenderDrawBlendMode(r, SDL_BLENDMODE_BLEND);
    SDL_SetRenderDrawColor(r, 0x0d, 0x11, 0x17, 200);
    fill_rect(r, 0, board_y, BW, BH);
    SDL_SetRenderDrawBlendMode(r, SDL_BLENDMODE_NONE);

    // Centered card
    int ow=BW-60, oh=160;
    int ox=(BW-ow)/2, oy=board_y+(BH-oh)/2;

    set_draw_color(r, {0x14,0x1e,0x28,0xff});
    fill_rect(r, ox, oy, ow, oh);

    // Green border
    set_draw_color(r, C_GREEN);
    for (int i=0; i<2; i++) draw_rect(r, ox+i, oy+i, ow-2*i, oh-2*i);

    // Check if player won
    bool player_won = (g.win_msg.find("RED") != std::string::npos && g.human_player == "red") ||
                      (g.win_msg.find("BLUE") != std::string::npos && g.human_player == "blue");

    const char* title = player_won ? "VICTORY!" : "GAME OVER";
    SDL_Color title_c = player_won
        ? SDL_Color{0x58,0xc8,0x8c,0xff}
        : SDL_Color{0xfb,0xbf,0x24,0xff};
    dtc(r, g_fnt_xl, title, BW/2, oy+36, title_c);
    dtc(r, g_fnt_lg, g.win_msg.c_str(), BW/2, oy+74, {0xe8,0xed,0xf2,0xff});

    const char* sub = player_won ? "Outstanding strategy, Commander!" : "Better luck next time, Commander.";
    dtc(r, g_fnt_md, sub, BW/2, oy+105, {0x90,0xa4,0xae,0xff});
    dtc(r, g_fnt_sm, "Click NEW GAME to play again", BW/2, oy+135, {0x78,0x90,0x9c,0x99});
}

static void draw_button(SDL_Renderer* r, int x, int y, int w, int h,
                        const char* lbl, SDL_Color tc, bool hover=false, bool disabled=false);

static SDL_Rect mode_menu_card_rect(int idx) {
    const int top = TITLE_H + STATUS_H + 140;
    const int margin = 34;
    const int gap = 18;
    const int w = (WIN_W - margin * 2 - gap) / 2;
    const int h = 132;
    int row = idx / 2;
    int col = idx % 2;
    return SDL_Rect{margin + col * (w + gap), top + row * (h + gap), w, h};
}

static SDL_Rect mode_menu_start_rect() {
    SDL_Rect c2 = mode_menu_card_rect(2);
    SDL_Rect c3 = mode_menu_card_rect(3);
    int y = std::max(c2.y + c2.h, c3.y + c3.h) + 72;
    return SDL_Rect{WIN_W / 2 - 120, y, 240, 40};
}

static SDL_Rect mode_menu_side_rect(int idx) {
    SDL_Rect s = mode_menu_start_rect();
    const int w = 180;
    const int h = 34;
    const int gap = 20;
    const int total = w * 2 + gap;
    const int x0 = WIN_W / 2 - total / 2;
    const int y = s.y - 52;
    return SDL_Rect{x0 + idx * (w + gap), y, w, h};
}

static SDL_Rect mode_menu_quit_rect() {
    SDL_Rect s = mode_menu_start_rect();
    return SDL_Rect{WIN_W / 2 - 60, s.y + s.h + 10, 120, 28};
}

static GameMode mode_for_menu_index(int idx) {
    switch (idx) {
    case 1: return GameMode::MARINE_BATTLE;
    case 2: return GameMode::AIR_BATTLE;
    case 3: return GameMode::LAND_BATTLE;
    case 0:
    default: return GameMode::FULL_BATTLE;
    }
}

static void draw_mode_selection_screen(SDL_Renderer* r, const Game& g) {
    int top = TITLE_H + STATUS_H;
    set_draw_color(r, C_BG);
    fill_rect(r, 0, top, WIN_W, WIN_H - top);

    SDL_SetRenderDrawBlendMode(r, SDL_BLENDMODE_BLEND);
    for (int i = 0; i < 9; i++) {
        uint8_t a = (uint8_t)(4 + i * 3);
        set_draw_color(r, {0x14,0x1e,0x28,a});
        int band_h = (WIN_H - top) / 9;
        fill_rect(r, 0, top + i * band_h, WIN_W, band_h);
    }
    set_draw_color(r, {0x58,0xc8,0x8c,0x10});
    fill_circle(r, WIN_W / 2, top + 34, 180);
    SDL_SetRenderDrawBlendMode(r, SDL_BLENDMODE_NONE);

    dtc(r, g_fnt_xl, "Choose Battle Mode", WIN_W / 2, top + 24, {0xe8,0xed,0xf2,0xff});
    dtc(r, g_fnt_md, "Step 1: mode   Step 2: side   Step 3: start",
        WIN_W / 2, top + 52, {0x90,0xa4,0xae,0xff});

    auto draw_step_chip = [&](int idx, const char* title, const char* detail, bool done, bool active) {
        const int w = 300;
        const int h = 42;
        const int gap = 16;
        const int total = w * 3 + gap * 2;
        int x = WIN_W / 2 - total / 2 + idx * (w + gap);
        int y = top + 78;
        Color bg = done ? Color{0x14,0x22,0x1a,0xff}
                        : (active ? Color{0x1a,0x23,0x32,0xff} : Color{0x14,0x18,0x20,0xff});
        Color edge = done ? Color{0x58,0xc8,0x8c,0xff}
                          : (active ? Color{0x58,0xc8,0x8c,0x55} : Color{0x33,0x3c,0x44,0xff});
        set_draw_color(r, bg);
        fill_rect(r, x, y, w, h);
        set_draw_color(r, edge);
        draw_rect(r, x, y, w, h);

        set_draw_color(r, done ? Color{0x58,0xc8,0x8c,0xff}
                               : (active ? Color{0xfb,0xbf,0x24,0xff} : Color{0x55,0x55,0x55,0xff}));
        fill_circle(r, x + 13, y + h/2, 7);
        dtl(r, g_fnt_sm, title, x + 26, y + 13,
            done ? SDL_Color{0x58,0xc8,0x8c,0xff}
                 : (active ? SDL_Color{0xe8,0xed,0xf2,0xff} : SDL_Color{0x78,0x90,0x9c,0xff}));
        dtl(r, g_fnt_sm, detail, x + 26, y + 28, {0x90,0xa4,0xae,0xff});
    };

    bool side_done = g.menu_side_chosen;
    draw_step_chip(0, "STEP 1  MODE", game_mode_name(g.selected_mode), true, false);
    draw_step_chip(1, "STEP 2  SIDE",
                   side_done ? (g.menu_side_choice == "red" ? "You are RED" : "You are BLUE")
                             : "Choose RED or BLUE",
                   side_done, !side_done);
    draw_step_chip(2, "STEP 3  START",
                   side_done ? "Ready to begin" : "Locked until side is set",
                   false, side_done);

    struct CardText {
        const char* title;
        const char* l1;
        const char* l2;
        const char* l3;
    };
    static const CardText cards[] = {
        {"FULL BATTLE",   "Win by capturing",      "the enemy Commander.",     "Default full ruleset."},
        {"MARINE BATTLE", "Win if enemy has",      "no Navy (N) left.",        "Commander capture also wins."},
        {"AIR BATTLE",    "Win if enemy has",      "no Air Force (Af) left.",  "Commander capture also wins."},
        {"LAND BATTLE",   "Win if enemy has",      "no T, In, and A left.",    "Commander capture also wins."},
    };

    for (int i = 0; i < 4; i++) {
        SDL_Rect rc = mode_menu_card_rect(i);
        GameMode mode = mode_for_menu_index(i);
        bool sel = (g.selected_mode == mode);

        set_draw_color(r, sel ? Color{0x14,0x22,0x1a,0xff} : Color{0x14,0x18,0x20,0xff});
        fill_rect(r, rc.x, rc.y, rc.w, rc.h);
        set_draw_color(r, sel ? Color{0x58,0xc8,0x8c,0xff} : Color{0x33,0x3c,0x44,0xff});
        draw_rect(r, rc.x, rc.y, rc.w, rc.h);
        if (sel) draw_rect(r, rc.x+1, rc.y+1, rc.w-2, rc.h-2);

        dtc(r, g_fnt_lg, cards[i].title, rc.x + rc.w / 2, rc.y + 24,
            sel ? SDL_Color{0x58,0xc8,0x8c,0xff} : SDL_Color{0x90,0xa4,0xae,0xff});
        dtl(r, g_fnt_md, cards[i].l1, rc.x + 12, rc.y + 52, {0xb0,0xbe,0xc5,0xff});
        dtl(r, g_fnt_md, cards[i].l2, rc.x + 12, rc.y + 74, {0xb0,0xbe,0xc5,0xff});
        dtl(r, g_fnt_sm, cards[i].l3, rc.x + 12, rc.y + 100, {0x78,0x90,0x9c,0xff});
    }

    SDL_Rect s = mode_menu_start_rect();
    SDL_Rect q = mode_menu_quit_rect();
    SDL_Rect sr = mode_menu_side_rect(0);
    SDL_Rect sb = mode_menu_side_rect(1);

    auto draw_side_btn = [&](const SDL_Rect& rc, const char* label, const std::string& side) {
        bool sel = g.menu_side_chosen && g.menu_side_choice == side;
        set_draw_color(r, sel ? Color{0x14,0x22,0x1a,0xff} : Color{0x14,0x18,0x20,0xff});
        fill_rect(r, rc.x, rc.y, rc.w, rc.h);
        Color edge = sel ? C_GREEN
                         : (side == "red" ? Color{0xdc,0x35,0x45,0x55} : Color{0x3b,0x82,0xf6,0x55});
        set_draw_color(r, edge);
        draw_rect(r, rc.x, rc.y, rc.w, rc.h);

        set_draw_color(r, side == "red" ? C_RED_DOT : C_BLUE_DOT);
        fill_circle(r, rc.x + 14, rc.y + rc.h/2, 6);
        dtc(r, g_fnt_btn, label, rc.x + rc.w/2 + 8, rc.y + rc.h/2,
            sel ? SDL_Color{0x58,0xc8,0x8c,0xff} : SDL_Color{0xb0,0xbe,0xc5,0xff});
    };

    std::string chosen_mode = std::string("Selected mode: ") + game_mode_name(g.selected_mode);
    dtc(r, g_fnt_md, chosen_mode.c_str(), WIN_W / 2, sr.y - 34, {0x58,0xc8,0x8c,0xbb});
    std::string chosen_side = g.menu_side_chosen
        ? std::string("Selected side: YOU = ") + (g.menu_side_choice == "red" ? "RED" : "BLUE")
        : "Selected side: (choose RED or BLUE)";
    dtc(r, g_fnt_sm, chosen_side.c_str(), WIN_W / 2, sr.y - 14, {0x90,0xa4,0xae,0xff});

    draw_side_btn(sr, "PLAY AS RED", "red");
    draw_side_btn(sb, "PLAY AS BLUE", "blue");

    draw_button(r, s.x, s.y, s.w, s.h, "START GAME",
                g.menu_side_chosen ? SDL_Color{0x58,0xc8,0x8c,0xff}
                                   : SDL_Color{0x55,0x55,0x55,0xff},
                false, !g.menu_side_chosen);
    draw_button(r, q.x, q.y, q.w, q.h, "Quit", {0xff,0x88,0x66,0xff});
}

// ── Button helper ─────────────────────────────────────────────────────────
static void draw_button(SDL_Renderer* r, int x, int y, int w, int h,
                        const char* lbl, SDL_Color tc, bool hover, bool disabled) {
    Color bg = disabled
        ? Color{0x18,0x1c,0x22,0xff}
        : (hover ? Color{0x1a,0x28,0x22,0xff} : Color{0x14,0x1e,0x28,0xff});
    Color edge = disabled ? Color{0x33,0x3c,0x44,0xff} : Color{0x58,0xc8,0x8c,0x77};
    set_draw_color(r, bg);
    fill_rect(r, x, y, w, h);
    set_draw_color(r, edge);
    draw_rect(r, x, y, w, h);
    dtc(r, g_fnt_btn, lbl, x+w/2, y+h/2, tc);
}

// ─────────────────────────────────────────────────────────────────────────
struct Button { SDL_Rect rect; std::string label; std::function<void()> action; };

struct SimOptions {
    bool enabled = false;
    int games = 1000;
    int seed = 1;
    int depth = 4;
    int time_ms = 50;
    int max_plies = 300;
    std::string start = "alternate"; // red | blue | alternate | random
    bool mcts = false;
};

static bool parse_i32_arg(const char* s, int& out) {
    if (!s || !*s) return false;
    std::stringstream ss(s);
    int v = 0;
    char extra = 0;
    if (!(ss >> v)) return false;
    if (ss >> extra) return false;
    out = v;
    return true;
}

static void print_usage(const char* prog) {
    std::cout
        << "Usage:\n"
        << "  " << prog << "\n"
        << "  " << prog << " [--eval_backend MODE]\n"
        << "  " << prog << " --sim [--games N] [--seed S] [--depth D] [--time_ms T] [--max_plies P] [--start MODE] [--mcts]\n"
        << "\n"
        << "General options:\n"
        << "  --eval_backend MODE    MODE: auto | cpu | webgpu   (default: auto)\n"
        << "\n"
        << "Defaults in --sim mode:\n"
        << "  --games 1000 --seed 1 --depth 4 --time_ms 50 --max_plies 300 --start alternate\n"
        << "  MODE: red | blue | alternate | random\n"
        << "  --mcts enables hybrid MCTS+AB move selection in sim mode\n";
}

static int run_headless_sim(const SimOptions& opt) {
    init_zobrist();
    tt_ensure_allocated();
    std::srand((unsigned int)opt.seed);
    std::mt19937 rng((uint32_t)opt.seed);
    bool prev_book = g_use_opening_book;
    bool prev_mcts = g_use_mcts;
    g_use_opening_book = false; // fair self-play: avoid side-specific opening-book bias
    g_use_mcts = opt.mcts;

    int red_wins = 0;
    int blue_wins = 0;
    int draws = 0;
    int started_red = 0;
    int started_blue = 0;
    int starter_wins = 0;
    int nonstarter_wins = 0;
    const double time_limit_secs = (double)opt.time_ms / 1000.0;

    auto t0 = std::chrono::steady_clock::now();

    for (int g = 0; g < opt.games; g++) {
        PieceList pieces = make_initial_pieces();
        std::string turn = "red";
        if (opt.start == "blue") turn = "blue";
        else if (opt.start == "alternate") turn = (g % 2 == 0) ? "red" : "blue";
        else if (opt.start == "random") turn = (std::uniform_int_distribution<int>(0, 1)(rng) == 0) ? "red" : "blue";
        const std::string starter = turn;
        if (starter == "red") started_red++;
        else started_blue++;
        std::vector<uint64_t> rep_history;
        push_position_history(rep_history, zobrist_hash(pieces, turn));

        std::string init_why;
        if (!validate_state_for_sim(pieces, opp(starter), &init_why)) {
            std::cerr
                << "[sim] invalid initial state"
                << " seed=" << opt.seed
                << " game=" << g
                << " starter=" << starter
                << " reason=\"" << init_why << "\"\n";
            std::abort();
        }
        bool finished = false;
        tt_clear();  // CRITICAL: purge all TT entries between games to prevent
                     //   cross-perspective value pollution (red stores "+500 good-for-red",
                     //   blue reads "+500" and misinterprets as "good-for-blue").

        for (int ply = 0; ply < opt.max_plies; ply++) {
            reset_search_tables();
            tt_clear();  // Self-play: purge TT every move since perspective alternates
            g_game_rep_history = rep_history;  // let search see game's repetition history
            AIResult r = cpu_pick_move(pieces, turn, opt.depth, time_limit_secs);
            if (!r.found) {
                draws++;
                finished = true;
                break;
            }

            pieces = apply_move(pieces, r.move.pid, r.move.dc, r.move.dr, turn);

            std::string why;
            if (!validate_state_for_sim(pieces, turn, &why)) {
                std::cerr
                    << "[sim] invalid state"
                    << " seed=" << opt.seed
                    << " game=" << g
                    << " ply=" << ply
                    << " turn=" << turn
                    << " move=(" << r.move.pid << " -> " << r.move.dc << "," << r.move.dr << ")"
                    << " reason=\"" << why << "\"\n";
                std::abort();
            }

            std::string win = check_win(pieces, turn);
            if (!win.empty()) {
                if (turn == "red") red_wins++;
                else               blue_wins++;
                if (turn == starter) starter_wins++;
                else                 nonstarter_wins++;
                finished = true;
                break;
            }

            turn = opp(turn);
            uint64_t rep_hash = zobrist_hash(pieces, turn);
            push_position_history(rep_history, rep_hash);
            if (is_threefold_repetition(rep_history, rep_hash)) {
                draws++;
                finished = true;
                break;
            }
        }

        if (!finished) draws++;
    }

    double total_seconds =
        std::chrono::duration<double>(std::chrono::steady_clock::now() - t0).count();
    double ms_per_game = (opt.games > 0) ? (total_seconds * 1000.0 / (double)opt.games) : 0.0;
    double games_per_hour = (total_seconds > 0.0) ? ((double)opt.games * 3600.0 / total_seconds) : 0.0;

    std::cout << std::fixed << std::setprecision(3);
    std::cout << "SIM CONFIG: games=" << opt.games
              << " seed=" << opt.seed
              << " depth=" << opt.depth
              << " time_ms=" << opt.time_ms
              << " max_plies=" << opt.max_plies
              << " start=" << opt.start
              << " mcts=" << (opt.mcts ? 1 : 0) << "\n";
    std::cout << "EVAL BACKEND: " << eval_backend_name(active_eval_backend()) << "\n";
    std::cout << "RESULTS: red_wins=" << red_wins
              << " blue_wins=" << blue_wins
              << " draws=" << draws << "\n";
    std::cout << "STARTERS: red_started=" << started_red
              << " blue_started=" << started_blue
              << " starter_wins=" << starter_wins
              << " nonstarter_wins=" << nonstarter_wins << "\n";
    std::cout << "total seconds: " << total_seconds << "\n";
    std::cout << "ms/game: " << ms_per_game << "\n";
    std::cout << "games/hour estimate: " << games_per_hour << "\n";
    g_use_opening_book = prev_book;
    g_use_mcts = prev_mcts;
    return 0;
}

// ═══════════════════════════════════════════════════════════════════════════
// MAIN
// ═══════════════════════════════════════════════════════════════════════════

int main(int argc, char* argv[]) {
    std::atexit(tt_arena_release);
    SimOptions sim;
    bool saw_sim_option = false;
    std::string eval_backend_mode = "auto";

    for (int i = 1; i < argc; i++) {
        std::string arg = argv[i];
        if (arg == "--help" || arg == "-h") {
            print_usage(argv[0]);
            return 0;
        } else if (arg == "--eval_backend") {
            if (i + 1 >= argc) {
                std::cerr << "Missing value for --eval_backend\n";
                print_usage(argv[0]);
                return 1;
            }
            eval_backend_mode = argv[++i];
        } else if (arg == "--sim") {
            sim.enabled = true;
        } else if (arg == "--mcts") {
            saw_sim_option = true;
            sim.mcts = true;
        } else if (arg == "--start") {
            saw_sim_option = true;
            if (i + 1 >= argc) {
                std::cerr << "Missing value for --start\n";
                print_usage(argv[0]);
                return 1;
            }
            sim.start = argv[++i];
            if (sim.start != "red" && sim.start != "blue" &&
                sim.start != "alternate" && sim.start != "random") {
                std::cerr << "--start must be one of: red, blue, alternate, random\n";
                return 1;
            }
        } else if (arg == "--games" || arg == "--seed" || arg == "--depth" ||
                   arg == "--time_ms" || arg == "--max_plies") {
            saw_sim_option = true;
            if (i + 1 >= argc) {
                std::cerr << "Missing value for " << arg << "\n";
                print_usage(argv[0]);
                return 1;
            }
            int v = 0;
            if (!parse_i32_arg(argv[++i], v)) {
                std::cerr << "Invalid integer for " << arg << ": " << argv[i] << "\n";
                return 1;
            }
            if (arg == "--games") {
                if (v <= 0) { std::cerr << "--games must be > 0\n"; return 1; }
                sim.games = v;
            } else if (arg == "--seed") {
                sim.seed = v;
            } else if (arg == "--depth") {
                if (v <= 0) { std::cerr << "--depth must be > 0\n"; return 1; }
                sim.depth = v;
            } else if (arg == "--time_ms") {
                if (v <= 0) { std::cerr << "--time_ms must be > 0\n"; return 1; }
                sim.time_ms = v;
            } else if (arg == "--max_plies") {
                if (v <= 0) { std::cerr << "--max_plies must be > 0\n"; return 1; }
                sim.max_plies = v;
            }
        } else {
            std::cerr << "Unknown option: " << arg << "\n";
            print_usage(argv[0]);
            return 1;
        }
    }

    if (!sim.enabled && saw_sim_option) {
        std::cerr << "Simulation options require --sim\n";
        print_usage(argv[0]);
        return 1;
    }
    std::string eval_note;
    if (!configure_eval_backend(eval_backend_mode, &eval_note)) {
        std::cerr << "Invalid value for --eval_backend: " << eval_backend_mode
                  << " (expected: auto | cpu | webgpu)\n";
        print_usage(argv[0]);
        return 1;
    }
    if (!eval_note.empty()) {
        std::cerr << "[eval] " << eval_note << "\n";
    }
    std::cerr << "[eval] active backend: " << eval_backend_name(active_eval_backend()) << "\n";
    if (sim.enabled) return run_headless_sim(sim);

    SDL_SetMainReady();
    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO) != 0) {
        SDL_Log("SDL_Init failed: %s", SDL_GetError());
        return 1;
    }
    if (!(IMG_Init(IMG_INIT_PNG) & IMG_INIT_PNG)) {
        SDL_Log("IMG_Init failed: %s", IMG_GetError());
        SDL_Quit(); return 1;
    }
    init_fonts();
    init_audio();
    init_zobrist();
    tt_ensure_allocated();

    SDL_Window* win = SDL_CreateWindow(
        "Commander Chess",
        SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,
        WIN_W, WIN_H, SDL_WINDOW_SHOWN);
    if (!win) { SDL_Log("Window failed: %s", SDL_GetError()); return 1; }

    SDL_Renderer* ren = SDL_CreateRenderer(win, -1,
        SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);
    if (!ren) { SDL_Log("Renderer failed: %s", SDL_GetError()); return 1; }
    SDL_SetRenderDrawBlendMode(ren, SDL_BLENDMODE_BLEND);

    load_all_textures(ren);
    Game game;
    bool running = true;

    // ── Window layout (absolute coords) ───────────────────────────────────
    //  y=0               : title bar         (TITLE_H px)
    //  y=TITLE_H         : status bar        (STATUS_H px)
    //  y=TITLE_H+STATUS_H: board             (BH px, x=0..BW)
    //  x=BW              : side panel        (PANEL_W px, full height)
    // No separate bottom button bar — buttons live at bottom of panel

    int board_top = TITLE_H + STATUS_H;

    // Clickable buttons
    // "New Game" and "Quit" sit at the very bottom of the panel
    int btn_y  = WIN_H - 38;
    int btn_w  = (PANEL_W - 24) / 2;

    // Difficulty radio-button hit areas (inside panel)
    // These are handled by checking proximity to the radio buttons drawn by draw_panel
    // Simpler: define 3 wide hit-rects spanning where the text labels are
    int diff_y = TITLE_H + 8 + 16 + 8 + 18;  // matches draw_panel layout
    int rbx0 = BW + 10;

    std::vector<Button> game_buttons = {
        // New Game button (bottom of panel, left half)
        {{BW+8,   btn_y, btn_w, 30}, "New Game", [&](){ game.open_mode_menu(); }},
        // Quit button (bottom of panel, right half)
        {{BW+8+btn_w+8, btn_y, btn_w, 30}, "Quit", [&](){ running=false; }},
        // Difficulty — wide tap targets
        {{rbx0,      diff_y, 70, 16}, "Beginner",     [&](){ game.set_difficulty(0); }},
        {{rbx0+72,   diff_y, 90, 16}, "Intermediate", [&](){ game.set_difficulty(1); }},
        {{rbx0+164,  diff_y, 60, 16}, "Expert",       [&](){ game.set_difficulty(2); }},
    };

    SDL_Event ev;
    while (running) {
        while (SDL_PollEvent(&ev)) {
            if (ev.type == SDL_QUIT) running = false;
            else if (ev.type == SDL_MOUSEBUTTONDOWN && ev.button.button == SDL_BUTTON_LEFT) {
                int mx=ev.button.x, my=ev.button.y;
                bool hit = false;
                auto inside = [&](const SDL_Rect& rc) {
                    return mx>=rc.x && mx<rc.x+rc.w && my>=rc.y && my<rc.y+rc.h;
                };

                if (game.show_mode_menu) {
                    for (int i = 0; i < 4; i++) {
                        SDL_Rect rc = mode_menu_card_rect(i);
                        if (inside(rc)) {
                            game.set_game_mode(mode_for_menu_index(i));
                            hit = true;
                            break;
                        }
                    }
                    if (!hit) {
                        SDL_Rect sr = mode_menu_side_rect(0);
                        if (inside(sr)) {
                            game.set_player_side("red");
                            hit = true;
                        }
                    }
                    if (!hit) {
                        SDL_Rect sb = mode_menu_side_rect(1);
                        if (inside(sb)) {
                            game.set_player_side("blue");
                            hit = true;
                        }
                    }
                    if (!hit) {
                        SDL_Rect s = mode_menu_start_rect();
                        if (inside(s)) {
                            game.start_selected_mode_game();
                            hit = true;
                        }
                    }
                    if (!hit) {
                        SDL_Rect q = mode_menu_quit_rect();
                        if (inside(q)) {
                            running = false;
                            hit = true;
                        }
                    }
                } else {
                    for (auto& b : game_buttons) {
                        if (inside(b.rect)) {
                            b.action(); hit=true; break;
                        }
                    }
                    if (!hit && mx >= BW) {
                        int nav = move_log_nav_from_panel_click(game, mx, my);
                        if (nav < 0) {
                            game.review_prev_move();
                            hit = true;
                        } else if (nav > 0) {
                            game.review_next_move();
                            hit = true;
                        }
                    }
                    if (!hit && mx >= BW) {
                        int mv_idx = move_log_index_from_panel_click(game, mx, my);
                        if (mv_idx >= 0) {
                            game.review_move_at(mv_idx);
                            hit = true;
                        }
                    }
                    // Board click — translate to board-local coords
                    if (!hit && mx<BW && my>=board_top && my<board_top+BH)
                        game.on_click(mx, my - board_top);
                }
            }
        }
        game.check_cpu_done();

        // ── Render ────────────────────────────────────────────────────────
        set_draw_color(ren, C_BG);
        SDL_RenderClear(ren);

        // Title
        draw_title(ren);
        // Status bar
        draw_status(ren, game);
        if (game.show_mode_menu) {
            draw_mode_selection_screen(ren, game);
        } else {
            // Board (in viewport so cx/cy work in board-local coords)
            {
                SDL_Rect vp = {0, board_top, BW, BH};
                SDL_RenderSetViewport(ren, &vp);
                draw_board(ren);
                draw_last_move_trail(ren, game);
                draw_highlights(ren, game);
                draw_pieces(ren, game);
                SDL_RenderSetViewport(ren, nullptr);
            }
            // Side panel
            draw_panel(ren, game);
            // New Game / Quit buttons at bottom of panel
            draw_button(ren, game_buttons[0].rect.x, game_buttons[0].rect.y,
                             game_buttons[0].rect.w, game_buttons[0].rect.h,
                             "New Game", {0x58,0xc8,0x8c,0xff});
            draw_button(ren, game_buttons[1].rect.x, game_buttons[1].rect.y,
                             game_buttons[1].rect.w, game_buttons[1].rect.h,
                             "Quit", {0x90,0xa4,0xae,0xff});
            // Game-over overlay
            if (game.state == GameState::GAME_OVER)
                draw_game_over(ren, game);
        }

        SDL_RenderPresent(ren);
        SDL_Delay(16);
    }

    // Cleanup
    for (auto& kv : g_textures)       SDL_DestroyTexture(kv.second);
    for (auto& kv : g_textures_small) SDL_DestroyTexture(kv.second);
    if (g_audio_dev) SDL_CloseAudioDevice(g_audio_dev);
    if (g_fnt_sm)   TTF_CloseFont(g_fnt_sm);
    if (g_fnt_md)   TTF_CloseFont(g_fnt_md);
    if (g_fnt_lg)   TTF_CloseFont(g_fnt_lg);
    if (g_fnt_xl)   TTF_CloseFont(g_fnt_xl);
    if (g_fnt_btn)  TTF_CloseFont(g_fnt_btn);
    if (g_fnt_head) TTF_CloseFont(g_fnt_head);
    TTF_Quit();
    SDL_DestroyRenderer(ren);
    SDL_DestroyWindow(win);
    IMG_Quit();
    SDL_Quit();
    return 0;
}
